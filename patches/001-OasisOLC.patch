diff -BENbdpru circle-3.1/src/Makefile.in circle3.1_oasis206/src/Makefile.in
--- circle-3.1/src/Makefile.in	2002-11-18 22:23:38.000000000 +0100
+++ circle3.1_oasis206/src/Makefile.in	2003-10-07 12:06:30.000000000 +0200
@@ -29,15 +29,19 @@ OBJFILES = act.comm.o act.informative.o 
 	graph.o handler.o house.o interpreter.o limits.o magic.o mail.o \
 	mobact.o modify.o objsave.o olc.o random.o shop.o spec_assign.o \
 	spec_procs.o spell_parser.o spells.o utils.o weather.o \
-	bsd-snprintf.o
+	bsd-snprintf.o cedit.o genmob.o genobj.o genolc.o genshp.o genwld.o \
+	genzon.o improved-edit.o medit.o oasis.o oasis_copy.o oasis_delete.o \
+	oasis_list.o oedit.o redit.o sedit.o tedit.o zedit.o aedit.o
 
 CXREF_FILES = act.comm.c act.informative.c act.item.c act.movement.c \
 	act.offensive.c act.other.c act.social.c act.wizard.c alias.c ban.c \
 	boards.c castle.c class.c comm.c config.c constants.c db.c fight.c \
 	graph.c handler.c house.c interpreter.c limits.c magic.c mail.c \
-	mobact.c modify.c objsave.c olc.c random.c shop.c spec_assign.c\
+	mobact.c modify.c objsave.c olc.c random.c shop.c spec_assign.c \
 	spec_procs.c spell_parser.c spells.c utils.c weather.c \
-	bsd-snprintf.c
+	bsd-snprintf.c cedit.c genmob.c genobj.c genolc.c genshp.c genwld.c \
+	genzon.c improved-edit.c medit.c oasis.c oasis_copy.c oasis_delete.c \
+	oasis_list.c oedit.c redit.c sedit.c tedit.c zedit.c aedit.o
 
 default: all
 
@@ -96,111 +100,7 @@ ref:
 # Dependencies for the object files (automagically generated with
 # gcc -MM)
 
-act.comm.o: act.comm.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
-  handler.h db.h screen.h
-	$(CC) -c $(CFLAGS) act.comm.c
-act.informative.o: act.informative.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h screen.h constants.h
-	$(CC) -c $(CFLAGS) act.informative.c
-act.item.o: act.item.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
-  handler.h db.h spells.h constants.h
-	$(CC) -c $(CFLAGS) act.item.c
-act.movement.o: act.movement.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h house.h constants.h
-	$(CC) -c $(CFLAGS) act.movement.c
-act.offensive.o: act.offensive.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h
-	$(CC) -c $(CFLAGS) act.offensive.c
-act.other.o: act.other.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
-  handler.h db.h spells.h screen.h house.h constants.h
-	$(CC) -c $(CFLAGS) act.other.c
-act.social.o: act.social.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h
-	$(CC) -c $(CFLAGS) act.social.c
-act.wizard.o: act.wizard.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h house.h screen.h constants.h
-	$(CC) -c $(CFLAGS) act.wizard.c
-alias.o: alias.c conf.h sysdep.h structs.h utils.h interpreter.h db.h
-	$(CC) -c $(CFLAGS) alias.c
-ban.o: ban.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h handler.h db.h
-	$(CC) -c $(CFLAGS) ban.c
-boards.o: boards.c conf.h sysdep.h structs.h utils.h comm.h db.h boards.h \
-  interpreter.h handler.h
-	$(CC) -c $(CFLAGS) boards.c
-castle.o: castle.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
-  handler.h db.h spells.h
-	$(CC) -c $(CFLAGS) castle.c
-class.o: class.c conf.h sysdep.h structs.h db.h utils.h spells.h interpreter.h \
-  constants.h
-	$(CC) -c $(CFLAGS) class.c
-comm.o: comm.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h handler.h \
-  db.h house.h
-	$(CC) -c $(CFLAGS) comm.c
-config.o: config.c conf.h sysdep.h structs.h interpreter.h
-	$(CC) -c $(CFLAGS) config.c
-constants.o: constants.c conf.h sysdep.h structs.h interpreter.h
-	$(CC) -c $(CFLAGS) constants.c
-db.o: db.c conf.h sysdep.h structs.h utils.h db.h comm.h handler.h spells.h mail.h \
-  interpreter.h house.h constants.h
-	$(CC) -c $(CFLAGS) db.c
-fight.o: fight.c conf.h sysdep.h structs.h utils.h comm.h handler.h interpreter.h \
-  db.h spells.h screen.h constants.h
-	$(CC) -c $(CFLAGS) fight.c
-graph.o: graph.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h handler.h \
-  db.h spells.h
-	$(CC) -c $(CFLAGS) graph.c
-handler.o: handler.c conf.h sysdep.h structs.h utils.h comm.h db.h handler.h \
-  interpreter.h spells.h
-	$(CC) -c $(CFLAGS) handler.c
-house.o: house.c conf.h sysdep.h structs.h comm.h handler.h db.h interpreter.h \
-  utils.h house.h constants.h
-	$(CC) -c $(CFLAGS) house.c
-interpreter.o: interpreter.c conf.h sysdep.h structs.h comm.h interpreter.h db.h \
-  utils.h spells.h handler.h mail.h screen.h
-	$(CC) -c $(CFLAGS) interpreter.c
-limits.o: limits.c conf.h sysdep.h structs.h utils.h spells.h comm.h db.h \
-  handler.h
-	$(CC) -c $(CFLAGS) limits.c
-magic.o: magic.c conf.h sysdep.h structs.h utils.h comm.h spells.h handler.h db.h \
-  constants.h
-	$(CC) -c $(CFLAGS) magic.c
-mail.o: mail.c conf.h sysdep.h structs.h utils.h comm.h db.h interpreter.h \
-  handler.h mail.h
-	$(CC) -c $(CFLAGS) mail.c
-mobact.o: mobact.c conf.h sysdep.h structs.h utils.h db.h comm.h interpreter.h \
-  handler.h spells.h constants.h
-	$(CC) -c $(CFLAGS) mobact.c
-modify.o: modify.c conf.h sysdep.h structs.h utils.h interpreter.h handler.h db.h \
-  comm.h spells.h mail.h boards.h
-	$(CC) -c $(CFLAGS) modify.c
-objsave.o: objsave.c conf.h sysdep.h structs.h comm.h handler.h db.h \
-  interpreter.h utils.h spells.h
-	$(CC) -c $(CFLAGS) objsave.c
-olc.o: olc.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h handler.h db.h \
-  olc.h
-	$(CC) -c $(CFLAGS) olc.c
-random.o: random.c utils.h
-	$(CC) -c $(CFLAGS) random.c
-shop.o: shop.c conf.h sysdep.h structs.h comm.h handler.h db.h interpreter.h \
-  utils.h shop.h constants.h
-	$(CC) -c $(CFLAGS) shop.c
-spec_assign.o: spec_assign.c conf.h sysdep.h structs.h db.h interpreter.h \
-  utils.h
-	$(CC) -c $(CFLAGS) spec_assign.c
-spec_procs.o: spec_procs.c conf.h sysdep.h structs.h utils.h comm.h \
-  interpreter.h handler.h db.h spells.h constants.h
-	$(CC) -c $(CFLAGS) spec_procs.c
-spell_parser.o: spell_parser.c conf.h sysdep.h structs.h utils.h interpreter.h \
-  spells.h handler.h comm.h db.h
-	$(CC) -c $(CFLAGS) spell_parser.c
-spells.o: spells.c conf.h sysdep.h structs.h utils.h comm.h spells.h handler.h \
-  db.h constants.h interpreter.h
-	$(CC) -c $(CFLAGS) spells.c
-utils.o: utils.c conf.h sysdep.h structs.h utils.h comm.h screen.h spells.h \
-  handler.h db.h interpreter.h
-	$(CC) -c $(CFLAGS) utils.c
-weather.o: weather.c conf.h sysdep.h structs.h utils.h comm.h handler.h \
-  interpreter.h db.h
-	$(CC) -c $(CFLAGS) weather.c
-bsd-snprintf.o: bsd-snprintf.c conf.h sysdep.h
-	$(CC) -c $(CFLAGS) bsd-snprintf.c
+depend:
+	$(CC) -MM *.c > depend
+
+-include depend
diff -BENbdpru circle-3.1/src/act.comm.c circle3.1_oasis206/src/act.comm.c
--- circle-3.1/src/act.comm.c	2002-09-26 02:38:48.000000000 +0200
+++ circle3.1_oasis206/src/act.comm.c	2003-07-26 10:19:22.000000000 +0200
@@ -19,10 +19,7 @@
 #include "handler.h"
 #include "db.h"
 #include "screen.h"
-
-/* extern variables */
-extern int level_can_shout;
-extern int holler_move_cost;
+#include "improved-edit.h"
 
 /* local functions */
 void perform_tell(struct char_data *ch, struct char_data *vict, char *arg);
@@ -51,7 +48,7 @@ ACMD(do_say)
     act(buf, FALSE, ch, 0, 0, TO_ROOM);
 
     if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
     else {
       delete_doubledollar(argument);
       send_to_char(ch, "You say, '%s'\r\n", argument);
@@ -90,7 +87,7 @@ ACMD(do_gsay)
 	act(buf, FALSE, ch, 0, f->follower, TO_VICT | TO_SLEEP);
 
     if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
     else
       send_to_char(ch, "You tell the group, '%s'\r\n", argument);
   }
@@ -107,7 +104,7 @@ void perform_tell(struct char_data *ch, 
   send_to_char(vict, "%s", CCNRM(vict, C_NRM));
 
   if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
   else {
     send_to_char(ch, "%s", CCRED(ch, C_CMP));
     snprintf(buf, sizeof(buf), "You tell $N, '%s'", arg);
@@ -153,9 +150,9 @@ ACMD(do_tell)
   if (!*buf || !*buf2)
     send_to_char(ch, "Who do you wish to tell what??\r\n");
   else if (GET_LEVEL(ch) < LVL_IMMORT && !(vict = get_player_vis(ch, buf, NULL, FIND_CHAR_WORLD)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (GET_LEVEL(ch) >= LVL_IMMORT && !(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_WORLD)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (is_tell_ok(ch, vict))
     perform_tell(ch, vict, buf2);
 }
@@ -229,7 +226,7 @@ ACMD(do_spec_comm)
   if (!*buf || !*buf2)
     send_to_char(ch, "Whom do you want to %s.. and what??\r\n", action_sing);
   else if (!(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_ROOM)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (vict == ch)
     send_to_char(ch, "You can't get your mouth close enough to your ear...\r\n");
   else {
@@ -239,7 +236,7 @@ ACMD(do_spec_comm)
     act(buf1, FALSE, ch, 0, vict, TO_VICT);
 
     if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
     else
       send_to_char(ch, "You %s %s, '%s'\r\n", action_sing, GET_NAME(vict), buf2);
     act(action_others, FALSE, ch, 0, vict, TO_NOTVICT);
@@ -311,13 +308,20 @@ ACMD(do_write)
     act("$p is no good for writing with.", FALSE, ch, pen, 0, TO_CHAR);
   else if (GET_OBJ_TYPE(paper) != ITEM_NOTE)
     act("You can't write on $p.", FALSE, ch, paper, 0, TO_CHAR);
-  else if (paper->action_description)
-    send_to_char(ch, "There's something written on it already.\r\n");
   else {
+    char *backstr = NULL;
+ 
+    /* Something on it, display it as that's in input buffer. */
+    if (paper->action_description) {
+      backstr = strdup(paper->action_description);
+      send_to_char(ch, "There's something written on it already:\r\n");
+      send_to_char(ch, "%s", paper->action_description);
+    }
+ 
     /* we can write - hooray! */
-    send_to_char(ch, "Write your note.  End with '@' on a new line.\r\n");
     act("$n begins to jot down a note.", TRUE, ch, 0, 0, TO_ROOM);
-    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH, 0, NULL);
+    send_editor_help(ch->desc);
+    string_write(ch->desc, &paper->action_description, MAX_NOTE_LENGTH, 0, backstr);
   }
 }
 
@@ -351,7 +355,7 @@ ACMD(do_page)
     if ((vict = get_char_vis(ch, arg, NULL, FIND_CHAR_WORLD)) != NULL) {
       act(buf, FALSE, ch, 0, vict, TO_VICT);
       if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-	send_to_char(ch, "%s", OK);
+	send_to_char(ch, "%s", CONFIG_OK);
       else
 	act(buf, FALSE, ch, 0, vict, TO_CHAR);
     } else
@@ -426,8 +430,8 @@ ACMD(do_gen_comm)
     return;
   }
   /* level_can_shout defined in config.c */
-  if (GET_LEVEL(ch) < level_can_shout) {
-    send_to_char(ch, "You must be at least level %d before you can %s.\r\n", level_can_shout, com_msgs[subcmd][1]);
+  if (GET_LEVEL(ch) < CONFIG_LEVEL_CAN_SHOUT) {
+    send_to_char(ch, "You must be at least level %d before you can %s.\r\n", CONFIG_LEVEL_CAN_SHOUT, com_msgs[subcmd][1]);
     return;
   }
   /* make sure the char is on the channel */
@@ -444,20 +448,20 @@ ACMD(do_gen_comm)
     return;
   }
   if (subcmd == SCMD_HOLLER) {
-    if (GET_MOVE(ch) < holler_move_cost) {
+    if (GET_MOVE(ch) < CONFIG_HOLLER_MOVE_COST) {
       send_to_char(ch, "You're too exhausted to holler.\r\n");
       return;
     } else
-      GET_MOVE(ch) -= holler_move_cost;
+      GET_MOVE(ch) -= CONFIG_HOLLER_MOVE_COST;
   }
   /* set up the color on code */
   strlcpy(color_on, com_msgs[subcmd][3], sizeof(color_on));
 
   /* first, set up strings to be given to the communicator */
   if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
   else
-    send_to_char(ch, "%sYou %s, '%s'%s\r\n", COLOR_LEV(ch) >= C_CMP ? color_on : "", com_msgs[subcmd][1], argument, CCNRM(ch, C_CMP));
+    send_to_char(ch, "%sYou %s, '%s'%s", COLOR_LEV(ch) >= C_CMP ? color_on : "", com_msgs[subcmd][1], argument, CCNRM(ch, C_CMP));
 
   snprintf(buf1, sizeof(buf1), "$n %ss, '%s'", com_msgs[subcmd][1], argument);
 
@@ -498,7 +502,7 @@ ACMD(do_qcomm)
     struct descriptor_data *i;
 
     if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
     else if (subcmd == SCMD_QSAY) {
       snprintf(buf, sizeof(buf), "You quest-say, '%s'", argument);
       act(buf, FALSE, ch, 0, argument, TO_CHAR);
diff -BENbdpru circle-3.1/src/act.informative.c circle3.1_oasis206/src/act.informative.c
--- circle-3.1/src/act.informative.c	2002-09-26 02:41:38.000000000 +0200
+++ circle3.1_oasis206/src/act.informative.c	2003-10-07 11:24:50.000000000 +0200
@@ -1026,7 +1026,7 @@ ACMD(do_who)
   send_to_char(ch, "Players\r\n-------\r\n");
 
   for (d = descriptor_list; d; d = d->next) {
-    if (STATE(d) != CON_PLAYING)
+    if (!IS_PLAYING(d))
       continue;
 
     if (d->original)
@@ -1070,9 +1070,34 @@ ACMD(do_who)
 
       if (PLR_FLAGGED(tch, PLR_MAILING))
 	send_to_char(ch, " (mailing)");
+      else if (d->olc)
+	send_to_char(ch, " (OLC)");
       else if (PLR_FLAGGED(tch, PLR_WRITING))
 	send_to_char(ch, " (writing)");
 
+      if (d->original)
+        send_to_char(ch, " (out of body)");
+       
+      if (d->connected == CON_OEDIT)
+        send_to_char(ch, " (Object Edit)");
+      if (d->connected == CON_MEDIT)
+        send_to_char(ch, " (Mobile Edit)");
+      if (d->connected == CON_ZEDIT)
+        send_to_char(ch, " (Zone Edit)");
+      if (d->connected == CON_SEDIT)
+        send_to_char(ch, " (Shop Edit)");
+      if (d->connected == CON_REDIT)
+        send_to_char(ch, " (Room Edit)");
+      if (d->connected == CON_TEDIT)
+        send_to_char(ch, " (Text Edit)");
+      if (d->connected == CON_AEDIT)
+        send_to_char(ch, " (Social Edit)");
+      if (d->connected == CON_CEDIT)
+        send_to_char(ch, " (Configuration Edit)");
+
+      if (PRF_FLAGGED(tch, PRF_BUILDWALK))
+	send_to_char(ch, " (Buildwalking)");
+
       if (PRF_FLAGGED(tch, PRF_DEAF))
 	send_to_char(ch, " (deaf)");
       if (PRF_FLAGGED(tch, PRF_NOTELL))
@@ -1177,7 +1202,7 @@ ACMD(do_users)
       continue;
     if (STATE(d) == CON_PLAYING && deadweight)
       continue;
-    if (STATE(d) == CON_PLAYING) {
+    if (IS_PLAYING(d)) {
       if (d->original)
 	tch = d->original;
       else if (!(tch = d->character))
@@ -1283,6 +1308,7 @@ ACMD(do_gen_ps)
     break;
   case SCMD_VERSION:
     send_to_char(ch, "%s\r\n", circlemud_version);
+    send_to_char(ch, "%s\r\n", oasisolc_version);
     break;
   case SCMD_WHOAMI:
     send_to_char(ch, "%s\r\n", GET_NAME(ch));
@@ -1409,8 +1435,7 @@ ACMD(do_where)
 ACMD(do_levels)
 {
   char buf[MAX_STRING_LENGTH];
-  size_t i, len = 0;
-  int nlen;
+  size_t i, len = 0, nlen;
 
   if (IS_NPC(ch)) {
     send_to_char(ch, "You ain't nothin' but a hound-dog.\r\n");
@@ -1506,7 +1531,7 @@ ACMD(do_diagnose)
 
   if (*buf) {
     if (!(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_ROOM)))
-      send_to_char(ch, "%s", NOPERSON);
+      send_to_char(ch, "%s", CONFIG_NOPERSON);
     else
       diag_char_to_char(vict, ch);
   } else {
@@ -1561,6 +1586,14 @@ ACMD(do_toggle)
 
   if (GET_LEVEL(ch) >= LVL_IMMORT) {
     send_to_char(ch,
+          "      Buildwalk: %-3s    "
+          "Clear Screen in OLC: %-3s\r\n",
+        ONOFF(PRF_FLAGGED(ch, PRF_BUILDWALK)),
+        ONOFF(PRF_FLAGGED(ch, PRF_CLS))
+    );
+
+    
+    send_to_char(ch,
 	  "      No Hassle: %-3s    "
 	  "      Holylight: %-3s    "
 	  "     Room Flags: %-3s\r\n",
@@ -1619,7 +1652,8 @@ ACMD(do_toggle)
 
 int sort_commands_helper(const void *a, const void *b)
 {
-  return strcmp(cmd_info[*(const int *)a].command, cmd_info[*(const int *)b].command);
+  return strcmp(complete_cmd_info[*(const int *)a].sort_as, 
+                complete_cmd_info[*(const int *)b].sort_as);
 }
 
 
@@ -1627,7 +1661,7 @@ void sort_commands(void)
 {
   int a, num_of_cmds = 0;
 
-  while (cmd_info[num_of_cmds].command[0] != '\n')
+  while (complete_cmd_info[num_of_cmds].command[0] != '\n')
     num_of_cmds++;
   num_of_cmds++;	/* \n */
 
@@ -1673,19 +1707,19 @@ ACMD(do_commands)
 	  vict == ch ? "you" : GET_NAME(vict));
 
   /* cmd_num starts at 1, not 0, to remove 'RESERVED' */
-  for (no = 1, cmd_num = 1; cmd_info[cmd_sort_info[cmd_num]].command[0] != '\n'; cmd_num++) {
+  for (no = 1, cmd_num = 1; complete_cmd_info[cmd_sort_info[cmd_num]].command[0] != '\n'; cmd_num++) {
     i = cmd_sort_info[cmd_num];
 
-    if (cmd_info[i].minimum_level < 0 || GET_LEVEL(vict) < cmd_info[i].minimum_level)
+    if (complete_cmd_info[i].minimum_level < 0 || GET_LEVEL(vict) < complete_cmd_info[i].minimum_level)
       continue;
 
-    if ((cmd_info[i].minimum_level >= LVL_IMMORT) != wizhelp)
+    if ((complete_cmd_info[i].minimum_level >= LVL_IMMORT) != wizhelp)
       continue;
 
-    if (!wizhelp && socials != (cmd_info[i].command_pointer == do_action || cmd_info[i].command_pointer == do_insult))
+    if (!wizhelp && socials != (complete_cmd_info[i].command_pointer == do_action || complete_cmd_info[i].command_pointer == do_insult))
       continue;
 
-    send_to_char(ch, "%-11s%s", cmd_info[i].command, no++ % 7 == 0 ? "\r\n" : "");
+    send_to_char(ch, "%-11s%s", complete_cmd_info[i].command, no++ % 7 == 0 ? "\r\n" : "");
   }
 
   if (no % 7 != 1)
diff -BENbdpru circle-3.1/src/act.item.c circle3.1_oasis206/src/act.item.c
--- circle-3.1/src/act.item.c	2002-09-26 01:44:46.000000000 +0200
+++ circle3.1_oasis206/src/act.item.c	2003-07-26 10:19:22.000000000 +0200
@@ -21,13 +21,6 @@
 #include "spells.h"
 #include "constants.h"
 
-/* extern variables */
-extern room_rnum donation_room_1;
-#if 0
-extern room_rnum donation_room_2;  /* uncomment if needed! */
-extern room_rnum donation_room_3;  /* uncomment if needed! */
-#endif
-
 /* local functions */
 int can_take_obj(struct char_data *ch, struct obj_data *obj);
 void get_check_money(struct char_data *ch, struct obj_data *obj);
@@ -495,7 +488,7 @@ ACMD(do_drop)
   struct obj_data *obj, *next_obj;
   room_rnum RDR = 0;
   byte mode = SCMD_DROP;
-  int dotmode, amount = 0, multi;
+  int dotmode, amount = 0, multi, num_don_rooms;
   const char *sname;
 
   switch (subcmd) {
@@ -506,17 +499,21 @@ ACMD(do_drop)
   case SCMD_DONATE:
     sname = "donate";
     mode = SCMD_DONATE;
-    switch (rand_number(0, 2)) {
+    /* fail + double chance for room 1   */
+    num_don_rooms = (CONFIG_DON_ROOM_1 != NOWHERE) * 2 +       
+                    (CONFIG_DON_ROOM_2 != NOWHERE)     +
+                    (CONFIG_DON_ROOM_3 != NOWHERE)     + 1 ; 
+    switch (rand_number(0, num_don_rooms)) {
     case 0:
       mode = SCMD_JUNK;
       break;
     case 1:
     case 2:
-      RDR = real_room(donation_room_1);
+      RDR = real_room(CONFIG_DON_ROOM_1);
       break;
-/*    case 3: RDR = real_room(donation_room_2); break;
-      case 4: RDR = real_room(donation_room_3); break;
-*/
+    case 3: RDR = real_room(CONFIG_DON_ROOM_2); break;
+    case 4: RDR = real_room(CONFIG_DON_ROOM_3); break;
+
     }
     if (RDR == NOWHERE) {
       send_to_char(ch, "Sorry, you can't donate anything right now.\r\n");
@@ -630,7 +627,7 @@ struct char_data *give_find_vict(struct 
   if (!*arg)
     send_to_char(ch, "To who?\r\n");
   else if (!(vict = get_char_vis(ch, arg, NULL, FIND_CHAR_ROOM)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (vict == ch)
     send_to_char(ch, "What's the point of that?\r\n");
   else
@@ -653,7 +650,7 @@ void perform_give_gold(struct char_data 
     send_to_char(ch, "You don't have that many coins!\r\n");
     return;
   }
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
 
   snprintf(buf, sizeof(buf), "$n gives you %d gold coin%s.", amount, amount == 1 ? "" : "s");
   act(buf, FALSE, ch, 0, vict, TO_VICT);
@@ -1330,6 +1327,8 @@ ACMD(do_wear)
     }
     if (!(obj = get_obj_in_list_vis(ch, arg1, NULL, ch->carrying)))
       send_to_char(ch, "You don't seem to have any %ss.\r\n", arg1);
+    else if (GET_LEVEL(ch) < GET_OBJ_LEVEL(obj))
+      send_to_char(ch, "You are not experienced enough to use that.\r\n");
     else
       while (obj) {
 	next_obj = get_obj_in_list_vis(ch, arg1, NULL, obj->next_content);
diff -BENbdpru circle-3.1/src/act.movement.c circle3.1_oasis206/src/act.movement.c
--- circle-3.1/src/act.movement.c	2002-05-02 04:58:40.000000000 +0200
+++ circle3.1_oasis206/src/act.movement.c	2003-10-06 21:13:54.000000000 +0200
@@ -22,14 +22,11 @@
 #include "house.h"
 #include "constants.h"
 
-
-/* external variables  */
-extern int tunnel_size;
-
 /* external functions */
 int special(struct char_data *ch, int cmd, char *arg);
 void death_cry(struct char_data *ch);
 int find_eq_pos(struct char_data *ch, struct obj_data *obj, char *arg);
+int buildwalk(struct char_data *ch, int dir);
 
 /* local functions */
 int has_boat(struct char_data *ch);
@@ -136,8 +133,8 @@ int do_simple_move(struct char_data *ch,
     }
   }
   if (ROOM_FLAGGED(EXIT(ch, dir)->to_room, ROOM_TUNNEL) &&
-      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) >= tunnel_size) {
-    if (tunnel_size > 1)
+      num_pc_in_room(&(world[EXIT(ch, dir)->to_room])) >= CONFIG_TUNNEL_SIZE) {
+    if (CONFIG_TUNNEL_SIZE > 1)
       send_to_char(ch, "There isn't enough room for you to go there!\r\n");
     else
       send_to_char(ch, "There isn't enough room there for more than one person!\r\n");
@@ -187,7 +184,7 @@ int perform_move(struct char_data *ch, i
 
   if (ch == NULL || dir < 0 || dir >= NUM_OF_DIRS || FIGHTING(ch))
     return (0);
-  else if (!EXIT(ch, dir) || EXIT(ch, dir)->to_room == NOWHERE)
+  else if ((!EXIT(ch, dir) && !buildwalk(ch, dir)) || EXIT(ch, dir)->to_room == NOWHERE)
     send_to_char(ch, "Alas, you cannot go that way...\r\n");
   else if (EXIT_FLAGGED(EXIT(ch, dir), EX_CLOSED)) {
     if (EXIT(ch, dir)->keyword)
@@ -343,14 +340,14 @@ void do_doorcmd(struct char_data *ch, st
     OPEN_DOOR(IN_ROOM(ch), obj, door);
     if (back)
       OPEN_DOOR(other_room, obj, rev_dir[door]);
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     break;
 
   case SCMD_CLOSE:
     CLOSE_DOOR(IN_ROOM(ch), obj, door);
     if (back)
       CLOSE_DOOR(other_room, obj, rev_dir[door]);
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     break;
 
   case SCMD_LOCK:
@@ -385,7 +382,7 @@ void do_doorcmd(struct char_data *ch, st
 
   /* Notify the other room */
   if (back && (scmd == SCMD_OPEN || scmd == SCMD_CLOSE))
-      send_to_room(EXIT(ch, door)->to_room, "The %s is %s%s from the other side.",
+      send_to_room(EXIT(ch, door)->to_room, "The %s is %s%s from the other side.\r\n",
 		back->keyword ? fname(back->keyword) : "door", cmd_door[scmd],
 		scmd == SCMD_CLOSE ? "d" : "ed");
 }
@@ -663,7 +660,7 @@ ACMD(do_wake)
     if (GET_POS(ch) == POS_SLEEPING)
       send_to_char(ch, "Maybe you should wake yourself up first.\r\n");
     else if ((vict = get_char_vis(ch, arg, NULL, FIND_CHAR_ROOM)) == NULL)
-      send_to_char(ch, "%s", NOPERSON);
+      send_to_char(ch, "%s", CONFIG_NOPERSON);
     else if (vict == ch)
       self = 1;
     else if (AWAKE(vict))
@@ -701,7 +698,7 @@ ACMD(do_follow)
 
   if (*buf) {
     if (!(leader = get_char_vis(ch, buf, NULL, FIND_CHAR_ROOM))) {
-      send_to_char(ch, "%s", NOPERSON);
+      send_to_char(ch, "%s", CONFIG_NOPERSON);
       return;
     }
   } else {
diff -BENbdpru circle-3.1/src/act.offensive.c circle3.1_oasis206/src/act.offensive.c
--- circle-3.1/src/act.offensive.c	2002-02-01 03:04:18.000000000 +0100
+++ circle3.1_oasis206/src/act.offensive.c	2003-07-26 10:19:22.000000000 +0200
@@ -20,9 +20,6 @@
 #include "db.h"
 #include "spells.h"
 
-/* extern variables */
-extern int pk_allowed;
-
 /* extern functions */
 void raw_kill(struct char_data *ch);
 void check_killer(struct char_data *ch, struct char_data *vict);
@@ -54,7 +51,7 @@ ACMD(do_assist)
   if (!*arg)
     send_to_char(ch, "Whom do you wish to assist?\r\n");
   else if (!(helpee = get_char_vis(ch, arg, NULL, FIND_CHAR_ROOM)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (helpee == ch)
     send_to_char(ch, "You can't help yourself any more than this!\r\n");
   else {
@@ -73,7 +70,8 @@ ACMD(do_assist)
       act("But nobody is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
     else if (!CAN_SEE(ch, opponent))
       act("You can't see who is fighting $M!", FALSE, ch, 0, helpee, TO_CHAR);
-    else if (!pk_allowed && !IS_NPC(opponent))	/* prevent accidental pkill */
+         /* prevent accidental pkill */
+    else if (!CONFIG_PK_ALLOWED && !IS_NPC(opponent))	
       act("Use 'murder' if you really want to attack $N.", FALSE,
 	  ch, 0, opponent, TO_CHAR);
     else {
@@ -103,7 +101,7 @@ ACMD(do_hit)
   } else if (AFF_FLAGGED(ch, AFF_CHARM) && (ch->master == vict))
     act("$N is just such a good friend, you simply can't hit $M.", FALSE, ch, 0, vict, TO_CHAR);
   else {
-    if (!pk_allowed) {
+    if (!CONFIG_PK_ALLOWED) {
       if (!IS_NPC(vict) && !IS_NPC(ch)) {
 	if (subcmd != SCMD_MURDER) {
 	  send_to_char(ch, "Use 'murder' to hit another player.\r\n");
@@ -239,7 +237,7 @@ ACMD(do_order)
       if ((vict->master != ch) || !AFF_FLAGGED(vict, AFF_CHARM))
 	act("$n has an indifferent look.", FALSE, vict, 0, 0, TO_ROOM);
       else {
-	send_to_char(ch, "%s", OK);
+	send_to_char(ch, "%s", CONFIG_OK);
 	command_interpreter(vict, message);
       }
     } else {			/* This is order "followers" */
@@ -256,7 +254,7 @@ ACMD(do_order)
 	  }
       }
       if (found)
-	send_to_char(ch, "%s", OK);
+	send_to_char(ch, "%s", CONFIG_OK);
       else
 	send_to_char(ch, "Nobody here is a loyal subject of yours!\r\n");
     }
diff -BENbdpru circle-3.1/src/act.other.c circle3.1_oasis206/src/act.other.c
--- circle-3.1/src/act.other.c	2002-09-26 02:39:10.000000000 +0200
+++ circle3.1_oasis206/src/act.other.c	2003-10-07 11:25:10.000000000 +0200
@@ -27,12 +27,6 @@
 /* extern variables */
 extern struct spell_info_type spell_info[];
 extern const char *class_abbrevs[];
-extern int free_rent;
-extern int pt_allowed;
-extern int max_filesize;
-extern int nameserver_is_slow;
-extern int auto_save;
-extern int track_through_doors;
 
 /* extern procedures */
 void list_skills(struct char_data *ch);
@@ -90,7 +84,7 @@ ACMD(do_quit)
      *  situation.
      */
 
-    if (free_rent)
+    if (CONFIG_FREE_RENT)
       Crash_rentsave(ch, 0);
 
     /* If someone is quitting in their house, let them load back here. */
@@ -117,7 +111,7 @@ ACMD(do_save)
      * that guest immortals aren't trustworthy. If you've disabled guest
      * immortal advances from mortality, you may want < instead of <=.
      */
-    if (auto_save && GET_LEVEL(ch) <= LVL_IMMORT) {
+    if (CONFIG_AUTO_SAVE && GET_LEVEL(ch) <= LVL_IMMORT) {
       send_to_char(ch, "Saving aliases.\r\n");
       write_aliases(ch);
       return;
@@ -227,7 +221,7 @@ ACMD(do_steal)
   if (GET_POS(vict) < POS_SLEEPING)
     percent = -1;		/* ALWAYS SUCCESS, unless heavy object. */
 
-  if (!pt_allowed && !IS_NPC(vict))
+  if (!CONFIG_PT_ALLOWED && !IS_NPC(vict))
     pcsteal = 1;
 
   if (!AWAKE(vict))	/* Easier to steal from sleeping people. */
@@ -442,7 +436,7 @@ ACMD(do_group)
   }
 
   if (!(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_ROOM)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if ((vict->master != ch) && (vict != ch))
     act("$N must follow you to enter your group.", FALSE, ch, 0, vict, TO_CHAR);
   else {
@@ -774,7 +768,7 @@ ACMD(do_display)
     }
   }
 
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
 }
 
 
@@ -822,7 +816,7 @@ ACMD(do_gen_write)
     perror("SYSERR: Can't stat() file");
     return;
   }
-  if (fbuf.st_size >= max_filesize) {
+  if (fbuf.st_size >= CONFIG_MAX_FILESIZE) {
     send_to_char(ch, "Sorry, the file is full right now.. try again later.\r\n");
     return;
   }
@@ -846,7 +840,7 @@ ACMD(do_gen_write)
 
 ACMD(do_gen_tog)
 {
-  long /* bitvector_t */ result;
+  long result;
 
   const char *tog_messages[][2] = {
     {"You are now safe from summoning by other players.\r\n",
@@ -882,7 +876,11 @@ ACMD(do_gen_tog)
     {"Autoexits disabled.\r\n",
     "Autoexits enabled.\r\n"},
     {"Will no longer track through doors.\r\n",
-    "Will now track through doors.\r\n"}
+    "Will now track through doors.\r\n"},
+    {"Will no longer clear screen in OLC.\r\n",
+    "Will now clear screen in OLC.\r\n"},
+    {"Buildwalk Off.\r\n",
+    "Buildwalk On.\r\n"}
   };
 
 
@@ -933,13 +931,29 @@ ACMD(do_gen_tog)
     result = PRF_TOG_CHK(ch, PRF_HOLYLIGHT);
     break;
   case SCMD_SLOWNS:
-    result = (nameserver_is_slow = !nameserver_is_slow);
+    result = (CONFIG_NS_IS_SLOW = !CONFIG_NS_IS_SLOW);
     break;
   case SCMD_AUTOEXIT:
     result = PRF_TOG_CHK(ch, PRF_AUTOEXIT);
     break;
   case SCMD_TRACK:
-    result = (track_through_doors = !track_through_doors);
+    result = (CONFIG_TRACK_T_DOORS = !CONFIG_TRACK_T_DOORS);
+    break;
+  case SCMD_CLS:
+    result = PRF_TOG_CHK(ch, PRF_CLS);
+    break;
+  case SCMD_BUILDWALK:
+    if (GET_LEVEL(ch) < LVL_BUILDER) {
+      send_to_char(ch, "Builders only, sorry.\r\n");  	
+      return;
+    }
+    result = PRF_TOG_CHK(ch, PRF_BUILDWALK);
+    if (PRF_FLAGGED(ch, PRF_BUILDWALK))
+      mudlog(CMP, GET_LEVEL(ch), TRUE, 
+             "OLC: %s turned buildwalk on. Allowed zone %d", GET_NAME(ch), GET_OLC_ZONE(ch));
+    else
+      mudlog(CMP, GET_LEVEL(ch), TRUE,
+             "OLC: %s turned buildwalk off. Allowed zone %d", GET_NAME(ch), GET_OLC_ZONE(ch));
     break;
   default:
     log("SYSERR: Unknown subcmd %d in do_gen_toggle.", subcmd);
diff -BENbdpru circle-3.1/src/act.social.c circle3.1_oasis206/src/act.social.c
--- circle-3.1/src/act.social.c	2002-02-01 03:04:18.000000000 +0100
+++ circle3.1_oasis206/src/act.social.c	2003-10-06 21:13:50.000000000 +0200
@@ -21,8 +21,9 @@
 #include "spells.h"
 
 
-/* local globals */
-static int list_top = -1;
+/* globals */
+extern int top_of_socialt;
+extern struct social_messg *soc_mess_list;
 
 /* local functions */
 char *fread_action(FILE *fl, int nr);
@@ -31,64 +32,15 @@ ACMD(do_action);
 ACMD(do_insult);
 void boot_social_messages(void);
 void free_social_messages(void);
-
-
-struct social_messg {
-  int act_nr;
-  int hide;
-  int min_victim_position;	/* Position of victim */
-
-  /* No argument was supplied */
-  char *char_no_arg;
-  char *others_no_arg;
-
-  /* An argument was there, and a victim was found */
-  char *char_found;		/* if NULL, read no further, ignore args */
-  char *others_found;
-  char *vict_found;
-
-  /* An argument was there, but no victim was found */
-  char *not_found;
-
-  /* The victim turned out to be the character */
-  char *char_auto;
-  char *others_auto;
-} *soc_mess_list;
-
-
-int find_action(int cmd)
-{
-  int bot, top, mid;
-
-  bot = 0;
-  top = list_top;
-
-  if (top < 0)
-    return (-1);
-
-  for (;;) {
-    mid = (bot + top) / 2;
-
-    if (soc_mess_list[mid].act_nr == cmd)
-      return (mid);
-    if (bot >= top)
-      return (-1);
-
-    if (soc_mess_list[mid].act_nr > cmd)
-      top = --mid;
-    else
-      bot = ++mid;
-  }
-}
-
-
+void free_action(struct social_messg *mess);
 
 ACMD(do_action)
 {
-  char buf[MAX_INPUT_LENGTH];
+  char arg[MAX_INPUT_LENGTH], part[MAX_INPUT_LENGTH];
   int act_nr;
   struct social_messg *action;
   struct char_data *vict;
+  struct obj_data *targ;
 
   if ((act_nr = find_action(cmd)) < 0) {
     send_to_char(ch, "That action is not supported.\r\n");
@@ -94,27 +46,65 @@ ACMD(do_action)
     send_to_char(ch, "That action is not supported.\r\n");
     return;
   }
+
   action = &soc_mess_list[act_nr];
 
+  if (!argument || !*argument) {
+    send_to_char(ch, "%s\r\n", action->char_no_arg);
+    act(action->others_no_arg, action->hide, ch, 0, 0, TO_ROOM);
+    return;
+  }
+
+  two_arguments(argument, arg, part);
+
+  if ((!action->char_body_found) && (*part)) {
+    send_to_char(ch, "Sorry, this social does not support body parts.\r\n");
+    return;
+  }
+
+  if (!action->char_found) 
+    *arg = '\0';
+
   if (action->char_found && argument)
-    one_argument(argument, buf);
+    one_argument(argument, arg);
   else
-    *buf = '\0';
+    *arg = '\0';
 
-  if (!*buf) {
-    send_to_char(ch, "%s\r\n", action->char_no_arg);
-    act(action->others_no_arg, action->hide, ch, 0, 0, TO_ROOM);
+  vict = get_char_vis(ch, arg, NULL, FIND_CHAR_ROOM);
+  if (!vict) {
+    if (action->char_obj_found) {
+      targ = get_obj_in_list_vis(ch, arg, NULL, ch->carrying);
+      if (!targ) targ = get_obj_in_list_vis(ch, arg, NULL, world[ch->in_room].contents);
+      if (targ) {
+        act(action->char_obj_found, action->hide, ch, targ, 0, TO_CHAR);
+        act(action->others_obj_found, action->hide, ch, targ, 0, TO_ROOM);
     return;
   }
-  if (!(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_ROOM)))
+    }
+    if (action->not_found)
     send_to_char(ch, "%s\r\n", action->not_found);
-  else if (vict == ch) {
+    else
+      send_to_char(ch, "I don't see anything by that name here.\r\n");
+    return;
+  } 
+  
+  if (vict == ch) {
+    if (action->char_auto)
     send_to_char(ch, "%s\r\n", action->char_auto);
+    else
+      send_to_char(ch, "Erm, no.");
     act(action->others_auto, action->hide, ch, 0, 0, TO_ROOM);
-  } else {
+    return;
+  } 
+  
     if (GET_POS(vict) < action->min_victim_position)
       act("$N is not in a proper position for that.", FALSE, ch, 0, vict, TO_CHAR | TO_SLEEP);
     else {
+    if (*part) {
+      act(action->char_body_found, 0, ch, (struct obj_data *)part, vict, TO_CHAR | TO_SLEEP);
+      act(action->others_body_found, action->hide, ch, (struct obj_data *)part, vict, TO_NOTVICT);
+      act(action->vict_body_found, action->hide, ch, (struct obj_data *)part, vict, TO_VICT);
+    } else {
       act(action->char_found, 0, ch, 0, vict, TO_CHAR | TO_SLEEP);
       act(action->others_found, action->hide, ch, 0, vict, TO_NOTVICT);
       act(action->vict_found, action->hide, ch, 0, vict, TO_VICT);
@@ -172,81 +162,75 @@ ACMD(do_insult)
 }
 
 
-char *fread_action(FILE *fl, int nr)
+
+void boot_social_messages(void)
 {
-  char buf[MAX_STRING_LENGTH];
+  FILE *fl;
+  int nr = 0, hide, min_char_pos, min_pos, min_lvl, curr_soc = -1;
+  char next_soc[MAX_STRING_LENGTH], sorted[MAX_INPUT_LENGTH];
 
-  fgets(buf, MAX_STRING_LENGTH, fl);
-  if (feof(fl)) {
-    log("SYSERR: fread_action: unexpected EOF near action #%d", nr);
+  if (CONFIG_NEW_SOCIALS == TRUE) {
+    /* open social file */
+    if (!(fl = fopen(SOCMESS_FILE_NEW, "r"))) {
+      log("SYSERR: can't open socials file '%s': %s", SOCMESS_FILE_NEW, strerror(errno));
     exit(1);
   }
-  if (*buf == '#')
-    return (NULL);
-
-  buf[strlen(buf) - 1] = '\0';
-  return (strdup(buf));
-}
-
-
-void free_social_messages(void)
-{
-  int ac;
-  struct social_messg *soc;
-
-  for (ac = 0; ac <= list_top; ac++) {
-    soc = &soc_mess_list[ac];
-
-    if (soc->char_no_arg)	free(soc->char_no_arg);
-    if (soc->others_no_arg)	free(soc->others_no_arg);
-    if (soc->char_found)	free(soc->char_found);
-    if (soc->others_found)	free(soc->others_found);
-    if (soc->vict_found)	free(soc->vict_found);
-    if (soc->not_found)		free(soc->not_found);
-    if (soc->char_auto)		free(soc->char_auto);
-    if (soc->others_auto)	free(soc->others_auto);
+    /* count socials */
+    *next_soc = '\0';
+    while (!feof(fl)) {
+      fgets(next_soc, MAX_STRING_LENGTH, fl);
+      if (*next_soc == '~') top_of_socialt++;
   }
-  free(soc_mess_list);
-}
-
-
-void boot_social_messages(void)
-{
-  FILE *fl;
-  int nr, i, hide, min_pos, curr_soc = -1;
-  char next_soc[100];
-  struct social_messg temp;
+  } else { /* old style */
 
   /* open social file */
   if (!(fl = fopen(SOCMESS_FILE, "r"))) {
     log("SYSERR: can't open socials file '%s': %s", SOCMESS_FILE, strerror(errno));
     exit(1);
   }
-  /* count socials & allocate space */
-  for (nr = 0; *cmd_info[nr].command != '\n'; nr++)
-    if (cmd_info[nr].command_pointer == do_action)
-      list_top++;
+    /* count socials */
+    while (!feof(fl)) {
+      fgets(next_soc, MAX_STRING_LENGTH, fl);
+      if (*next_soc == '\n' || *next_soc == '\r') top_of_socialt++; /* all socials are followed by a blank line */
+    }
+  }
 
-  CREATE(soc_mess_list, struct social_messg, list_top + 1);
+  log("Social table contains %d socials.", top_of_socialt);
+  rewind(fl);
+  
+  CREATE(soc_mess_list, struct social_messg, top_of_socialt + 1);
 
   /* now read 'em */
   for (;;) {
     fscanf(fl, " %s ", next_soc);
-    if (*next_soc == '$')
-      break;
-    if (fscanf(fl, " %d %d \n", &hide, &min_pos) != 2) {
+    if (*next_soc == '$') break;
+
+    if (CONFIG_NEW_SOCIALS == TRUE) {
+      if (fscanf(fl, " %s %d %d %d %d \n",
+  		sorted, &hide, &min_char_pos, &min_pos, &min_lvl) != 5) {
       log("SYSERR: format error in social file near social '%s'", next_soc);
       exit(1);
     }
-    if (++curr_soc > list_top) {
-      log("SYSERR: Ran out of slots in social array. (%d > %d)", curr_soc, list_top);
-      break;
+      curr_soc++;
+      soc_mess_list[curr_soc].command = strdup(next_soc+1);
+      soc_mess_list[curr_soc].sort_as = strdup(sorted);
+      soc_mess_list[curr_soc].hide = hide;
+      soc_mess_list[curr_soc].min_char_position = min_char_pos;
+      soc_mess_list[curr_soc].min_victim_position = min_pos;
+      soc_mess_list[curr_soc].min_level_char = min_lvl;
+    } else {  /* old style */
+      if (fscanf(fl, " %d %d \n", &hide, &min_pos) != 2) {
+        log("SYSERR: format error in social file near social '%s'", next_soc);
+        exit(1);
     }
- 
-    /* read the stuff */
-    soc_mess_list[curr_soc].act_nr = nr = find_command(next_soc);
+      curr_soc++;
+      soc_mess_list[curr_soc].command = strdup(next_soc);
+      soc_mess_list[curr_soc].sort_as = strdup(next_soc);
     soc_mess_list[curr_soc].hide = hide;
+      soc_mess_list[curr_soc].min_char_position = POS_RESTING;
     soc_mess_list[curr_soc].min_victim_position = min_pos;
+      soc_mess_list[curr_soc].min_level_char = 0;
+    }
 
 #ifdef CIRCLE_ACORN
     if (fgetc(fl) != '\n')
@@ -258,7 +242,7 @@ void boot_social_messages(void)
     soc_mess_list[curr_soc].char_found = fread_action(fl, nr);
 
     /* if no char_found, the rest is to be ignored */
-    if (!soc_mess_list[curr_soc].char_found)
+    if (CONFIG_NEW_SOCIALS == FALSE && !soc_mess_list[curr_soc].char_found)
       continue;
 
     soc_mess_list[curr_soc].others_found = fread_action(fl, nr);
@@ -267,34 +251,149 @@ void boot_social_messages(void)
     soc_mess_list[curr_soc].char_auto = fread_action(fl, nr);
     soc_mess_list[curr_soc].others_auto = fread_action(fl, nr);
 
-    /* If social not found, re-use this slot.  'curr_soc' will be reincremented. */
-    if (nr < 0) {
-      log("SYSERR: Unknown social '%s' in social file.", next_soc);
-      memset(&soc_mess_list[curr_soc--], 0, sizeof(struct social_messg));
+    if (CONFIG_NEW_SOCIALS == FALSE) 
       continue;
-    }
 
-    /* If the command we found isn't do_action, we didn't count it for the CREATE(). */
-    if (cmd_info[nr].command_pointer != do_action) {
-      log("SYSERR: Social '%s' already assigned to a command.", next_soc);
-      memset(&soc_mess_list[curr_soc--], 0, sizeof(struct social_messg));
-    }
+    soc_mess_list[curr_soc].char_body_found = fread_action(fl, nr);
+    soc_mess_list[curr_soc].others_body_found = fread_action(fl, nr);
+    soc_mess_list[curr_soc].vict_body_found = fread_action(fl, nr);
+    soc_mess_list[curr_soc].char_obj_found = fread_action(fl, nr);
+    soc_mess_list[curr_soc].others_obj_found = fread_action(fl, nr);
   }
 
   /* close file & set top */
   fclose(fl);
-  list_top = curr_soc;
+  assert(curr_soc <= top_of_socialt);
+  top_of_socialt = curr_soc;
+}
 
-  /* now, sort 'em */
-  for (curr_soc = 0; curr_soc < list_top; curr_soc++) {
-    min_pos = curr_soc;
-    for (i = curr_soc + 1; i <= list_top; i++)
-      if (soc_mess_list[i].act_nr < soc_mess_list[min_pos].act_nr)
-	min_pos = i;
-    if (curr_soc != min_pos) {
-      temp = soc_mess_list[curr_soc];
-      soc_mess_list[curr_soc] = soc_mess_list[min_pos];
-      soc_mess_list[min_pos] = temp;
+/* this function adds in the loaded socials and assigns them a command # */
+void create_command_list(void)
+{
+  int i, j, k;
+  struct social_messg temp;
+  extern struct command_info cmd_info[];
+
+  /* free up old command list */
+  if (complete_cmd_info) free(complete_cmd_info);
+    complete_cmd_info = NULL;
+
+  /* re check the sort on the socials */
+  for (j = 0; j < top_of_socialt; j++) {
+    k = j;
+    for (i = j + 1; i <= top_of_socialt; i++)
+      if (str_cmp(soc_mess_list[i].sort_as, soc_mess_list[k].sort_as) < 0)
+        k = i;
+    if (j != k) {
+      temp = soc_mess_list[j];
+      soc_mess_list[j] = soc_mess_list[k];
+      soc_mess_list[k] = temp;
+    }
+  }
+
+  /* count the commands in the command list */
+  i = 0;
+  while(*cmd_info[i].command != '\n') i++;
+  i++;
+
+  CREATE(complete_cmd_info, struct command_info, top_of_socialt + i + 2);
+
+  /* this loop sorts the socials and commands together into one big list */
+  i = 0;
+  j = 0;
+  k = 0;
+  while ((*cmd_info[i].command != '\n') || (j <= top_of_socialt))  {
+    if ((i < RESERVE_CMDS) || (j > top_of_socialt) || 
+	(str_cmp(cmd_info[i].sort_as, soc_mess_list[j].sort_as) < 1))
+      complete_cmd_info[k++] = cmd_info[i++];
+    else {
+      soc_mess_list[j].act_nr		= k;
+      complete_cmd_info[k].command		= soc_mess_list[j].command;
+      complete_cmd_info[k].sort_as		= soc_mess_list[j].sort_as;
+      complete_cmd_info[k].minimum_position	= soc_mess_list[j].min_char_position;
+      complete_cmd_info[k].command_pointer	= do_action;
+      complete_cmd_info[k].minimum_level    	= soc_mess_list[j++].min_level_char;
+      complete_cmd_info[k++].subcmd		= 0;
+    }
     }
+  complete_cmd_info[k].command		= strdup("\n");
+  complete_cmd_info[k].sort_as		= strdup("zzzzzzz");
+  complete_cmd_info[k].minimum_position = 0;
+  complete_cmd_info[k].command_pointer	= 0;
+  complete_cmd_info[k].minimum_level	= 0;
+  complete_cmd_info[k].subcmd		= 0;
+  log("Command info rebuilt, %d total commands.", k);
+}
+
+char *fread_action(FILE *fl, int nr)
+{
+  char buf[MAX_STRING_LENGTH];
+
+  fgets(buf, MAX_STRING_LENGTH, fl);
+  if (feof(fl)) {
+    log("SYSERR: fread_action: unexpected EOF near action #%d", nr);
+    exit(1);
+  }
+  if (*buf == '#')
+    return (NULL);
+
+  buf[strlen(buf) - 1] = '\0';
+  return (strdup(buf));
+}
+
+void free_social_messages(void) 
+{
+  struct social_messg *mess;
+  int i;
+  
+  for (i = 0;i <= top_of_socialt;i++)  {
+    mess = &soc_mess_list[i];
+    free_action(mess);
+  }
+  free(soc_mess_list);
+  
+}  
+
+void free_action(struct social_messg *mess)  {
+  if (mess->command) free(mess->command);
+  if (mess->sort_as) free(mess->sort_as);
+  if (mess->char_no_arg) free(mess->char_no_arg);
+  if (mess->others_no_arg) free(mess->others_no_arg);
+  if (mess->char_found) free(mess->char_found);
+  if (mess->others_found) free(mess->others_found);
+  if (mess->vict_found) free(mess->vict_found);
+  if (mess->char_body_found) free(mess->char_body_found);
+  if (mess->others_body_found) free(mess->others_body_found);
+  if (mess->vict_body_found) free(mess->vict_body_found);
+  if (mess->not_found) free(mess->not_found);
+  if (mess->char_auto) free(mess->char_auto);
+  if (mess->others_auto) free(mess->others_auto);
+  if (mess->char_obj_found) free(mess->char_obj_found);
+  if (mess->others_obj_found) free(mess->others_obj_found);
+  memset(mess, 0, sizeof(struct social_messg));
+}
+
+int find_action(int cmd)
+{
+  int bot, top, mid;
+
+  bot = 0;
+  top = top_of_socialt;
+
+  if (top < 0)
+    return (-1);
+
+  for (;;) {
+    mid = (bot + top) / 2;
+
+    if (soc_mess_list[mid].act_nr == cmd)
+      return (mid);
+    if (bot >= top)
+      return (-1);
+
+    if (soc_mess_list[mid].act_nr > cmd)
+      top = --mid;
+    else
+      bot = ++mid;
   }
 }
diff -BENbdpru circle-3.1/src/act.wizard.c circle3.1_oasis206/src/act.wizard.c
--- circle-3.1/src/act.wizard.c	2002-09-26 02:41:38.000000000 +0200
+++ circle3.1_oasis206/src/act.wizard.c	2003-10-07 11:26:36.000000000 +0200
@@ -21,6 +21,7 @@
 #include "house.h"
 #include "screen.h"
 #include "constants.h"
+#include "oasis.h"
 
 /*   external vars  */
 extern FILE *player_fl;
@@ -29,7 +30,6 @@ extern char *class_abbrevs[];
 extern time_t boot_time;
 extern int circle_shutdown, circle_reboot;
 extern int circle_restrict;
-extern int load_into_inventory;
 extern int buf_switches, buf_largecount, buf_overflows;
 extern int top_of_p_table;
 
@@ -46,6 +46,11 @@ void reset_zone(zone_rnum zone);
 void roll_real_abils(struct char_data *ch);
 int parse_class(char arg);
 void run_autowiz(void);
+int save_all(void);
+void print_zone(struct char_data *ch, zone_vnum vnum);
+extern zone_rnum real_zone_by_thing(room_vnum vznum); /* added for zone_checker */
+SPECIAL(shop_keeper);
+void Crash_rentsave(struct char_data * ch, int cost);
 
 /* local functions */
 int perform_set(struct char_data *ch, struct char_data *vict, int mode, char *val_arg);
@@ -85,11 +90,11 @@ ACMD(do_force);
 ACMD(do_wiznet);
 ACMD(do_zreset);
 ACMD(do_wizutil);
-size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone);
+size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone, int listall);
 ACMD(do_show);
 ACMD(do_set);
 void snoop_check(struct char_data *ch);
-
+ACMD(do_saveall);
 
 ACMD(do_echo)
 {
@@ -107,8 +112,8 @@ ACMD(do_echo)
 
     act(buf, FALSE, ch, 0, 0, TO_ROOM);
 
-    if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+    if (!IS_NPC(ch) && PRF_FLAGGED(ch, PRF_NOREPEAT))
+      send_to_char(ch, "%s", CONFIG_OK);
     else
       act(buf, FALSE, ch, 0, 0, TO_CHAR);
   }
@@ -127,7 +132,7 @@ ACMD(do_send)
     return;
   }
   if (!(vict = get_char_vis(ch, arg, NULL, FIND_CHAR_WORLD))) {
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
     return;
   }
   send_to_char(vict, "%s\r\n", buf);
@@ -273,7 +278,7 @@ ACMD(do_trans)
     send_to_char(ch, "Whom do you wish to transfer?\r\n");
   else if (str_cmp("all", buf)) {
     if (!(victim = get_char_vis(ch, buf, NULL, FIND_CHAR_WORLD)))
-      send_to_char(ch, "%s", NOPERSON);
+      send_to_char(ch, "%s", CONFIG_NOPERSON);
     else if (victim == ch)
       send_to_char(ch, "That doesn't make much sense, does it?\r\n");
     else {
@@ -306,7 +311,7 @@ ACMD(do_trans)
 	act("$n has transferred you!", FALSE, ch, 0, victim, TO_VICT);
 	look_at_room(victim, 0);
       }
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
   }
 }
 
@@ -323,7 +328,7 @@ ACMD(do_teleport)
   if (!*buf)
     send_to_char(ch, "Whom do you wish to teleport?\r\n");
   else if (!(victim = get_char_vis(ch, buf, NULL, FIND_CHAR_WORLD)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (victim == ch)
     send_to_char(ch, "Use 'goto' to teleport yourself.\r\n");
   else if (GET_LEVEL(victim) >= GET_LEVEL(ch))
@@ -331,7 +336,7 @@ ACMD(do_teleport)
   else if (!*buf2)
     send_to_char(ch, "Where do you wish to send this person?\r\n");
   else if ((target = find_target_room(ch, buf2)) != NOWHERE) {
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     act("$n disappears in a puff of smoke.", FALSE, victim, 0, 0, TO_ROOM);
     char_from_room(victim);
     char_to_room(victim, target);
@@ -363,6 +368,110 @@ ACMD(do_vnum)
 }
 
 
+#define ZOCMD zone_table[zrnum].cmd[subcmd]
+ 
+void list_zone_commands_room(struct char_data *ch, room_vnum rvnum)
+{
+  zone_rnum zrnum = real_zone_by_thing(rvnum);
+  room_rnum rrnum = real_room(rvnum), cmd_room = NOWHERE;
+  int subcmd = 0, count = 0;
+
+  if (zrnum == NOWHERE || rrnum == NOWHERE) {
+    send_to_char(ch, "No zone information available.\r\n");
+    return;
+  }
+
+  get_char_colors(ch);
+
+  send_to_char(ch, "Zone commands in this room:%s\r\n", yel);
+  while (ZOCMD.command != 'S') {
+    switch (ZOCMD.command) {
+      case 'M':
+      case 'O':
+      case 'T':
+      case 'V':
+        cmd_room = ZOCMD.arg3;
+        break;
+      case 'D':
+      case 'R':
+        cmd_room = ZOCMD.arg1;
+        break;
+      default:
+        break;
+    }
+    if (cmd_room == rrnum) {
+      count++;
+      /* start listing */
+      switch (ZOCMD.command) {
+        case 'M':
+          send_to_char(ch, "%sLoad %s [%s%d%s], Max : %d\r\n",
+                  ZOCMD.if_flag ? " then " : "",
+                  mob_proto[ZOCMD.arg1].player.short_descr, cyn,
+                  mob_index[ZOCMD.arg1].vnum, yel, ZOCMD.arg2
+                  );
+          break;
+        case 'G':
+          send_to_char(ch, "%sGive it %s [%s%d%s], Max : %d\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      obj_proto[ZOCMD.arg1].short_description,
+    	      cyn, obj_index[ZOCMD.arg1].vnum, yel,
+    	      ZOCMD.arg2
+    	      );
+          break;
+        case 'O':
+          send_to_char(ch, "%sLoad %s [%s%d%s], Max : %d\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      obj_proto[ZOCMD.arg1].short_description,
+    	      cyn, obj_index[ZOCMD.arg1].vnum, yel,
+    	      ZOCMD.arg2
+    	      );
+          break;
+        case 'E':
+          send_to_char(ch, "%sEquip with %s [%s%d%s], %s, Max : %d\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      obj_proto[ZOCMD.arg1].short_description,
+    	      cyn, obj_index[ZOCMD.arg1].vnum, yel,
+    	      equipment_types[ZOCMD.arg3],
+    	      ZOCMD.arg2
+    	      );
+          break;
+        case 'P':
+          send_to_char(ch, "%sPut %s [%s%d%s] in %s [%s%d%s], Max : %d\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      obj_proto[ZOCMD.arg1].short_description,
+    	      cyn, obj_index[ZOCMD.arg1].vnum, yel,
+    	      obj_proto[ZOCMD.arg3].short_description,
+    	      cyn, obj_index[ZOCMD.arg3].vnum, yel,
+    	      ZOCMD.arg2
+    	      );
+          break;
+        case 'R':
+          send_to_char(ch, "%sRemove %s [%s%d%s] from room.\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      obj_proto[ZOCMD.arg2].short_description,
+    	      cyn, obj_index[ZOCMD.arg2].vnum, yel
+    	      );
+          break;
+        case 'D':
+          send_to_char(ch, "%sSet door %s as %s.\r\n",
+    	      ZOCMD.if_flag ? " then " : "",
+    	      dirs[ZOCMD.arg2],
+    	      ZOCMD.arg3 ? ((ZOCMD.arg3 == 1) ? "closed" : "locked") : "open"
+    	      );
+          break;
+        default:
+          send_to_char(ch, "<Unknown Command>\r\n");
+          break;
+      }
+    } 
+    subcmd++;  
+  }
+  send_to_char(ch, nrm);
+  if (!count) 
+    send_to_char(ch, "None!\r\n");
+
+}
+#undef ZOCMD
 
 void do_stat_room(struct char_data *ch)
 {
@@ -388,7 +497,7 @@ void do_stat_room(struct char_data *ch)
   if (rm->ex_description) {
     send_to_char(ch, "Extra descs:%s", CCCYN(ch, C_NRM));
     for (desc = rm->ex_description; desc; desc = desc->next)
-      send_to_char(ch, " %s", desc->keyword);
+      send_to_char(ch, " [%s]", desc->keyword);
     send_to_char(ch, "%s\r\n", CCNRM(ch, C_NRM));
   }
 
@@ -440,10 +549,13 @@ void do_stat_room(struct char_data *ch)
     sprintbit(rm->dir_option[i]->exit_info, exit_bits, buf2, sizeof(buf2));
 
     send_to_char(ch, "Exit %s%-5s%s:  To: [%s], Key: [%5d], Keywrd: %s, Type: %s\r\n%s",
-	CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, rm->dir_option[i]->key,
+	CCCYN(ch, C_NRM), dirs[i], CCNRM(ch, C_NRM), buf1, 
+	rm->dir_option[i]->key == NOTHING ? -1 : rm->dir_option[i]->key,
 	rm->dir_option[i]->keyword ? rm->dir_option[i]->keyword : "None", buf2,
 	rm->dir_option[i]->general_description ? rm->dir_option[i]->general_description : "  No exit description.\r\n");
   }
+
+  list_zone_commands_room(ch, rm->number);
 }
 
 
@@ -469,7 +581,7 @@ void do_stat_object(struct char_data *ch
   if (j->ex_description) {
     send_to_char(ch, "Extra descs:%s", CCCYN(ch, C_NRM));
     for (desc = j->ex_description; desc; desc = desc->next)
-      send_to_char(ch, " %s", desc->keyword);
+      send_to_char(ch, " [%s]", desc->keyword);
     send_to_char(ch, "%s\r\n", CCNRM(ch, C_NRM));
   }
 
@@ -482,8 +594,8 @@ void do_stat_object(struct char_data *ch
   sprintbit(GET_OBJ_EXTRA(j), extra_bits, buf, sizeof(buf));
   send_to_char(ch, "Extra flags   : %s\r\n", buf);
 
-  send_to_char(ch, "Weight: %d, Value: %d, Cost/day: %d, Timer: %d\r\n",
-     GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j), GET_OBJ_TIMER(j));
+  send_to_char(ch, "Weight: %d, Value: %d, Cost/day: %d, Timer: %d, Min level: %d\r\n",
+     GET_OBJ_WEIGHT(j), GET_OBJ_COST(j), GET_OBJ_RENT(j), GET_OBJ_TIMER(j), GET_OBJ_LEVEL(j));
 
   send_to_char(ch, "In room: %d (%s), ", GET_ROOM_VNUM(IN_ROOM(j)),
 	IN_ROOM(j) == NOWHERE ? "Nowhere" : world[IN_ROOM(j)].name);
@@ -628,10 +740,20 @@ void do_stat_character(struct char_data 
 	    buf1, buf2, k->player.time.played / 3600,
 	    ((k->player.time.played % 3600) / 60), age(k)->year);
 
-    send_to_char(ch, "Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])\r\n",
+    send_to_char(ch, "Hometown: [%d], Speaks: [%d/%d/%d], (STL[%d]/per[%d]/NSTL[%d])",
 	 k->player.hometown, GET_TALK(k, 0), GET_TALK(k, 1), GET_TALK(k, 2),
 	    GET_PRACTICES(k), int_app[GET_INT(k)].learn,
 	    wis_app[GET_WIS(k)].bonus);
+    /*. Display OLC zone for immorts .*/
+    if (GET_LEVEL(k) >= LVL_BUILDER) {
+      if (GET_OLC_ZONE(k)==AEDIT_PERMISSION)
+        send_to_char(ch, ", OLC[%sActions%s]", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
+      else if (GET_OLC_ZONE(k)==NOWHERE)
+        send_to_char(ch, ", OLC[%sOFF%s]", CCCYN(ch, C_NRM), CCNRM(ch, C_NRM));
+      else
+        send_to_char(ch, ", OLC[%s%d%s]", CCCYN(ch, C_NRM), GET_OLC_ZONE(k), CCNRM(ch, C_NRM));
+    }
+    send_to_char(ch, "\r\n");
   }
   send_to_char(ch, "Str: [%s%d/%d%s]  Int: [%s%d%s]  Wis: [%s%d%s]  "
 	  "Dex: [%s%d%s]  Con: [%s%d%s]  Cha: [%s%d%s]\r\n",
@@ -748,7 +870,7 @@ ACMD(do_stat)
   half_chop(argument, buf1, buf2);
 
   if (!*buf1) {
-    send_to_char(ch, "Stats on who or what?\r\n");
+    send_to_char(ch, "Stats on who or what or where?\r\n");
     return;
   } else if (is_abbrev(buf1, "room")) {
     do_stat_room(ch);
@@ -801,6 +923,14 @@ ACMD(do_stat)
       else
 	send_to_char(ch, "No such object around.\r\n");
     }
+  } else if (is_abbrev(buf1, "zone")) {
+    if (!*buf2) {
+      send_to_char(ch, "Stats on which zone?\r\n");
+      return;
+    } else {
+      print_zone(ch, atoi(buf2));
+      return;
+    }
   } else {
     char *name = buf1;
     int number = get_number(&name);
@@ -847,6 +977,11 @@ ACMD(do_shutdown)
     send_to_all("Shutting down for maintenance.\r\n");
     touch(KILLSCRIPT_FILE);
     circle_shutdown = 1;
+  } else if (!str_cmp(arg, "now")) {
+    log("(GC) Shutdown NOW by %s.", GET_NAME(ch));
+    send_to_all("Rebooting.. come back in a minute or two.\r\n");
+    circle_shutdown = 1;
+    circle_reboot = 2; /* do not autosave olc */
   } else if (!str_cmp(arg, "pause")) {
     log("(GC) Shutdown by %s.", GET_NAME(ch));
     send_to_all("Shutting down for maintenance.\r\n");
@@ -923,7 +1058,7 @@ ACMD(do_snoop)
       send_to_char(ch, "You can't.\r\n");
       return;
     }
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
 
     if (ch->desc->snooping)
       ch->desc->snooping->snoop_by = NULL;
@@ -960,7 +1095,7 @@ ACMD(do_switch)
 		&& !House_can_enter(ch, GET_ROOM_VNUM(IN_ROOM(victim))))
     send_to_char(ch, "That's private property -- no trespassing!\r\n");
   else {
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
 
     ch->desc->character = victim;
     ch->desc->original = ch;
@@ -1041,7 +1176,7 @@ ACMD(do_load)
       return;
     }
     obj = read_object(r_num, REAL);
-    if (load_into_inventory)
+    if (CONFIG_LOAD_INVENTORY)
       obj_to_char(obj, ch);
     else
       obj_to_room(obj, IN_ROOM(ch));
@@ -1134,7 +1269,7 @@ ACMD(do_purge)
       return;
     }
 
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
   } else {			/* no argument. clean out the room */
     int i;
 
@@ -1256,7 +1391,7 @@ ACMD(do_advance)
 	"You feel slightly different.", FALSE, ch, 0, victim, TO_VICT);
   }
 
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
 
   if (newlevel < oldlevel)
     log("(GC) %s demoted %s from level %d to %d.",
@@ -1270,7 +1405,12 @@ ACMD(do_advance)
      * nice immortal only flags, shall we?
      */
     REMOVE_BIT(PRF_FLAGS(victim), PRF_LOG1 | PRF_LOG2);
-    REMOVE_BIT(PRF_FLAGS(victim), PRF_NOHASSLE | PRF_HOLYLIGHT);
+    REMOVE_BIT(PRF_FLAGS(victim), PRF_NOHASSLE | PRF_HOLYLIGHT | PRF_ROOMFLAGS);
+    run_autowiz();
+  } else if (oldlevel < LVL_IMMORT && newlevel >= LVL_IMMORT) {
+    SET_BIT(PRF_FLAGS(victim), PRF_LOG2);
+    SET_BIT(PRF_FLAGS(victim), PRF_HOLYLIGHT | PRF_ROOMFLAGS | PRF_AUTOEXIT);
+    SET_BIT(PRF_FLAGS(victim), PRF_COLOR_1 | PRF_COLOR_2);
     run_autowiz();
   }
 
@@ -1289,7 +1429,7 @@ ACMD(do_restore)
   if (!*buf)
     send_to_char(ch, "Whom do you wish to restore?\r\n");
   else if (!(vict = get_char_vis(ch, buf, NULL, FIND_CHAR_WORLD)))
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
   else if (!IS_NPC(vict) && ch != vict && GET_LEVEL(vict) >= GET_LEVEL(ch))
     send_to_char(ch, "They don't need your help.\r\n");
   else {
@@ -1314,7 +1454,7 @@ ACMD(do_restore)
     }
     update_pos(vict);
     affect_total(vict);
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     act("You have been fully healed by $N!", FALSE, vict, 0, ch, TO_CHAR);
   }
 }
@@ -1392,11 +1532,11 @@ ACMD(do_gecho)
     send_to_char(ch, "That must be a mistake...\r\n");
   else {
     for (pt = descriptor_list; pt; pt = pt->next)
-      if (STATE(pt) == CON_PLAYING && pt->character && pt->character != ch)
+      if (IS_PLAYING(pt) && pt->character && pt->character != ch)
 	send_to_char(pt->character, "%s\r\n", argument);
 
     if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
     else
       send_to_char(ch, "%s\r\n", argument);
   }
@@ -1423,7 +1563,7 @@ ACMD(do_poofset)
   else
     *msg = strdup(argument);
 
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
 }
 
 
@@ -1587,17 +1727,17 @@ ACMD(do_force)
     send_to_char(ch, "Whom do you wish to force do what?\r\n");
   else if ((GET_LEVEL(ch) < LVL_GRGOD) || (str_cmp("all", arg) && str_cmp("room", arg))) {
     if (!(vict = get_char_vis(ch, arg, NULL, FIND_CHAR_WORLD)))
-      send_to_char(ch, "%s", NOPERSON);
+      send_to_char(ch, "%s", CONFIG_NOPERSON);
     else if (!IS_NPC(vict) && GET_LEVEL(ch) <= GET_LEVEL(vict))
       send_to_char(ch, "No, no, no!\r\n");
     else {
-      send_to_char(ch, "%s", OK);
+      send_to_char(ch, "%s", CONFIG_OK);
       act(buf1, TRUE, ch, NULL, vict, TO_VICT);
       mudlog(NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE, "(GC) %s forced %s to %s", GET_NAME(ch), GET_NAME(vict), to_force);
       command_interpreter(vict, to_force);
     }
   } else if (!str_cmp("room", arg)) {
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     mudlog(NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE, "(GC) %s forced room %d to %s",
 		GET_NAME(ch), GET_ROOM_VNUM(IN_ROOM(ch)), to_force);
 
@@ -1609,7 +1749,7 @@ ACMD(do_force)
       command_interpreter(vict, to_force);
     }
   } else { /* force all */
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
     mudlog(NRM, MAX(LVL_GOD, GET_INVIS_LEV(ch)), TRUE, "(GC) %s forced all to %s", GET_NAME(ch), to_force);
 
     for (i = descriptor_list; i; i = next_desc) {
@@ -1711,7 +1851,7 @@ ACMD(do_wiznet)
   }
 
   if (PRF_FLAGGED(ch, PRF_NOREPEAT))
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
 }
 
 
@@ -1834,9 +1974,10 @@ ACMD(do_wizutil)
       act("A sudden fireball conjured from nowhere thaws $n!", FALSE, vict, 0, 0, TO_ROOM);
       break;
     case SCMD_UNAFFECT:
-      if (vict->affected) {
+      if (vict->affected || AFF_FLAGS(vict)) {
 	while (vict->affected)
 	  affect_remove(vict, vict->affected);
+	AFF_FLAGS(vict) = 0;
 	send_to_char(vict, "There is a brief flash of light!\r\nYou feel slightly different.\r\n");
 	send_to_char(ch, "All spells removed.\r\n");
       } else {
@@ -1857,22 +1998,60 @@ ACMD(do_wizutil)
    code 3 times ... -je, 4/6/93 */
 
 /* FIXME: overflow possible */
-size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone)
+size_t print_zone_to_buf(char *bufptr, size_t left, zone_rnum zone, int listall)
 {
-  return snprintf(bufptr, left,
-	"%3d %-30.30s Age: %3d; Reset: %3d (%1d); Range: %5d-%5d\r\n",
-	zone_table[zone].number, zone_table[zone].name,
+  size_t tmp;
+  
+  if (listall) {
+    int i, j, k, l, m;
+    int count_shops(shop_vnum low, shop_vnum high);
+
+    tmp = snprintf(bufptr, left,
+	"%3d %-30.30s By: %-10.10s Age: %3d; Reset: %3d (%1d); Range: %5d-%5d\r\n",
+	zone_table[zone].number, zone_table[zone].name, zone_table[zone].builders,
 	zone_table[zone].age, zone_table[zone].lifespan,
 	zone_table[zone].reset_mode,
 	zone_table[zone].bot, zone_table[zone].top);
+        i = j = k = l = m = 0;
+        
+        for (i = 0; i < top_of_world; i++)
+          if (world[i].number >= zone_table[zone].bot && world[i].number <= zone_table[zone].top)
+            j++;
+
+        for (i = 0; i < top_of_objt; i++)
+          if (obj_index[i].vnum >= zone_table[zone].bot && obj_index[i].vnum <= zone_table[zone].top)
+            k++;
+        
+        for (i = 0; i < top_of_mobt; i++)
+          if (mob_index[i].vnum >= zone_table[zone].bot && mob_index[i].vnum <= zone_table[zone].top)
+            l++;
+
+        m = count_shops(zone_table[zone].bot, zone_table[zone].top);
+
+	tmp += snprintf(bufptr + tmp, left - tmp,
+                        "       Zone stats:\r\n"
+                        "       ---------------\r\n"
+                        "         Rooms:    %2d\r\n"
+                        "         Objects:  %2d\r\n"
+                        "         Mobiles:  %2d\r\n"
+                        "         Shops:    %2d\r\n",
+                          j, k, l, m);
+        
+    return tmp;
+  } 
+  
+  return snprintf(bufptr, left,
+	"%3d %-30.30s By: %-10.10s Range: %5d-%5d\r\n",
+	zone_table[zone].number, zone_table[zone].name, zone_table[zone].builders,
+	zone_table[zone].bot, zone_table[zone].top);
 }
 
 
 ACMD(do_show)
 {
   struct char_file_u vbuf;
-  int i, j, k, l, con, nlen;		/* i, j, k to specifics? */
-  size_t len;
+  int i, j, k, l, con;		/* i, j, k to specifics? */
+  size_t len, nlen;
   zone_rnum zrn;
   zone_vnum zvn;
   byte self = FALSE;
@@ -1930,18 +2109,18 @@ ACMD(do_show)
   case 1:
     /* tightened up by JE 4/6/93 */
     if (self)
-      print_zone_to_buf(buf, sizeof(buf), world[IN_ROOM(ch)].zone);
+      print_zone_to_buf(buf, sizeof(buf), world[IN_ROOM(ch)].zone, 1);
     else if (*value && is_number(value)) {
       for (zvn = atoi(value), zrn = 0; zone_table[zrn].number != zvn && zrn <= top_of_zone_table; zrn++);
       if (zrn <= top_of_zone_table)
-	print_zone_to_buf(buf, sizeof(buf), zrn);
+	print_zone_to_buf(buf, sizeof(buf), zrn, 1);
       else {
 	send_to_char(ch, "That is not a valid zone.\r\n");
 	return;
       }
     } else
       for (len = zrn = 0; zrn <= top_of_zone_table; zrn++) {
-	nlen = print_zone_to_buf(buf + len, sizeof(buf) - len, zrn);
+	nlen = print_zone_to_buf(buf + len, sizeof(buf) - len, zrn, 0);
         if (len + nlen >= sizeof(buf) || nlen < 0)
           break;
         len += nlen;
@@ -2167,6 +2346,7 @@ ACMD(do_show)
    { "age",		LVL_GRGOD,	BOTH,	NUMBER },
    { "height",		LVL_GOD,	BOTH,	NUMBER },
    { "weight",		LVL_GOD,	BOTH,	NUMBER },  /* 50 */
+   { "olc",		LVL_IMPL,	PC,	MISC },
    { "\n", 0, BOTH, MISC }
   };
 
@@ -2214,7 +2394,7 @@ int perform_set(struct char_data *ch, st
     value = atoi(val_arg);
     send_to_char(ch, "%s's %s set to %d.\r\n", GET_NAME(vict), set_fields[mode].cmd, value);
   } else
-    send_to_char(ch, "%s", OK);
+    send_to_char(ch, "%s", CONFIG_OK);
 
   switch (mode) {
   case 0:
@@ -2429,7 +2609,7 @@ int perform_set(struct char_data *ch, st
       if (real_room(rvnum) != NOWHERE) {
         SET_BIT(PLR_FLAGS(vict), PLR_LOADROOM);
 	GET_LOADROOM(vict) = rvnum;
-	send_to_char(ch, "%s will enter at room #%d.", GET_NAME(vict), GET_LOADROOM(vict));
+	send_to_char(ch, "%s will enter at room #%d.\r\n", GET_NAME(vict), GET_LOADROOM(vict));
       } else {
 	send_to_char(ch, "That room does not exist!\r\n");
 	return (0);
@@ -2493,6 +2673,18 @@ int perform_set(struct char_data *ch, st
     affect_total(vict);
     break;
 
+  case 51:
+    if (is_abbrev(val_arg, "socials") || is_abbrev(val_arg, "actions")) 
+      GET_OLC_ZONE(vict) = AEDIT_PERMISSION;
+    else if (is_abbrev(val_arg, "off")) 
+      GET_OLC_ZONE(vict) = NOWHERE;
+    else if (!is_number(val_arg)) {
+      send_to_char(ch, "Value must be either 'socials', 'actions', 'off' or a zone number.\r\n");
+      return (0);
+    } else
+      GET_OLC_ZONE(vict) = atoi(val_arg);
+    break;
+
   default:
     send_to_char(ch, "Can't set that!\r\n");
     return (0);
@@ -2586,3 +2778,12 @@ ACMD(do_set)
     free_char(cbuf);
 }
 
+ACMD(do_saveall)
+{
+ if (GET_LEVEL(ch) < LVL_BUILDER)
+    send_to_char (ch, "You are not holy enough to use this privelege.\n\r");
+ else {
+    save_all();
+    send_to_char(ch, "World files saved.\n\r");
+ }
+}
diff -BENbdpru circle-3.1/src/aedit.c circle3.1_oasis206/src/aedit.c
--- circle-3.1/src/aedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/aedit.c	2003-10-07 11:36:54.000000000 +0200
@@ -0,0 +1,832 @@
+/*
+ * File: aedit.c
+ * Comment: OLC for MUDs -- this one edits socials
+ * by Michael Scott <scottm@workcomm.net> -- 06/10/96
+ * for use with OasisOLC
+ * ftpable from ftp.circlemud.org:/pub/CircleMUD/contrib/code
+ */
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "interpreter.h"
+#include "handler.h"
+#include "comm.h"
+#include "utils.h"
+#include "db.h"
+#include "oasis.h"
+#include "screen.h"
+#include "constants.h"
+#include "genolc.h"
+
+/* external functs */
+int sort_command_helper(const void *a, const void *b);
+void sort_commands(void); /* aedit patch -- M. Scott */
+void create_command_list(void);
+void free_action(struct social_messg *action);
+
+/* function protos */
+void aedit_disp_menu(struct descriptor_data * d);
+void aedit_parse(struct descriptor_data * d, char *arg);
+void aedit_setup_new(struct descriptor_data *d);
+void aedit_setup_existing(struct descriptor_data *d, int real_num);
+void aedit_save_to_disk(struct descriptor_data *d);
+void aedit_save_internally(struct descriptor_data *d);
+
+/*
+ * Utils and exported functions.
+ */
+
+/*------------------------------------------------------------------------*\
+  Utils and exported functions.
+\*------------------------------------------------------------------------*/
+
+ACMD(do_oasis_aedit)
+{
+  char arg[MAX_INPUT_LENGTH];
+  struct descriptor_data *d;
+  
+  if (CONFIG_NEW_SOCIALS == 0) {
+    send_to_char(ch, "Socials cannot be edited at the moment.\r\n");
+    return;
+  }
+
+  if (GET_OLC_ZONE(ch) != AEDIT_PERMISSION && GET_LEVEL(ch) < LVL_IMPL) {
+    send_to_char(ch, "You don't have access to editing socials.\r\n");
+    return;
+  }
+
+  for (d = descriptor_list; d; d = d->next)
+    if (STATE(d) == CON_AEDIT) {
+      send_to_char(ch, "Sorry, only one can edit socials at a time.\r\n");
+      return;
+    }
+
+  one_argument(argument, arg);
+    
+  if (!*arg) {
+    send_to_char(ch, "Please specify a social to edit.\r\n");
+    return;
+  }
+
+  d = ch->desc;
+
+  if (!str_cmp("save", arg)) {
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE, "OLC: %s saves socials.", GET_NAME(ch));
+    send_to_char(ch, "Writing social file..\r\n");
+    aedit_save_to_disk(d);
+    send_to_char(ch, "Done.\r\n");
+    return;
+  }
+  
+  /*
+   * Give descriptor an OLC structure.
+   */
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_oasis: Player already had olc structure.");
+    free(d->olc);
+  }
+  CREATE(d->olc, struct oasis_olc_data, 1);
+
+  OLC_NUM(d) = 0;
+  OLC_STORAGE(d) = strdup(arg);
+  
+  for (OLC_ZNUM(d) = 0; (OLC_ZNUM(d) <= top_of_socialt); OLC_ZNUM(d)++)  
+    if (is_abbrev(OLC_STORAGE(d), soc_mess_list[OLC_ZNUM(d)].command))
+      break;
+
+  if (OLC_ZNUM(d) > top_of_socialt)  {
+    if (find_command(OLC_STORAGE(d)) != NOTHING)  {
+      send_to_char(ch, "The '%s' command already exists.\r\n", OLC_STORAGE(d));
+      cleanup_olc(d, CLEANUP_ALL);
+      return;
+    }
+    send_to_char(ch, "Do you wish to add the '%s' action? ", OLC_STORAGE(d));
+    OLC_MODE(d) = AEDIT_CONFIRM_ADD;
+  } else {
+    send_to_char(ch, "Do you wish to edit the '%s' action? ", soc_mess_list[OLC_ZNUM(d)].command);
+    OLC_MODE(d) = AEDIT_CONFIRM_EDIT;
+  }
+  STATE(d) = CON_AEDIT;
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  mudlog(CMP, LVL_IMMORT, TRUE, "OLC: %s starts editing actions.", GET_NAME(ch));
+}
+
+
+void aedit_setup_new(struct descriptor_data *d) {
+   CREATE(OLC_ACTION(d), struct social_messg, 1);
+   OLC_ACTION(d)->command             = strdup(OLC_STORAGE(d));
+   OLC_ACTION(d)->sort_as             = strdup(OLC_STORAGE(d));
+   OLC_ACTION(d)->hide                = 0;
+   OLC_ACTION(d)->min_victim_position = POS_STANDING;
+   OLC_ACTION(d)->min_char_position   = POS_STANDING;
+   OLC_ACTION(d)->min_level_char      = 0;
+   OLC_ACTION(d)->char_no_arg         = strdup("This action is unfinished.");
+   OLC_ACTION(d)->others_no_arg       = strdup("This action is unfinished.");
+   OLC_ACTION(d)->char_found          = NULL;
+   OLC_ACTION(d)->others_found        = NULL;
+   OLC_ACTION(d)->vict_found          = NULL;
+   OLC_ACTION(d)->not_found           = NULL;
+   OLC_ACTION(d)->char_auto           = NULL;
+   OLC_ACTION(d)->others_auto         = NULL;
+   OLC_ACTION(d)->char_body_found     = NULL;
+   OLC_ACTION(d)->others_body_found   = NULL;
+   OLC_ACTION(d)->vict_body_found     = NULL;
+   OLC_ACTION(d)->char_obj_found      = NULL;
+   OLC_ACTION(d)->others_obj_found    = NULL;
+   aedit_disp_menu(d);
+   OLC_VAL(d) = 0;
+}
+
+/*------------------------------------------------------------------------*/
+
+void aedit_setup_existing(struct descriptor_data *d, int real_num) {
+   CREATE(OLC_ACTION(d), struct social_messg, 1);
+   OLC_ACTION(d)->command             = strdup(soc_mess_list[real_num].command);
+   OLC_ACTION(d)->sort_as             = strdup(soc_mess_list[real_num].sort_as);
+   OLC_ACTION(d)->hide                = soc_mess_list[real_num].hide;
+   OLC_ACTION(d)->min_victim_position = soc_mess_list[real_num].min_victim_position;
+   OLC_ACTION(d)->min_char_position   = soc_mess_list[real_num].min_char_position;
+   OLC_ACTION(d)->min_level_char      = soc_mess_list[real_num].min_level_char;
+   if (soc_mess_list[real_num].char_no_arg)
+     OLC_ACTION(d)->char_no_arg       = strdup(soc_mess_list[real_num].char_no_arg);
+   if (soc_mess_list[real_num].others_no_arg)
+     OLC_ACTION(d)->others_no_arg     = strdup(soc_mess_list[real_num].others_no_arg);
+   if (soc_mess_list[real_num].char_found)
+     OLC_ACTION(d)->char_found        = strdup(soc_mess_list[real_num].char_found);
+   if (soc_mess_list[real_num].others_found)
+     OLC_ACTION(d)->others_found      = strdup(soc_mess_list[real_num].others_found);
+   if (soc_mess_list[real_num].vict_found)
+     OLC_ACTION(d)->vict_found        = strdup(soc_mess_list[real_num].vict_found);
+   if (soc_mess_list[real_num].not_found)
+     OLC_ACTION(d)->not_found         = strdup(soc_mess_list[real_num].not_found);
+   if (soc_mess_list[real_num].char_auto)
+     OLC_ACTION(d)->char_auto         = strdup(soc_mess_list[real_num].char_auto);
+   if (soc_mess_list[real_num].others_auto)
+     OLC_ACTION(d)->others_auto       = strdup(soc_mess_list[real_num].others_auto);
+   if (soc_mess_list[real_num].char_body_found)
+     OLC_ACTION(d)->char_body_found   = strdup(soc_mess_list[real_num].char_body_found);
+   if (soc_mess_list[real_num].others_body_found)
+     OLC_ACTION(d)->others_body_found = strdup(soc_mess_list[real_num].others_body_found);
+   if (soc_mess_list[real_num].vict_body_found)
+     OLC_ACTION(d)->vict_body_found   = strdup(soc_mess_list[real_num].vict_body_found);
+   if (soc_mess_list[real_num].char_obj_found)
+     OLC_ACTION(d)->char_obj_found    = strdup(soc_mess_list[real_num].char_obj_found);
+   if (soc_mess_list[real_num].others_obj_found)
+     OLC_ACTION(d)->others_obj_found  = strdup(soc_mess_list[real_num].others_obj_found);
+   OLC_VAL(d) = 0;
+   aedit_disp_menu(d);
+}
+
+
+      
+void aedit_save_internally(struct descriptor_data *d) {
+   struct social_messg *new_soc_mess_list = NULL;
+   int i;
+   
+   /* add a new social into the list */
+   if (OLC_ZNUM(d) > top_of_socialt)  {
+      CREATE(new_soc_mess_list, struct social_messg, top_of_socialt + 2);
+      for (i = 0; i <= top_of_socialt; i++)
+              new_soc_mess_list[i] = soc_mess_list[i];
+      new_soc_mess_list[++top_of_socialt] = *OLC_ACTION(d);
+      free(soc_mess_list);
+      soc_mess_list = new_soc_mess_list;
+      create_command_list();
+      sort_commands();
+   }
+   /* pass the editted action back to the list - no need to add */
+   else {
+      i = find_command(OLC_ACTION(d)->command);
+      OLC_ACTION(d)->act_nr = soc_mess_list[OLC_ZNUM(d)].act_nr;
+      /* why did i do this..? hrm */
+      free_action(soc_mess_list + OLC_ZNUM(d));
+      soc_mess_list[OLC_ZNUM(d)] = *OLC_ACTION(d);
+      if (i > NOTHING) {
+         complete_cmd_info[i].command = soc_mess_list[OLC_ZNUM(d)].command;
+         complete_cmd_info[i].sort_as  = soc_mess_list[OLC_ZNUM(d)].sort_as;
+         complete_cmd_info[i].minimum_position = soc_mess_list[OLC_ZNUM(d)].min_char_position;
+         complete_cmd_info[i].minimum_level  = soc_mess_list[OLC_ZNUM(d)].min_level_char;
+      }
+   }
+   add_to_save_list(AEDIT_PERMISSION, SL_ACTION);
+   aedit_save_to_disk(d); /* autosave by Rumble */
+}
+
+
+/*------------------------------------------------------------------------*/
+
+void aedit_save_to_disk(struct descriptor_data *d) {
+   FILE *fp;
+   int i;
+   if (!(fp = fopen(SOCMESS_FILE_NEW, "w+")))  {
+     char error[MAX_STRING_LENGTH];
+     snprintf(error, sizeof(error), "Can't open socials file '%s'", SOCMESS_FILE);
+     perror(error);
+     exit(1);
+   }
+
+   for (i = 0; i <= top_of_socialt; i++)  {
+      fprintf(fp, "~%s %s %d %d %d %d\n",
+              soc_mess_list[i].command,
+              soc_mess_list[i].sort_as,
+              soc_mess_list[i].hide,
+              soc_mess_list[i].min_char_position,
+              soc_mess_list[i].min_victim_position,
+              soc_mess_list[i].min_level_char);
+      fprintf(fp, "%s\n%s\n%s\n%s\n",
+              ((soc_mess_list[i].char_no_arg)?soc_mess_list[i].char_no_arg:"#"),
+              ((soc_mess_list[i].others_no_arg)?soc_mess_list[i].others_no_arg:"#"),
+              ((soc_mess_list[i].char_found)?soc_mess_list[i].char_found:"#"),
+              ((soc_mess_list[i].others_found)?soc_mess_list[i].others_found:"#"));
+      fprintf(fp, "%s\n%s\n%s\n%s\n",
+              ((soc_mess_list[i].vict_found)?soc_mess_list[i].vict_found:"#"),
+              ((soc_mess_list[i].not_found)?soc_mess_list[i].not_found:"#"),
+              ((soc_mess_list[i].char_auto)?soc_mess_list[i].char_auto:"#"),
+              ((soc_mess_list[i].others_auto)?soc_mess_list[i].others_auto:"#"));
+      fprintf(fp, "%s\n%s\n%s\n",
+              ((soc_mess_list[i].char_body_found)?soc_mess_list[i].char_body_found:"#"),
+              ((soc_mess_list[i].others_body_found)?soc_mess_list[i].others_body_found:"#"),
+              ((soc_mess_list[i].vict_body_found)?soc_mess_list[i].vict_body_found:"#"));
+      fprintf(fp, "%s\n%s\n\n",
+              ((soc_mess_list[i].char_obj_found)?soc_mess_list[i].char_obj_found:"#"),
+              ((soc_mess_list[i].others_obj_found)?soc_mess_list[i].others_obj_found:"#"));
+   }
+   
+   fprintf(fp, "$\n");
+   fclose(fp);
+   remove_from_save_list(AEDIT_PERMISSION, SL_ACTION); 
+}
+
+/*------------------------------------------------------------------------*/
+
+/* Menu functions */
+
+/* the main menu */
+void aedit_disp_menu(struct descriptor_data * d) {
+   struct social_messg *action = OLC_ACTION(d);
+   struct char_data *ch        = d->character;
+
+   get_char_colors(ch);
+   
+   write_to_output(d, 
+           "%s-- Action editor\r\n"
+           "%sn%s) Command         : %s%-15.15s%s %s1%s) Sort as Command  : %s%-15.15s%s\r\n"
+           "%s2%s) Min Position[CH]: %s%-8.8s        %s3%s) Min Position [VT]: %s%-8.8s\r\n"
+           "%s4%s) Min Level   [CH]: %s%-3d             %s5%s) Show if Invisible: %s%s\r\n"
+           "%sa%s) Char    [NO ARG]: %s%s\r\n"
+           "%sb%s) Others  [NO ARG]: %s%s\r\n"
+           "%sc%s) Char [NOT FOUND]: %s%s\r\n"
+           "%sd%s) Char  [ARG SELF]: %s%s\r\n"
+           "%se%s) Others[ARG SELF]: %s%s\r\n"
+           "%sf%s) Char      [VICT]: %s%s\r\n"
+           "%sg%s) Others    [VICT]: %s%s\r\n"
+           "%sh%s) Victim    [VICT]: %s%s\r\n"
+           "%si%s) Char  [BODY PRT]: %s%s\r\n"
+           "%sj%s) Others[BODY PRT]: %s%s\r\n"
+           "%sk%s) Victim[BODY PRT]: %s%s\r\n"
+           "%sl%s) Char       [OBJ]: %s%s\r\n"
+           "%sm%s) Others     [OBJ]: %s%s\r\n"
+           "%sq%s) Quit\r\n"
+           "Enter Choice:",
+           nrm, grn, nrm,
+           yel, action->command, nrm,
+           grn, nrm,
+           yel, action->sort_as, nrm,
+           grn, nrm,
+           cyn, position_types[action->min_char_position],
+           grn, nrm,
+           cyn, position_types[action->min_victim_position],
+           grn, nrm,
+           cyn, action->min_level_char,
+           grn, nrm,
+           cyn, (action->hide?"HIDDEN":"NOT HIDDEN"),
+           grn, nrm, cyn,
+           action->char_no_arg ? action->char_no_arg : "<Null>",
+           grn, nrm, cyn,
+           action->others_no_arg ? action->others_no_arg : "<Null>",
+           grn, nrm, cyn,
+           action->not_found ? action->not_found : "<Null>",
+           grn, nrm, cyn,
+           action->char_auto ? action->char_auto : "<Null>",
+           grn, nrm, cyn,
+           action->others_auto ? action->others_auto : "<Null>",
+           grn, nrm, cyn,
+           action->char_found ? action->char_found : "<Null>",
+           grn, nrm, cyn,
+           action->others_found ? action->others_found : "<Null>",
+           grn, nrm, cyn,
+           action->vict_found ? action->vict_found : "<Null>",
+           grn, nrm, cyn,
+           action->char_body_found ? action->char_body_found : "<Null>",
+           grn, nrm, cyn,
+           action->others_body_found ? action->others_body_found : "<Null>",
+           grn, nrm, cyn,
+           action->vict_body_found ? action->vict_body_found : "<Null>",
+           grn, nrm, cyn,
+           action->char_obj_found ? action->char_obj_found : "<Null>",
+           grn, nrm, cyn,
+           action->others_obj_found ? action->others_obj_found : "<Null>",
+           grn, nrm);
+
+   OLC_MODE(d) = AEDIT_MAIN_MENU;
+}
+
+
+/*
+ * The main loop
+ */
+
+void aedit_parse(struct descriptor_data * d, char *arg) {
+   int i;
+
+   switch (OLC_MODE(d)) {
+    case AEDIT_CONFIRM_SAVESTRING:
+      switch (*arg) {
+       case 'y': case 'Y':
+         aedit_save_internally(d);
+         mudlog (CMP, LVL_IMPL, TRUE, "OLC: %s edits action %s", 
+                 GET_NAME(d->character), OLC_ACTION(d)->command);
+
+         /* do not free the strings.. just the structure */
+         cleanup_olc(d, CLEANUP_STRUCTS);
+         write_to_output(d, "Action saved to disk.\r\n");
+         break;
+       case 'n': case 'N':
+         /* free everything up, including strings etc */
+         cleanup_olc(d, CLEANUP_ALL);
+         break;
+       default:
+         write_to_output(d, "Invalid choice!\r\n"
+                            "Do you wish to save this action internally? ");
+         break;
+      }
+      return; /* end of AEDIT_CONFIRM_SAVESTRING */
+
+    case AEDIT_CONFIRM_EDIT:
+      switch (*arg)  {
+       case 'y': case 'Y':
+         aedit_setup_existing(d, OLC_ZNUM(d));
+         break;
+       case 'q': case 'Q':
+         cleanup_olc(d, CLEANUP_ALL);
+         break;
+       case 'n': case 'N':
+         OLC_ZNUM(d)++;
+         for (;(OLC_ZNUM(d) <= top_of_socialt); OLC_ZNUM(d)++)
+           if (is_abbrev(OLC_STORAGE(d), soc_mess_list[OLC_ZNUM(d)].command)) 
+             break;
+
+         if (OLC_ZNUM(d) > top_of_socialt) {
+            if (find_command(OLC_STORAGE(d)) != NOTHING)  {
+               cleanup_olc(d, CLEANUP_ALL);
+               break;
+            }
+            write_to_output(d, "Do you wish to add the '%s' action? ",
+                               OLC_STORAGE(d));
+            OLC_MODE(d) = AEDIT_CONFIRM_ADD;
+         } else  {
+            write_to_output(d, "Do you wish to edit the '%s' action? ",
+                            soc_mess_list[OLC_ZNUM(d)].command);
+            OLC_MODE(d) = AEDIT_CONFIRM_EDIT;
+         }
+         break;
+       default:
+         write_to_output(d, "Invalid choice!\r\n"
+                            "Do you wish to edit the '%s' action? ", 
+                            soc_mess_list[OLC_ZNUM(d)].command);
+         break;
+      }
+      return;
+
+    case AEDIT_CONFIRM_ADD:
+      switch (*arg)  {
+       case 'y': case 'Y':
+         aedit_setup_new(d);
+         break;
+       case 'n': case 'N': case 'q': case 'Q':
+         cleanup_olc(d, CLEANUP_ALL);
+         break;
+       default:
+         write_to_output(d, "Invalid choice!\r\n"
+                            "Do you wish to add the '%s' action? ", 
+                            OLC_STORAGE(d));
+         break;
+      }
+      return;
+
+    case AEDIT_MAIN_MENU:
+      switch (*arg) {
+       case 'q': case 'Q':
+         if (OLC_VAL(d))  { /* Something was modified */
+            write_to_output(d, "Do you wish to save this action internally? ");
+            OLC_MODE(d) = AEDIT_CONFIRM_SAVESTRING;
+         }
+         else cleanup_olc(d, CLEANUP_ALL);
+         break;
+       case 'n':
+         write_to_output(d, "Enter action name: ");
+         OLC_MODE(d) = AEDIT_ACTION_NAME;
+         return;
+       case '1':
+         write_to_output(d, "Enter sort info for this action (for the command listing): ");
+         OLC_MODE(d) = AEDIT_SORT_AS;
+         return;
+       case '2':
+         write_to_output(d, "Enter the minimum position the Character has to be in to activate social:\r\n");
+         {
+           int i;
+           for (i=POS_DEAD;i<=POS_STANDING;i++)
+             write_to_output(d, "   %d) %s\r\n", i, position_types[i]);
+           
+           write_to_output(d, "Enter choice: ");
+         }
+         OLC_MODE(d) = AEDIT_MIN_CHAR_POS;
+         return;
+       case '3':
+         write_to_output(d, "Enter the minimum position the Victim has to be in to activate social:\r\n");
+         {
+           int i;
+           for (i=POS_DEAD;i<=POS_STANDING;i++)
+             write_to_output(d, "   %d) %s\r\n", i, position_types[i]);
+           
+           write_to_output(d, "Enter choice: ");
+         }
+         OLC_MODE(d) = AEDIT_MIN_VICT_POS;
+         return;
+       case '4':
+         write_to_output(d, "Enter new minimum level for social: ");
+         OLC_MODE(d) = AEDIT_MIN_CHAR_LEVEL;
+         return;
+       case '5':
+         OLC_ACTION(d)->hide = !OLC_ACTION(d)->hide;
+         aedit_disp_menu(d);
+         OLC_VAL(d) = 1;
+         break;
+       case 'a': case 'A':
+         write_to_output(d, "Enter social shown to the Character when there is no argument supplied.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                 ((OLC_ACTION(d)->char_no_arg)?OLC_ACTION(d)->char_no_arg:"NULL"));
+         OLC_MODE(d) = AEDIT_NOVICT_CHAR;
+         return;
+       case 'b': case 'B':
+         write_to_output(d, "Enter social shown to Others when there is no argument supplied.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->others_no_arg)?OLC_ACTION(d)->others_no_arg:"NULL"));
+         OLC_MODE(d) = AEDIT_NOVICT_OTHERS;
+         return;
+       case 'c': case 'C':
+         write_to_output(d, "Enter text shown to the Character when his victim isnt found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->not_found)?OLC_ACTION(d)->not_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_NOT_FOUND;
+         return;
+       case 'd': case 'D':
+         write_to_output(d, "Enter social shown to the Character when it is its own victim.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->char_auto)?OLC_ACTION(d)->char_auto:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_SELF_CHAR;
+         return;
+       case 'e': case 'E':
+         write_to_output(d, "Enter social shown to Others when the Char is its own victim.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->others_auto)?OLC_ACTION(d)->others_auto:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_SELF_OTHERS;
+         return;
+       case 'f': case 'F':
+         write_to_output(d, "Enter normal social shown to the Character when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->char_found)?OLC_ACTION(d)->char_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_CHAR_FOUND;
+         return;
+       case 'g': case 'G':
+         write_to_output(d, "Enter normal social shown to Others when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->others_found)?OLC_ACTION(d)->others_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_OTHERS_FOUND;
+         return;
+       case 'h': case 'H':
+         write_to_output(d, "Enter normal social shown to the Victim when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->vict_found)?OLC_ACTION(d)->vict_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_VICT_FOUND;
+         return;
+       case 'i': case 'I':
+         write_to_output(d, "Enter 'body part' social shown to the Character when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->char_body_found)?OLC_ACTION(d)->char_body_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_CHAR_BODY_FOUND;
+         return;
+       case 'j': case 'J':
+         write_to_output(d, "Enter 'body part' social shown to Others when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->others_body_found)?OLC_ACTION(d)->others_body_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_OTHERS_BODY_FOUND;
+         return;
+       case 'k': case 'K':
+         write_to_output(d, "Enter 'body part' social shown to the Victim when the victim is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->vict_body_found)?OLC_ACTION(d)->vict_body_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_VICT_VICT_BODY_FOUND;
+         return;
+       case 'l': case 'L':
+         write_to_output(d, "Enter 'object' social shown to the Character when the object is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->char_obj_found)?OLC_ACTION(d)->char_obj_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_OBJ_CHAR_FOUND;
+         return;
+       case 'm': case 'M':
+         write_to_output(d, "Enter 'object' social shown to the Room when the object is found.\r\n"
+                            "[OLD]: %s\r\n"
+                            "[NEW]: ",
+                            ((OLC_ACTION(d)->others_obj_found)?OLC_ACTION(d)->others_obj_found:"NULL"));
+         
+         OLC_MODE(d) = AEDIT_OBJ_OTHERS_FOUND;
+         return;
+       default:
+         aedit_disp_menu(d);
+         break;
+      }
+      return;
+         
+    case AEDIT_ACTION_NAME:
+      if (!*arg || strchr(arg,' ')) {
+        aedit_disp_menu(d);
+        return;
+      } 
+      if (OLC_ACTION(d)->command)
+        free(OLC_ACTION(d)->command);
+        OLC_ACTION(d)->command = strdup(arg);
+
+      break;
+
+    case AEDIT_SORT_AS:
+      if (!*arg || strchr(arg,' ')) {
+        aedit_disp_menu(d);
+        return;
+      }
+      if (OLC_ACTION(d)->sort_as) {
+        free(OLC_ACTION(d)->sort_as);
+        OLC_ACTION(d)->sort_as = strdup(arg);
+      }
+      break;
+
+    case AEDIT_MIN_CHAR_POS:
+    case AEDIT_MIN_VICT_POS:
+      if (!*arg) {
+        aedit_disp_menu(d);
+        return;
+      }
+      i = atoi(arg);
+      if ((i < POS_DEAD) && (i > POS_STANDING))  {
+        aedit_disp_menu(d);
+        return;
+      } 
+      if (OLC_MODE(d) == AEDIT_MIN_CHAR_POS)
+        OLC_ACTION(d)->min_char_position = i;
+      else
+        OLC_ACTION(d)->min_victim_position = i;
+      break;
+      
+    case AEDIT_MIN_CHAR_LEVEL:
+      if (!*arg) {
+        aedit_disp_menu(d);
+        return;
+      }
+      i = atoi(arg);
+      if ((i < 0) && (i > LVL_IMPL))  {
+        aedit_disp_menu(d);
+        return;
+      }
+      OLC_ACTION(d)->min_level_char = i;
+      break;
+
+    case AEDIT_NOVICT_CHAR:
+      if (OLC_ACTION(d)->char_no_arg)
+        free(OLC_ACTION(d)->char_no_arg);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->char_no_arg = strdup(arg);
+      } else 
+        OLC_ACTION(d)->char_no_arg = NULL;
+      break;
+
+    case AEDIT_NOVICT_OTHERS:
+      if (OLC_ACTION(d)->others_no_arg)
+        free(OLC_ACTION(d)->others_no_arg);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->others_no_arg = strdup(arg);
+      } else
+        OLC_ACTION(d)->others_no_arg = NULL;
+      break;
+
+    case AEDIT_VICT_CHAR_FOUND:
+      if (OLC_ACTION(d)->char_found)
+        free(OLC_ACTION(d)->char_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->char_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->char_found = NULL;
+      break;
+
+    case AEDIT_VICT_OTHERS_FOUND:
+      if (OLC_ACTION(d)->others_found)
+        free(OLC_ACTION(d)->others_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->others_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->others_found = NULL;
+      break;
+
+    case AEDIT_VICT_VICT_FOUND:
+      if (OLC_ACTION(d)->vict_found)
+        free(OLC_ACTION(d)->vict_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->vict_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->vict_found = NULL;
+      break;
+
+    case AEDIT_VICT_NOT_FOUND:
+      if (OLC_ACTION(d)->not_found)
+        free(OLC_ACTION(d)->not_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->not_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->not_found = NULL;
+      break;
+
+    case AEDIT_SELF_CHAR:
+      if (OLC_ACTION(d)->char_auto)
+        free(OLC_ACTION(d)->char_auto);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->char_auto = strdup(arg);
+      } else
+        OLC_ACTION(d)->char_auto = NULL;
+      break;
+
+    case AEDIT_SELF_OTHERS:
+      if (OLC_ACTION(d)->others_auto)
+        free(OLC_ACTION(d)->others_auto);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->others_auto = strdup(arg);
+      } else
+        OLC_ACTION(d)->others_auto = NULL;
+      break;
+
+    case AEDIT_VICT_CHAR_BODY_FOUND:
+      if (OLC_ACTION(d)->char_body_found)
+        free(OLC_ACTION(d)->char_body_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->char_body_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->char_body_found = NULL;
+      break;
+
+    case AEDIT_VICT_OTHERS_BODY_FOUND:
+      if (OLC_ACTION(d)->others_body_found)
+        free(OLC_ACTION(d)->others_body_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->others_body_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->others_body_found = NULL;
+      break;
+
+    case AEDIT_VICT_VICT_BODY_FOUND:
+      if (OLC_ACTION(d)->vict_body_found)
+        free(OLC_ACTION(d)->vict_body_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->vict_body_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->vict_body_found = NULL;
+      break;
+
+    case AEDIT_OBJ_CHAR_FOUND:
+      if (OLC_ACTION(d)->char_obj_found)
+        free(OLC_ACTION(d)->char_obj_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->char_obj_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->char_obj_found = NULL;
+      break;
+
+    case AEDIT_OBJ_OTHERS_FOUND:
+      if (OLC_ACTION(d)->others_obj_found)
+        free(OLC_ACTION(d)->others_obj_found);
+      if (*arg) {
+        delete_doubledollar(arg);
+        OLC_ACTION(d)->others_obj_found = strdup(arg);
+      } else
+        OLC_ACTION(d)->others_obj_found = NULL;
+      break;
+
+    default:
+      /* we should never get here */
+      break;
+   }
+   OLC_VAL(d) = 1;
+   aedit_disp_menu(d);
+}
+
+ACMD(do_astat)
+{
+  int i, real = FALSE;
+  char arg[MAX_INPUT_LENGTH];
+
+  if (IS_NPC(ch))
+    return;
+
+  one_argument(argument, arg);
+
+  if(!*arg) {
+    send_to_char(ch, "Astat which social?\r\n");
+    return;
+  }
+
+  for (i = 0; i <= top_of_socialt; i++) {
+    if (is_abbrev(arg, soc_mess_list[i].command)) {
+      real = TRUE;
+      break;
+    }
+  }
+
+  if (!real) {
+    send_to_char(ch, "No such social.\r\n");
+    return;
+  }
+
+   get_char_colors(ch);
+   send_to_char(ch, 
+    "n) Command         : %s%-15.15s%s 1) Sort as Command : %s%-15.15s%s\r\n"
+    "2) Min Position[CH]: %s%-8.8s%s        3) Min Position[VT]: %s%-8.8s%s\r\n"
+    "4) Min Level   [CH]: %s%-3d%s             5) Show if Invis   : %s%s%s\r\n"
+    "a) Char    [NO ARG]: %s%s%s\r\n"
+    "b) Others  [NO ARG]: %s%s%s\r\n"
+    "c) Char [NOT FOUND]: %s%s%s\r\n"
+    "d) Char  [ARG SELF]: %s%s%s\r\n"
+    "e) Others[ARG SELF]: %s%s%s\r\n"
+    "f) Char      [VICT]: %s%s%s\r\n"
+    "g) Others    [VICT]: %s%s%s\r\n"
+    "h) Victim    [VICT]: %s%s%s\r\n"
+    "i) Char  [BODY PRT]: %s%s%s\r\n"
+    "j) Others[BODY PRT]: %s%s%s\r\n"
+    "k) Victim[BODY PRT]: %s%s%s\r\n"
+    "l) Char       [OBJ]: %s%s%s\r\n"
+    "m) Others     [OBJ]: %s%s%s\r\n",
+
+    yel, soc_mess_list[i].command, nrm,
+    yel, soc_mess_list[i].sort_as, nrm,
+    cyn, position_types[soc_mess_list[i].min_char_position], nrm,
+    cyn, position_types[soc_mess_list[i].min_victim_position], nrm,
+    cyn, soc_mess_list[i].min_level_char, nrm,
+    cyn, (soc_mess_list[i].hide ? "HIDDEN" : "NOT HIDDEN"), nrm,
+    cyn, soc_mess_list[i].char_no_arg ? soc_mess_list[i].char_no_arg : "", nrm,
+    cyn, soc_mess_list[i].others_no_arg ? soc_mess_list[i].others_no_arg : "", nrm,
+    cyn, soc_mess_list[i].not_found ? soc_mess_list[i].not_found : "", nrm,
+    cyn, soc_mess_list[i].char_auto ? soc_mess_list[i].char_auto : "", nrm,
+    cyn, soc_mess_list[i].others_auto ? soc_mess_list[i].others_auto : "", nrm,
+    cyn, soc_mess_list[i].char_found ? soc_mess_list[i].char_found : "", nrm,
+    cyn, soc_mess_list[i].others_found ? soc_mess_list[i].others_found : "", nrm,
+    cyn, soc_mess_list[i].vict_found ? soc_mess_list[i].vict_found : "", nrm,
+    cyn, soc_mess_list[i].char_body_found ? soc_mess_list[i].char_body_found : "", nrm,
+    cyn, soc_mess_list[i].others_body_found ? soc_mess_list[i].others_body_found : "", nrm,
+    cyn, soc_mess_list[i].vict_body_found ? soc_mess_list[i].vict_body_found : "", nrm,
+    cyn, soc_mess_list[i].char_obj_found ? soc_mess_list[i].char_obj_found : "", nrm,
+    cyn, soc_mess_list[i].others_obj_found ? soc_mess_list[i].others_obj_found : "", nrm);
+
+}
diff -BENbdpru circle-3.1/src/ban.c circle3.1_oasis206/src/ban.c
--- circle-3.1/src/ban.c	2002-04-09 16:12:16.000000000 +0200
+++ circle3.1_oasis206/src/ban.c	2003-10-06 22:08:10.000000000 +0200
@@ -247,7 +247,7 @@ int num_invalid = 0;
 
 int Valid_Name(char *newname)
 {
-  int i;
+  int i, wovels = 0;
   struct descriptor_data *dt;
   char tempname[MAX_INPUT_LENGTH];
 
@@ -256,11 +256,27 @@ int Valid_Name(char *newname)
    * do a 'str_cmp' so people can't do 'Bob' and 'BoB'.  The creating login
    * will not have a character name yet and other people sitting at the
    * prompt won't have characters yet.
+   *
+   * New, unindexed characters (i.e., characters who are in the process of creating)
+   * will have an idnum of -1, set by clear_char() in db.c.  If someone is creating a
+   * character by the same name as the one we are checking, then the name is invalid,
+   * to prevent character duping.
+   * THIS SHOULD FIX THE 'invalid name' if disconnected from OLC-bug - WELCOR 9/00
    */
   for (dt = descriptor_list; dt; dt = dt->next)
     if (dt->character && GET_NAME(dt->character) && !str_cmp(GET_NAME(dt->character), newname))
-      return (STATE(dt) == CON_PLAYING);
+      if (GET_IDNUM(dt->character) == -1)
+        return (IS_PLAYING(dt));
 
+  /* count wovels */
+  for (i = 0; newname[i]; i++) {
+    if (strchr("aeiouyAEIOUY", newname[i]))
+      wovels++;
+  }
+
+  /* return invalid if no wovels */
+  if (!wovels)
+    return (0);
   /* return valid if list doesn't exist */
   if (!invalid_list || num_invalid < 1)
     return (1);
diff -BENbdpru circle-3.1/src/boards.c circle3.1_oasis206/src/boards.c
--- circle-3.1/src/boards.c	2002-09-26 01:45:06.000000000 +0200
+++ circle3.1_oasis206/src/boards.c	2003-10-07 11:27:44.000000000 +0200
@@ -55,6 +54,7 @@ TO ADD A NEW BOARD, simply follow our ea
 #include "boards.h"
 #include "interpreter.h"
 #include "handler.h"
+#include "improved-edit.h"
 
 /* Board appearance order. */
 #define	NEWEST_AT_TOP	FALSE
@@ -140,11 +140,6 @@ void init_boards(void)
     Board_load_board(i);
   }
 
-  ACMD_READ = find_command("read");
-  ACMD_WRITE = find_command("write");
-  ACMD_REMOVE = find_command("remove");
-  ACMD_LOOK = find_command("look");
-  ACMD_EXAMINE = find_command("examine");
 
   if (fatal_error)
     exit(1);
@@ -164,6 +159,12 @@ SPECIAL(gen_board)
   if (!ch->desc)
     return (0);
 
+  ACMD_READ = find_command("read");
+  ACMD_WRITE = find_command("write");
+  ACMD_REMOVE = find_command("remove");
+  ACMD_LOOK = find_command("look");
+  ACMD_EXAMINE = find_command("examine");
+
   if (cmd != ACMD_WRITE && cmd != ACMD_LOOK && cmd != ACMD_EXAMINE &&
       cmd != ACMD_READ && cmd != ACMD_REMOVE)
     return (0);
@@ -224,7 +225,8 @@ int Board_write_message(int board_type, 
   NEW_MSG_INDEX(board_type).heading = strdup(buf);
   NEW_MSG_INDEX(board_type).level = GET_LEVEL(ch);
 
-  send_to_char(ch, "Write your message.  Terminate with a @ on a new line.\r\n\r\n");
+  send_to_char(ch, "Write your message.\r\n");
+  send_editor_help(ch->desc);
   act("$n starts to write a message.", TRUE, ch, 0, 0, TO_ROOM);
 
   string_write(ch->desc, &(msg_storage[NEW_MSG_INDEX(board_type).slot_num]),
@@ -416,9 +418,6 @@ int Board_remove_msg(int board_type, str
     MSG_SLOTNUM(board_type, ind) = MSG_SLOTNUM(board_type, ind + 1);
     MSG_LEVEL(board_type, ind) = MSG_LEVEL(board_type, ind + 1);
   }
-  MSG_HEADING(board_type, num_of_msgs[board_type] - 1) = NULL;
-  MSG_SLOTNUM(board_type, num_of_msgs[board_type] - 1) = 0;
-  MSG_LEVEL(board_type, num_of_msgs[board_type] - 1) = 0;
   num_of_msgs[board_type]--;
 
   send_to_char(ch, "Message removed.\r\n");
diff -BENbdpru circle-3.1/src/cedit.c circle3.1_oasis206/src/cedit.c
--- circle-3.1/src/cedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/cedit.c	2003-10-06 22:37:04.000000000 +0200
@@ -0,0 +1,1706 @@
+/************************************************************************
+ * OasisOLC - Game configuration / cedit.c                   v2.0	*
+ * Copyright 2002-2003 Kip Potter   (kip_potter@hotmail.com)            *
+ * A graphical in-game game configuration utility for OasisOLC.         *
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "utils.h"
+#include "db.h"
+#include "constants.h"
+#include "genolc.h"
+#include "oasis.h"
+#include "improved-edit.h"
+
+
+/******************************************************************************/
+/** External Functions                                                       **/
+/******************************************************************************/
+void free_config(struct config_data *data);
+
+/******************************************************************************/
+/** Internal Macros                                                          **/
+/******************************************************************************/
+#define NO 0
+#define YES 1
+
+#define CHECK_VAR(var)  ((var == YES) ? "Yes" : "No")
+#define TOGGLE_VAR(var)	if (var == YES) { var = NO; } else { var = YES; }
+
+
+/******************************************************************************/
+/** Internal Functions                                                       **/
+/******************************************************************************/
+void cedit_disp_menu(struct descriptor_data *d);
+void cedit_setup(struct descriptor_data *d);
+void cedit_save_to_disk( void );
+int  save_config( IDXTYPE nowhere );
+void reassign_rooms(void);
+
+/******************************************************************************/
+/** Routines                                                                 **/
+/******************************************************************************/
+ACMD(do_oasis_cedit)
+{
+  struct descriptor_data *d;
+  char buf1[MAX_STRING_LENGTH];
+  
+  /****************************************************************************/
+  /** Parse any arguments.                                                   **/
+  /****************************************************************************/
+  one_argument(argument, buf1);
+  
+  if (GET_LEVEL(ch) < LVL_IMPL) {
+    send_to_char(ch, "You can't modify the game configuration.\r\n");
+    return;
+  }
+  
+  d = ch->desc;
+  
+  if (!*buf1) {
+    CREATE(d->olc, struct oasis_olc_data, 1);
+    OLC_ZONE(d) = 0;
+    cedit_setup(d);
+    STATE(d) = CON_CEDIT;
+    act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+    SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+    
+    mudlog(BRF, LVL_IMMORT, TRUE, 
+      "OLC: %s starts editing the game configuration.", GET_NAME(ch));
+    return;
+  } else if (str_cmp("save", buf1) != 0) {
+    send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+    return;
+  }
+  
+  send_to_char(ch, "Saving the game configuration.\r\n");
+  mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE, 
+    "OLC: %s saves the game configuration.", GET_NAME(ch));
+  
+  cedit_save_to_disk();
+}
+
+/*-------------------------------------------------------------------*/
+
+void cedit_setup(struct descriptor_data *d)
+{
+  /****************************************************************************/
+  /** Create the config_data struct.                                         **/
+  /****************************************************************************/
+  CREATE(OLC_CONFIG(d), struct config_data, 1);
+  
+  /****************************************************************************/
+  /** Copy the current configuration from the config_info to this one.       **/
+  /****************************************************************************/
+  /****************************************************************************/
+  /** Copy the game play options from the configuration info struct.         **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->play.pk_allowed          = CONFIG_PK_ALLOWED;
+  OLC_CONFIG(d)->play.pt_allowed          = CONFIG_PT_ALLOWED;
+  OLC_CONFIG(d)->play.level_can_shout     = CONFIG_LEVEL_CAN_SHOUT;
+  OLC_CONFIG(d)->play.holler_move_cost    = CONFIG_HOLLER_MOVE_COST;
+  OLC_CONFIG(d)->play.tunnel_size         = CONFIG_TUNNEL_SIZE;
+  OLC_CONFIG(d)->play.max_exp_gain        = CONFIG_MAX_EXP_GAIN;
+  OLC_CONFIG(d)->play.max_exp_loss        = CONFIG_MAX_EXP_LOSS;
+  OLC_CONFIG(d)->play.max_npc_corpse_time = CONFIG_MAX_NPC_CORPSE_TIME;
+  OLC_CONFIG(d)->play.max_pc_corpse_time  = CONFIG_MAX_PC_CORPSE_TIME;
+  OLC_CONFIG(d)->play.idle_void           = CONFIG_IDLE_VOID;
+  OLC_CONFIG(d)->play.idle_rent_time      = CONFIG_IDLE_RENT_TIME;
+  OLC_CONFIG(d)->play.idle_max_level      = CONFIG_IDLE_MAX_LEVEL;
+  OLC_CONFIG(d)->play.dts_are_dumps       = CONFIG_DTS_ARE_DUMPS;
+  OLC_CONFIG(d)->play.load_into_inventory = CONFIG_LOAD_INVENTORY;
+  OLC_CONFIG(d)->play.track_through_doors = CONFIG_TRACK_T_DOORS;
+  OLC_CONFIG(d)->play.immort_level_ok     = CONFIG_IMMORT_LEVEL_OK;
+  
+  /****************************************************************************/
+  /** Crash Saves                                                            **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->csd.free_rent            = CONFIG_FREE_RENT;
+  OLC_CONFIG(d)->csd.max_obj_save         = CONFIG_MAX_OBJ_SAVE;
+  OLC_CONFIG(d)->csd.min_rent_cost        = CONFIG_MIN_RENT_COST;
+  OLC_CONFIG(d)->csd.auto_save            = CONFIG_AUTO_SAVE;
+  OLC_CONFIG(d)->csd.autosave_time        = CONFIG_AUTOSAVE_TIME;
+  OLC_CONFIG(d)->csd.crash_file_timeout   = CONFIG_CRASH_TIMEOUT;
+  OLC_CONFIG(d)->csd.rent_file_timeout    = CONFIG_RENT_TIMEOUT;
+  
+  /****************************************************************************/
+  /** Room Numbers                                                           **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->room_nums.mortal_start_room = CONFIG_MORTAL_START;
+  OLC_CONFIG(d)->room_nums.immort_start_room = CONFIG_IMMORTAL_START;
+  OLC_CONFIG(d)->room_nums.frozen_start_room = CONFIG_FROZEN_START;
+  OLC_CONFIG(d)->room_nums.donation_room_1   = CONFIG_DON_ROOM_1;
+  OLC_CONFIG(d)->room_nums.donation_room_2   = CONFIG_DON_ROOM_2;
+  OLC_CONFIG(d)->room_nums.donation_room_3   = CONFIG_DON_ROOM_3;
+  
+  /****************************************************************************/
+  /** Game Operation                                                         **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->operation.DFLT_PORT          = CONFIG_DFLT_PORT;
+  OLC_CONFIG(d)->operation.max_playing        = CONFIG_MAX_PLAYING;
+  OLC_CONFIG(d)->operation.max_filesize       = CONFIG_MAX_FILESIZE;
+  OLC_CONFIG(d)->operation.max_bad_pws        = CONFIG_MAX_BAD_PWS;
+  OLC_CONFIG(d)->operation.siteok_everyone    = CONFIG_SITEOK_ALL;
+  OLC_CONFIG(d)->operation.use_new_socials    = CONFIG_NEW_SOCIALS;
+  OLC_CONFIG(d)->operation.auto_save_olc      = CONFIG_OLC_SAVE;
+  OLC_CONFIG(d)->operation.nameserver_is_slow = CONFIG_NS_IS_SLOW;
+  
+  /****************************************************************************/
+  /** Autowiz                                                                **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->autowiz.use_autowiz          = CONFIG_USE_AUTOWIZ;
+  OLC_CONFIG(d)->autowiz.min_wizlist_lev      = CONFIG_MIN_WIZLIST_LEV;
+  
+  
+  /****************************************************************************/
+  /** Allocate space for the strings.                                        **/
+  /****************************************************************************/
+  OLC_CONFIG(d)->play.OK       = str_udup(CONFIG_OK);
+  OLC_CONFIG(d)->play.NOPERSON = str_udup(CONFIG_NOPERSON);
+  OLC_CONFIG(d)->play.NOEFFECT = str_udup(CONFIG_NOEFFECT);
+  
+  if (CONFIG_DFLT_IP)
+    OLC_CONFIG(d)->operation.DFLT_IP     = strdup(CONFIG_DFLT_IP);
+  else
+    OLC_CONFIG(d)->operation.DFLT_IP     = NULL;
+  
+  if (CONFIG_DFLT_DIR)
+    OLC_CONFIG(d)->operation.DFLT_DIR    = strdup(CONFIG_DFLT_DIR);
+  else
+    OLC_CONFIG(d)->operation.DFLT_DIR    = NULL;
+
+  if (CONFIG_LOGNAME)
+    OLC_CONFIG(d)->operation.LOGNAME     = strdup(CONFIG_LOGNAME);
+  else
+    OLC_CONFIG(d)->operation.LOGNAME     = NULL;
+  
+  if (CONFIG_MENU)
+    OLC_CONFIG(d)->operation.MENU        = strdup(CONFIG_MENU);
+  else
+    OLC_CONFIG(d)->operation.MENU        = NULL;
+  
+  if (CONFIG_WELC_MESSG)
+    OLC_CONFIG(d)->operation.WELC_MESSG  = strdup(CONFIG_WELC_MESSG);
+  else
+    OLC_CONFIG(d)->operation.WELC_MESSG  = NULL;
+  
+  if (CONFIG_START_MESSG)
+    OLC_CONFIG(d)->operation.START_MESSG = strdup(CONFIG_START_MESSG);
+  else
+    OLC_CONFIG(d)->operation.START_MESSG = NULL;
+  
+  cedit_disp_menu(d);
+}
+
+/******************************************************************************/
+
+void cedit_save_internally(struct descriptor_data *d)
+{
+  /* see if we need to reassign spec procs on rooms */
+  int reassign = (CONFIG_DTS_ARE_DUMPS != OLC_CONFIG(d)->play.dts_are_dumps);
+  /****************************************************************************/
+  /** Copy the data back from the descriptor to the config_info structure.   **/
+  /****************************************************************************/
+  CONFIG_PK_ALLOWED          = OLC_CONFIG(d)->play.pk_allowed;
+  CONFIG_PT_ALLOWED          = OLC_CONFIG(d)->play.pt_allowed;
+  CONFIG_LEVEL_CAN_SHOUT     = OLC_CONFIG(d)->play.level_can_shout;
+  CONFIG_HOLLER_MOVE_COST    = OLC_CONFIG(d)->play.holler_move_cost;
+  CONFIG_TUNNEL_SIZE         = OLC_CONFIG(d)->play.tunnel_size;
+  CONFIG_MAX_EXP_GAIN        = OLC_CONFIG(d)->play.max_exp_gain;
+  CONFIG_MAX_EXP_LOSS        = OLC_CONFIG(d)->play.max_exp_loss;
+  CONFIG_MAX_NPC_CORPSE_TIME = OLC_CONFIG(d)->play.max_npc_corpse_time;
+  CONFIG_MAX_PC_CORPSE_TIME  = OLC_CONFIG(d)->play.max_pc_corpse_time;
+  CONFIG_IDLE_VOID           = OLC_CONFIG(d)->play.idle_void;
+  CONFIG_IDLE_RENT_TIME      = OLC_CONFIG(d)->play.idle_rent_time;
+  CONFIG_IDLE_MAX_LEVEL      = OLC_CONFIG(d)->play.idle_max_level;
+  CONFIG_DTS_ARE_DUMPS       = OLC_CONFIG(d)->play.dts_are_dumps;
+  CONFIG_LOAD_INVENTORY = OLC_CONFIG(d)->play.load_into_inventory;
+  CONFIG_TRACK_T_DOORS = OLC_CONFIG(d)->play.track_through_doors;
+  CONFIG_IMMORT_LEVEL_OK     = OLC_CONFIG(d)->play.immort_level_ok;
+  
+  /****************************************************************************/
+  /** Crash Saves                                                            **/
+  /****************************************************************************/
+  CONFIG_FREE_RENT            = OLC_CONFIG(d)->csd.free_rent;
+  CONFIG_MAX_OBJ_SAVE         = OLC_CONFIG(d)->csd.max_obj_save;
+  CONFIG_MIN_RENT_COST        = OLC_CONFIG(d)->csd.min_rent_cost;
+  CONFIG_AUTO_SAVE            = OLC_CONFIG(d)->csd.auto_save;
+  CONFIG_AUTOSAVE_TIME        = OLC_CONFIG(d)->csd.autosave_time;
+  CONFIG_CRASH_TIMEOUT   = OLC_CONFIG(d)->csd.crash_file_timeout;
+  CONFIG_RENT_TIMEOUT    = OLC_CONFIG(d)->csd.rent_file_timeout;
+  
+  /****************************************************************************/
+  /** Room Numbers                                                           **/
+  /****************************************************************************/
+  CONFIG_MORTAL_START = OLC_CONFIG(d)->room_nums.mortal_start_room;
+  CONFIG_IMMORTAL_START = OLC_CONFIG(d)->room_nums.immort_start_room;
+  CONFIG_FROZEN_START = OLC_CONFIG(d)->room_nums.frozen_start_room;
+  CONFIG_DON_ROOM_1   = OLC_CONFIG(d)->room_nums.donation_room_1;
+  CONFIG_DON_ROOM_2   = OLC_CONFIG(d)->room_nums.donation_room_2;
+  CONFIG_DON_ROOM_3   = OLC_CONFIG(d)->room_nums.donation_room_3;
+  
+  /****************************************************************************/
+  /** Game Operation                                                         **/
+  /****************************************************************************/
+  CONFIG_DFLT_PORT          = OLC_CONFIG(d)->operation.DFLT_PORT;
+  CONFIG_MAX_PLAYING        = OLC_CONFIG(d)->operation.max_playing;
+  CONFIG_MAX_FILESIZE       = OLC_CONFIG(d)->operation.max_filesize;
+  CONFIG_MAX_BAD_PWS        = OLC_CONFIG(d)->operation.max_bad_pws;
+  CONFIG_SITEOK_ALL         = OLC_CONFIG(d)->operation.siteok_everyone;
+  CONFIG_NEW_SOCIALS        = OLC_CONFIG(d)->operation.use_new_socials;  
+  CONFIG_NS_IS_SLOW         = OLC_CONFIG(d)->operation.nameserver_is_slow;
+  CONFIG_OLC_SAVE           = OLC_CONFIG(d)->operation.auto_save_olc;
+  
+  /****************************************************************************/
+  /** Autowiz                                                                **/
+  /****************************************************************************/
+  CONFIG_USE_AUTOWIZ          = OLC_CONFIG(d)->autowiz.use_autowiz;
+  CONFIG_MIN_WIZLIST_LEV      = OLC_CONFIG(d)->autowiz.min_wizlist_lev;
+  
+  /****************************************************************************/
+  /** Allocate space for the strings.                                        **/
+  /****************************************************************************/
+  if (CONFIG_OK)
+    free(CONFIG_OK);
+  CONFIG_OK       = str_udup(OLC_CONFIG(d)->play.OK);
+  
+  if (CONFIG_NOPERSON)
+    free(CONFIG_NOPERSON);
+  CONFIG_NOPERSON = str_udup(OLC_CONFIG(d)->play.NOPERSON);
+  
+  if (CONFIG_NOEFFECT)
+    free(CONFIG_NOEFFECT);
+  CONFIG_NOEFFECT = str_udup(OLC_CONFIG(d)->play.NOEFFECT);
+  
+  if (CONFIG_DFLT_IP)
+    free(CONFIG_DFLT_IP);
+  if (OLC_CONFIG(d)->operation.DFLT_IP)
+    CONFIG_DFLT_IP     = strdup(OLC_CONFIG(d)->operation.DFLT_IP);
+  else
+    CONFIG_DFLT_IP     = NULL;
+  
+  
+  if (CONFIG_DFLT_DIR)
+    free(CONFIG_DFLT_DIR);
+  if (OLC_CONFIG(d)->operation.DFLT_DIR)
+    CONFIG_DFLT_DIR    = strdup(OLC_CONFIG(d)->operation.DFLT_DIR);
+  else
+    CONFIG_DFLT_DIR    = NULL;
+
+  if (CONFIG_LOGNAME)
+    free(CONFIG_LOGNAME);
+  if (OLC_CONFIG(d)->operation.LOGNAME)
+    CONFIG_LOGNAME     = strdup(OLC_CONFIG(d)->operation.LOGNAME);
+  else
+    CONFIG_LOGNAME     = NULL;
+  
+  if (CONFIG_MENU)
+    free(CONFIG_MENU);
+  if (OLC_CONFIG(d)->operation.MENU)
+    CONFIG_MENU        = strdup(OLC_CONFIG(d)->operation.MENU);
+  else
+    CONFIG_MENU        = NULL;
+  
+  if (CONFIG_WELC_MESSG)
+    free(CONFIG_WELC_MESSG);
+  if (OLC_CONFIG(d)->operation.WELC_MESSG)
+    CONFIG_WELC_MESSG  = strdup(OLC_CONFIG(d)->operation.WELC_MESSG);
+  else
+    CONFIG_WELC_MESSG  = NULL;
+  
+  if (CONFIG_START_MESSG)
+    free(CONFIG_START_MESSG);
+  if (OLC_CONFIG(d)->operation.START_MESSG)
+    CONFIG_START_MESSG = strdup(OLC_CONFIG(d)->operation.START_MESSG);
+  else
+    CONFIG_START_MESSG = NULL;
+  
+  /* if we changed the dts to/from dumps, reassign - Welcor */
+  if (reassign)
+    reassign_rooms();
+
+  add_to_save_list(NOWHERE, SL_CFG);
+}
+
+/******************************************************************************/
+
+void cedit_save_to_disk( void )
+{
+  /****************************************************************************/
+  /** Just call save_config and get it over with.                            **/
+  /****************************************************************************/
+  save_config( NOWHERE );
+}
+
+/******************************************************************************/
+
+int save_config( IDXTYPE nowhere )
+{
+  FILE *fl;
+  char buf[MAX_STRING_LENGTH];
+  
+  if (!(fl = fopen(CONFIG_CONFFILE, "w"))) {
+    perror("SYSERR: save_config");
+    return (FALSE);
+  }
+  
+  fprintf(fl, 
+    "* This file is autogenerated by OasisOLC (CEdit).\n"
+    "* Please note the following information about this file's format.\n"
+    "*\n"
+    "* - If variable is a yes/no or true/false based variable, use 1's and 0's\n"
+    "*   where YES or TRUE = 1 and NO or FALSE = 0.\n"
+    "* - Variable names in this file are case-insensitive.  Variable values\n"
+    "*   are not case-insensitive.\n"
+    "* -----------------------------------------------------------------------\n"
+    "* Lines starting with * are comments, and are not parsed.\n"
+    "* -----------------------------------------------------------------------\n\n"
+    "* [ Game Play Options ]\n"
+  );
+    
+  fprintf(fl, "* Is player killing allowed on the mud?\n"
+              "pk_allowed = %d\n\n", CONFIG_PK_ALLOWED);
+  fprintf(fl, "* Is player thieving allowed on the mud?\n"
+  	      "pt_allowed = %d\n\n", CONFIG_PT_ALLOWED);
+  fprintf(fl, "* What is the minimum level a player can shout/gossip/etc?\n"
+              "level_can_shout = %d\n\n", CONFIG_LEVEL_CAN_SHOUT);
+  fprintf(fl, "* How many movement points does shouting cost the player?\n"
+  	      "holler_move_cost = %d\n\n", CONFIG_HOLLER_MOVE_COST);
+  fprintf(fl, "* How many players can fit in a tunnel?\n"
+              "tunnel_size = %d\n\n", CONFIG_TUNNEL_SIZE);
+  fprintf(fl, "* Maximum experience gainable per kill?\n"
+              "max_exp_gain = %d\n\n", CONFIG_MAX_EXP_GAIN);
+  fprintf(fl, "* Maximum experience loseable per death?\n"
+              "max_exp_loss = %d\n\n", CONFIG_MAX_EXP_LOSS);
+  fprintf(fl, "* Number of tics before NPC corpses decompose.\n"
+              "max_npc_corpse_time = %d\n\n", CONFIG_MAX_NPC_CORPSE_TIME);
+  fprintf(fl, "* Number of tics before PC corpses decompose.\n"
+              "max_pc_corpse_time = %d\n\n", CONFIG_MAX_PC_CORPSE_TIME);
+  fprintf(fl, "* Number of tics before a PC is sent to the void.\n"
+              "idle_void = %d\n\n", CONFIG_IDLE_VOID);
+  fprintf(fl, "* Number of tics before a PC is autorented.\n"
+              "idle_rent_time = %d\n\n", CONFIG_IDLE_RENT_TIME);
+  fprintf(fl, "* Level and above of players whom are immune to idle penalties.\n"
+              "idle_max_level = %d\n\n", CONFIG_IDLE_MAX_LEVEL);
+  fprintf(fl, "* Should the items in death traps be junked automatically?\n"
+              "dts_are_dumps = %d\n\n", CONFIG_DTS_ARE_DUMPS);
+  fprintf(fl, "* When an immortal loads an object, should it load into their inventory?\n"
+              "load_into_inventory = %d\n\n", CONFIG_LOAD_INVENTORY);
+  fprintf(fl, "* Should PC's be able to track through hidden or closed doors?\n"
+              "track_through_doors = %d\n\n", CONFIG_TRACK_T_DOORS);
+  fprintf(fl, "* Should players who reach enough exp automatically level to immortal?\n"
+              "immort_level_ok = %d\n\n", CONFIG_IMMORT_LEVEL_OK);
+              
+  strcpy(buf, CONFIG_OK);
+  strip_cr(buf);
+  
+  fprintf(fl, "* Text sent to players when OK is all that is needed.\n"
+              "ok = %s\n\n", buf);
+              
+  strcpy(buf, CONFIG_NOPERSON);
+  strip_cr(buf);            
+              
+  fprintf(fl, "* Text sent to players when noone is available.\n"
+              "noperson = %s\n\n", buf);
+              
+  strcpy(buf, CONFIG_NOEFFECT);
+  strip_cr(buf);
+  
+  fprintf(fl, "* Text sent to players when an effect fails.\n"
+              "noeffect = %s\n", buf);
+  
+  
+  
+  /************************************************************************
+   ** RENT / CRASHSAVE OPTIONS					         **
+   ************************************************************************/
+  fprintf(fl, "\n\n\n* [ Rent/Crashsave Options ]\n");
+  
+  fprintf(fl, "* Should the MUD allow you to 'rent' for free?  (i.e. if you just quit,\n"
+              "* your objects are saved at no cost, as in Merc-type MUDs.)\n"
+              "free_rent = %d\n\n", CONFIG_FREE_RENT);
+  
+  fprintf(fl, "* Maximum number of items players are allowed to rent.\n"
+   	      "max_obj_save = %d\n\n", CONFIG_MAX_OBJ_SAVE);
+  
+  fprintf(fl, "* Should the game automatically save people?\n"
+              "auto_save = %d\n\n", CONFIG_AUTO_SAVE);
+  
+  fprintf(fl, "* If auto_save = 1, how often (in minutes) should the game save people's objects?\n"
+              "autosave_time = %d\n\n", CONFIG_AUTOSAVE_TIME);
+  
+  fprintf(fl, "* Lifetime of crashfiles and force-rent (idlesave) files in days.\n"
+              "crash_file_timeout = %d\n\n", CONFIG_CRASH_TIMEOUT);
+  
+  fprintf(fl, "* Lifetime of normal rent files in days.\n"
+              "rent_file_timeout = %d\n\n", CONFIG_RENT_TIMEOUT);
+  
+  
+  /************************************************************************
+   ** ROOM NUMBERS						  	 **
+   ************************************************************************/
+  fprintf(fl, "\n\n\n* [ Room Numbers ]\n");
+  
+  fprintf(fl, "* The virtual number of the room that mortals should enter at.\n"
+  	      "mortal_start_room = %d\n\n", CONFIG_MORTAL_START);
+  
+  fprintf(fl, "* The virtual number of the room that immorts should enter at.\n"
+              "immort_start_room = %d\n\n", CONFIG_IMMORTAL_START);
+  
+  fprintf(fl, "* The virtual number of the room that frozen people should enter at.\n"
+	      "frozen_start_room = %d\n\n", CONFIG_FROZEN_START);
+
+  fprintf(fl, "* The virtual numbers of the donation rooms.  Note: Add donation rooms\n"
+              "* sequentially (1 & 2 before 3). If you don't, you might not be able to\n"
+              "* donate. Use -1 for 'no such room'.\n"
+              "donation_room_1 = %d\n"
+              "donation_room_2 = %d\n"
+              "donation_room_3 = %d\n\n",
+              CONFIG_DON_ROOM_1 != NOWHERE ? CONFIG_DON_ROOM_1 : -1,
+              CONFIG_DON_ROOM_2 != NOWHERE ? CONFIG_DON_ROOM_2 : -1,
+              CONFIG_DON_ROOM_3 != NOWHERE ? CONFIG_DON_ROOM_3 : -1);
+  
+  
+  fprintf(fl, "\n\n\n* [ Game Operation Options ]\n");
+  
+  fprintf(fl, "* This is the default port on which the game should run if no port is\n"
+              "* given on the command-line.  NOTE WELL: If you're using the\n"
+              "* 'autorun' script, the port number there will override this setting.\n"
+              "* Change the PORT= line in autorun instead of (or in addition to)\n"
+              "* changing this.\n"
+              "DFLT_PORT = %d\n\n",
+              CONFIG_DFLT_PORT);
+  
+  if (CONFIG_DFLT_IP) {
+    strcpy(buf, CONFIG_DFLT_IP);
+    strip_cr(buf);
+  
+    fprintf(fl, "* IP address to which the MUD should bind.\nDFLT_IP = %s\n\n", buf);
+  }
+  
+  if (CONFIG_DFLT_DIR) {
+    strcpy(buf, CONFIG_DFLT_DIR);
+    strip_cr(buf);
+    
+    fprintf(fl, "* default directory to use as data directory.\n"
+                "DFLT_DIR = %s\n\n", buf);
+  }
+  
+  if (CONFIG_LOGNAME) {
+    strcpy(buf, CONFIG_LOGNAME);
+    strip_cr(buf);
+    
+    fprintf(fl, "* What file to log messages to (ex: 'log/syslog').\n"
+                "LOGNAME = %s\n\n", buf);
+  }
+  
+  fprintf(fl, "* Maximum number of players allowed before game starts to turn people away.\n"
+              "max_playing = %d\n\n",
+              CONFIG_MAX_PLAYING);
+              
+  fprintf(fl, "* Maximum size of bug, typo, and idea files in bytes (to prevent bombing).\n"
+              "max_filesize = %d\n\n",
+              CONFIG_MAX_FILESIZE);
+  
+  fprintf(fl, "* Maximum number of password attempts before disconnection.\n"
+              "max_bad_pws = %d\n\n",
+              CONFIG_MAX_BAD_PWS);
+  
+  fprintf(fl, "* Is the site ok for everyone except those that are banned?\n"
+              "siteok_everyone = %d\n\n",
+              CONFIG_SITEOK_ALL);
+  
+  fprintf(fl, "* If you want to use the original social file format\n"
+              "* and disable Aedit, set to 0, otherwise, 1.\n"
+              "use_new_socials = %d\n\n",
+              CONFIG_NEW_SOCIALS);
+
+  fprintf(fl, "* If the nameserver is fast, set to 0, otherwise, 1.\n"
+              "nameserver_is_slow = %d\n\n",
+              CONFIG_NS_IS_SLOW);
+  
+  fprintf(fl, "* Should OLC autosave to disk (1) or save internally (0).\n"
+              "auto_save_olc = %d\n\n",
+              CONFIG_OLC_SAVE);
+
+  if (CONFIG_MENU) {
+    strcpy(buf, CONFIG_MENU);
+    strip_cr(buf);
+    
+    fprintf(fl, "* The entrance/exit menu.\n"
+                "MENU = \n%s~\n\n", buf);
+  }
+  
+  if (CONFIG_WELC_MESSG) {
+    strcpy(buf, CONFIG_WELC_MESSG);
+    strip_cr(buf);
+    
+    fprintf(fl, "* The welcome message.\nWELC_MESSG = \n%s~\n\n", buf);
+  }
+  
+  if (CONFIG_START_MESSG) {
+    strcpy(buf, CONFIG_START_MESSG);
+    strip_cr(buf);
+    
+    fprintf(fl, "* NEWBIE start message.\n"
+                "START_MESSG = \n%s~\n\n", buf);
+  }
+  
+  fprintf(fl, "\n\n\n* [ Autowiz Options ]\n");
+  
+  fprintf(fl, "* Should the game automatically create a new wizlist/immlist every time\n"
+              "* someone immorts, or is promoted to a higher (or lower) god level?\n"
+              "use_autowiz = %d\n\n",
+              CONFIG_USE_AUTOWIZ);
+  
+  fprintf(fl, "* If yes, what is the lowest level which should be on the wizlist?\n"
+              "min_wizlist_lev = %d\n\n",
+              CONFIG_MIN_WIZLIST_LEV);
+              
+  
+  fclose(fl);
+  
+  if (in_save_list(NOWHERE, SL_CFG))
+    remove_from_save_list(NOWHERE, SL_CFG);
+  
+  return (TRUE);
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+/*
+ * the main menu 
+ */
+void cedit_disp_menu(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  /*
+   * Menu header
+   */
+  write_to_output(d, 
+  	  "OasisOLC MUD Configuration Editor\r\n"
+  	  "%sG%s) Game Play Options\r\n"
+  	  "%sC%s) Crashsave/Rent Options\r\n"
+  	  "%sR%s) Room Numbers\r\n"
+          "%sO%s) Operation Options\r\n"
+          "%sA%s) Autowiz Options\r\n"
+          "%sQ%s) Quit\r\n"
+          "Enter your choice : ",
+          
+          grn, nrm,
+          grn, nrm,
+          grn, nrm,
+          grn, nrm,
+          grn, nrm,
+          grn, nrm
+          );
+
+  OLC_MODE(d) = CEDIT_MAIN_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void cedit_disp_game_play_options(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  
+  write_to_output(d, "\r\n\r\n"
+        "%sA%s) Player Killing Allowed  : %s%s\r\n"
+        "%sB%s) Player Thieving Allowed : %s%s\r\n"
+        "%sC%s) Minimum Level To Shout  : %s%d\r\n"
+        "%sD%s) Holler Move Cost        : %s%d\r\n"
+        "%sE%s) Tunnel Size             : %s%d\r\n"
+        "%sF%s) Maximum Experience Gain : %s%d\r\n"
+        "%sG%s) Maximum Experience Loss : %s%d\r\n"
+        "%sH%s) Max Time for NPC Corpse : %s%d\r\n"
+        "%sI%s) Max Time for PC Corpse  : %s%d\r\n"
+        "%sJ%s) Tics before PC sent to void : %s%d\r\n"
+        "%sK%s) Tics before PC is autosaved : %s%d\r\n"
+        "%sL%s) Level Immune To IDLE        : %s%d\r\n"
+        "%sM%s) Death Traps Junk Items      : %s%s\r\n"
+        "%sN%s) Objects Load Into Inventory : %s%s\r\n"
+        "%sO%s) Track Through Doors         : %s%s\r\n"
+        "%sP%s) Mortals Level To Immortal   : %s%s\r\n"
+        "%s1%s) OK Message Text         : %s%s"
+        "%s2%s) NOPERSON Message Text   : %s%s"
+        "%s3%s) NOEFFECT Message Text   : %s%s"
+        "%sQ%s) Exit To The Main Menu\r\n"
+        "Enter your choice : ",
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.pk_allowed),
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.pt_allowed),
+        grn, nrm, cyn, OLC_CONFIG(d)->play.level_can_shout,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.holler_move_cost,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.tunnel_size,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.max_exp_gain,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.max_exp_loss,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.max_npc_corpse_time,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.max_pc_corpse_time,
+
+        grn, nrm, cyn, OLC_CONFIG(d)->play.idle_void,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.idle_rent_time,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.idle_max_level,
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.dts_are_dumps),
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.load_into_inventory),
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.track_through_doors),
+        grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->play.immort_level_ok),
+        
+        grn, nrm, cyn, OLC_CONFIG(d)->play.OK,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.NOPERSON,
+        grn, nrm, cyn, OLC_CONFIG(d)->play.NOEFFECT,
+        
+        grn, nrm
+        );
+
+  OLC_MODE(d) = CEDIT_GAME_OPTIONS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void cedit_disp_crash_save_options(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  
+  write_to_output(d, "\r\n\r\n"
+  	"%sA%s) Free Rent          : %s%s\r\n"
+  	"%sB%s) Max Objects Saved  : %s%d\r\n"
+  	"%sC%s) Minimum Rent Cost  : %s%d\r\n"
+  	"%sD%s) Auto Save          : %s%s\r\n"
+  	"%sE%s) Auto Save Time     : %s%d minute(s)\r\n"
+  	"%sF%s) Crash File Timeout : %s%d day(s)\r\n"
+  	"%sG%s) Rent File Timeout  : %s%d day(s)\r\n"
+  	"%sQ%s) Exit To The Main Menu\r\n"
+  	"Enter your choice : ",
+  	grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->csd.free_rent),
+  	grn, nrm, cyn, OLC_CONFIG(d)->csd.max_obj_save,
+  	grn, nrm, cyn, OLC_CONFIG(d)->csd.min_rent_cost,
+  	grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->csd.auto_save),
+  	grn, nrm, cyn, OLC_CONFIG(d)->csd.autosave_time,
+  	grn, nrm, cyn, OLC_CONFIG(d)->csd.crash_file_timeout,
+  	grn, nrm, cyn, OLC_CONFIG(d)->csd.rent_file_timeout,
+  	grn, nrm
+  	);
+  
+  OLC_MODE(d) = CEDIT_CRASHSAVE_OPTIONS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void cedit_disp_room_numbers(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  
+  write_to_output(d, "\r\n\r\n"
+  	"%sA%s) Mortal Start Room   : %s%d\r\n"
+  	"%sB%s) Immortal Start Room : %s%d\r\n"
+  	"%sC%s) Frozen Start Room   : %s%d\r\n"
+  	"%s1%s) Donation Room #1    : %s%d\r\n"
+  	"%s2%s) Donation Room #2    : %s%d\r\n"
+  	"%s3%s) Donation Room #3    : %s%d\r\n"
+  	"%sQ%s) Exit To The Main Menu\r\n"
+  	"Enter your choice : ",
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.mortal_start_room,
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.immort_start_room,
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.frozen_start_room,
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.donation_room_1,
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.donation_room_2,
+  	grn, nrm, cyn, OLC_CONFIG(d)->room_nums.donation_room_3,
+  	grn, nrm
+  	);
+  
+  OLC_MODE(d) = CEDIT_ROOM_NUMBERS_MENU;
+}
+
+
+/*-------------------------------------------------------------------*/
+
+void cedit_disp_operation_options(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  
+  write_to_output(d, "\r\n\r\n"
+  	"%sA%s) Default Port : %s%d\r\n"
+  	"%sB%s) Default IP   : %s%s\r\n"
+  	"%sC%s) Default Directory   : %s%s\r\n"
+  	"%sD%s) Logfile Name        : %s%s\r\n"
+  	"%sE%s) Max Players         : %s%d\r\n"
+  	"%sF%s) Max Filesize        : %s%d\r\n"
+  	"%sG%s) Max Bad Pws         : %s%d\r\n"
+  	"%sH%s) Site Ok Everyone    : %s%s\r\n"
+  	"%sI%s) Name Server Is Slow : %s%s\r\n"
+        "%sJ%s) Use new socials file: %s%s\r\n"
+        "%sK%s) OLC autosave to disk: %s%s\r\n"
+  	"%sL%s) Main Menu           : \r\n%s%s\r\n"
+  	"%sM%s) Welcome Message     : \r\n%s%s\r\n"
+  	"%sN%s) Start Message       : \r\n%s%s\r\n"
+    "%sQ%s) Exit To The Main Menu\r\n"
+    "Enter your choice : ",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.DFLT_PORT,
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.DFLT_IP ? OLC_CONFIG(d)->operation.DFLT_IP : "<None>",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.DFLT_DIR ? OLC_CONFIG(d)->operation.DFLT_DIR : "<None>",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.LOGNAME ? OLC_CONFIG(d)->operation.LOGNAME : "<None>",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.max_playing,
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.max_filesize,
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.max_bad_pws,
+    grn, nrm, cyn, YESNO(OLC_CONFIG(d)->operation.siteok_everyone),
+    grn, nrm, cyn, YESNO(OLC_CONFIG(d)->operation.nameserver_is_slow),
+    grn, nrm, cyn, YESNO(OLC_CONFIG(d)->operation.use_new_socials),
+    grn, nrm, cyn, YESNO(OLC_CONFIG(d)->operation.auto_save_olc),
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.MENU ? OLC_CONFIG(d)->operation.MENU : "<None>",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.WELC_MESSG ? OLC_CONFIG(d)->operation.WELC_MESSG : "<None>",
+    grn, nrm, cyn, OLC_CONFIG(d)->operation.START_MESSG ? OLC_CONFIG(d)->operation.START_MESSG : "<None>",
+    grn, nrm
+    );
+  
+  OLC_MODE(d) = CEDIT_OPERATION_OPTIONS_MENU;
+}
+  	
+
+/*-------------------------------------------------------------------*/
+
+void cedit_disp_autowiz_options(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  
+  write_to_output(d, "\r\n\r\n"
+    "%sA%s) Use the autowiz        : %s%s\r\n"
+    "%sB%s) Minimum wizlist level  : %s%d\r\n"
+    "%sQ%s) Exit To The Main Menu\r\n"
+    "Enter your choice : ",
+    grn, nrm, cyn, CHECK_VAR(OLC_CONFIG(d)->autowiz.use_autowiz),
+    grn, nrm, cyn, OLC_CONFIG(d)->autowiz.min_wizlist_lev,
+    grn, nrm
+    );
+  
+  OLC_MODE(d) = CEDIT_AUTOWIZ_OPTIONS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+/**************************************************************************
+  The GARGANTAUN event handler
+ **************************************************************************/
+
+void cedit_parse(struct descriptor_data *d, char *arg)
+{
+  char *oldtext = NULL;
+  
+  switch (OLC_MODE(d)) {
+    case CEDIT_CONFIRM_SAVESTRING:
+      switch (*arg) {
+        case 'y':
+        case 'Y':
+          cedit_save_internally(d);
+          mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE, 
+                 "OLC: %s modifies the game configuration.", GET_NAME(d->character));
+          cleanup_olc(d, CLEANUP_CONFIG);
+	  if (CONFIG_AUTO_SAVE) {
+	    cedit_save_to_disk();
+	    write_to_output(d, "Game configuration saved to disk.\r\n");
+	  } else
+          write_to_output(d, "Game configuration saved to memory.\r\n");
+          return;
+        case 'n':
+        case 'N':
+          write_to_output(d, "Game configuration not saved to memory.\r\n");
+          cleanup_olc(d, CLEANUP_CONFIG);
+          return;
+        default :
+          write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+          write_to_output(d, "Do you wish to save the configuration? (y/n) : ");
+          return;
+      }
+      
+/*-------------------------------------------------------------------*/
+      
+    case CEDIT_MAIN_MENU:
+      switch (*arg) {
+        case 'g':
+        case 'G':
+          cedit_disp_game_play_options(d);
+          OLC_MODE(d) = CEDIT_GAME_OPTIONS_MENU;
+          break;
+          
+        case 'c':
+        case 'C':
+          cedit_disp_crash_save_options(d);
+          OLC_MODE(d) = CEDIT_CRASHSAVE_OPTIONS_MENU;
+          break;
+          
+        case 'r':
+        case 'R':
+          cedit_disp_room_numbers(d);
+          OLC_MODE(d) = CEDIT_ROOM_NUMBERS_MENU;
+          break;
+        
+        case 'o':
+        case 'O':
+          cedit_disp_operation_options(d);
+          OLC_MODE(d) = CEDIT_OPERATION_OPTIONS_MENU;
+          break;
+          
+        case 'a':
+        case 'A':
+          cedit_disp_autowiz_options(d);
+          OLC_MODE(d) = CEDIT_AUTOWIZ_OPTIONS_MENU;
+          break;
+        
+        case 'q':
+        case 'Q':
+          write_to_output(d, "Do you wish to save the configuration? (y/n) : ");
+          OLC_MODE(d) = CEDIT_CONFIRM_SAVESTRING;
+          break;
+          
+        default:
+          write_to_output(d, "That is an invalid choice!\r\n");
+          cedit_disp_menu(d);
+          break;
+      }
+      break;
+          
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_GAME_OPTIONS_MENU:
+      switch (*arg) {
+        case 'a':
+        case 'A':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.pk_allowed);
+          break;
+          
+        case 'b':
+        case 'B':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.pt_allowed);
+          break;
+          
+        case 'c':
+        case 'C':
+          write_to_output(d, "Enter the minimum level a player must be to shout, gossip, etc : ");
+          OLC_MODE(d) = CEDIT_LEVEL_CAN_SHOUT;
+          return;
+          
+        case 'd':
+        case 'D':
+          write_to_output(d, "Enter the amount it costs (in move points) to holler : ");
+          OLC_MODE(d) = CEDIT_HOLLER_MOVE_COST;
+          return;
+        
+        case 'e':
+        case 'E':
+          write_to_output(d, "Enter the maximum number of people allowed in a tunnel : ");
+          OLC_MODE(d) = CEDIT_TUNNEL_SIZE;
+          return;
+        
+        case 'f':
+        case 'F':
+          write_to_output(d, "Enter the maximum gain of experience per kill for players : ");
+          OLC_MODE(d) = CEDIT_MAX_EXP_GAIN;
+          return;
+          
+        case 'g':
+        case 'G':
+          write_to_output(d, "Enter the maximum loss of experience per death for players : ");
+          OLC_MODE(d) = CEDIT_MAX_EXP_LOSS;
+          return;
+        
+        case 'h':
+        case 'H':
+          write_to_output(d, "Enter the number of tics before NPC corpses decompose : ");
+          OLC_MODE(d) = CEDIT_MAX_NPC_CORPSE_TIME;
+          return;
+        
+        case 'i':
+        case 'I':
+          write_to_output(d, "Enter the number of tics before PC corpses decompose : ");
+          OLC_MODE(d) = CEDIT_MAX_PC_CORPSE_TIME;
+          return;
+        
+        case 'j':
+        case 'J':
+          write_to_output(d, "Enter the number of tics before PC's are sent to the void (idle) : ");
+          OLC_MODE(d) = CEDIT_IDLE_VOID;
+          return;
+        
+        case 'k':
+        case 'K':
+          write_to_output(d, "Enter the number of tics before PC's are automatically rented and forced to quit : ");
+          OLC_MODE(d) = CEDIT_IDLE_RENT_TIME;
+          return;
+        
+        case 'l':
+        case 'L':
+          write_to_output(d, "Enter the level a player must be to become immune to IDLE : ");
+          OLC_MODE(d) = CEDIT_IDLE_MAX_LEVEL;
+          return;
+        
+        case 'm':
+        case 'M':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.dts_are_dumps);
+          break;
+        
+        case 'n':
+        case 'N':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.load_into_inventory);
+          break;
+        
+        case 'o':
+        case 'O':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.track_through_doors);
+          break;
+        
+        case 'p':
+        case 'P':
+          TOGGLE_VAR(OLC_CONFIG(d)->play.immort_level_ok);
+          break;
+        
+        case '1':
+          write_to_output(d, "Enter the OK message : ");
+          OLC_MODE(d) = CEDIT_OK;
+          return;
+        
+        case '2':
+          write_to_output(d, "Enter the NOPERSON message : ");
+          OLC_MODE(d) = CEDIT_NOPERSON;
+          return;
+        
+        case '3':
+          write_to_output(d, "Enter the NOEFFECT message : ");
+          OLC_MODE(d) = CEDIT_NOEFFECT;
+          return;
+        
+        case 'q':
+        case 'Q':
+          cedit_disp_menu(d);
+          return;
+          
+        default:
+          write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+          cedit_disp_game_play_options(d);
+      }
+      
+      cedit_disp_game_play_options(d);
+      return;
+ 
+ /*-------------------------------------------------------------------*/
+    
+    case CEDIT_CRASHSAVE_OPTIONS_MENU:
+      switch (*arg) {
+        case 'a':
+        case 'A':
+          TOGGLE_VAR(OLC_CONFIG(d)->csd.free_rent);
+          break;
+        
+        case 'b':
+        case 'B':
+          write_to_output(d, "Enter the maximum number of items players can rent : ");
+          OLC_MODE(d) = CEDIT_MAX_OBJ_SAVE;
+          return;
+        
+        case 'c':
+        case 'C':
+          write_to_output(d, "Enter the surcharge on top of item costs : ");
+          OLC_MODE(d) = CEDIT_MIN_RENT_COST;
+          return;
+        
+        case 'd':
+        case 'D':
+          TOGGLE_VAR(OLC_CONFIG(d)->csd.auto_save);
+          break;
+        
+        case 'e':
+        case 'E':
+          write_to_output(d, "Enter how often (in minutes) should the MUD save players : ");
+          OLC_MODE(d) = CEDIT_AUTOSAVE_TIME;
+          return;
+        
+        case 'f':
+        case 'F':
+          write_to_output(d, "Enter the lifetime of crash and idlesave files (days) : ");
+          OLC_MODE(d) = CEDIT_CRASH_FILE_TIMEOUT;
+          return;
+        
+        case 'g':
+        case 'G':
+          write_to_output(d, "Enter the lifetime of normal rent files (days) : ");
+          OLC_MODE(d) = CEDIT_RENT_FILE_TIMEOUT;
+          return;
+        
+        case 'q':
+        case 'Q':
+          cedit_disp_menu(d);
+          return;
+        
+        default:
+          write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+        }
+        
+        cedit_disp_crash_save_options(d);
+        return;
+ 
+ /*-------------------------------------------------------------------*/
+ 
+    case CEDIT_ROOM_NUMBERS_MENU:
+      switch (*arg) {
+        case 'a':
+        case 'A':
+          write_to_output(d, "Enter the room's vnum where mortals should load into : ");
+          OLC_MODE(d) = CEDIT_MORTAL_START_ROOM;
+          return;
+       
+        case 'b':
+        case 'B':
+          write_to_output(d, "Enter the room's vnum where immortals should load into : ");
+          OLC_MODE(d) = CEDIT_IMMORT_START_ROOM;
+          return;
+       
+        case 'c':
+        case 'C':
+        write_to_output(d, "Enter the room's vnum where frozen people should load into : ");
+        OLC_MODE(d) = CEDIT_FROZEN_START_ROOM;
+        return;
+        
+      case '1':
+        write_to_output(d, "Enter the vnum for donation room #1 : ");
+        OLC_MODE(d) = CEDIT_DONATION_ROOM_1;
+        return;
+        
+      case '2':
+        write_to_output(d, "Enter the vnum for donation room #2 : ");
+        OLC_MODE(d) = CEDIT_DONATION_ROOM_2;
+        return;
+        
+      case '3':
+        write_to_output(d, "Enter the vnum for donation room #3 : ");
+        OLC_MODE(d) = CEDIT_DONATION_ROOM_3;
+        return;
+        
+      case 'q':
+      case 'Q':
+        cedit_disp_menu(d);
+        return;
+        
+      default:
+        write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+    }
+   
+    cedit_disp_room_numbers(d);
+    return;
+   
+ /*-------------------------------------------------------------------*/
+ 
+     case CEDIT_OPERATION_OPTIONS_MENU:
+       switch (*arg) {
+         case 'a':
+         case 'A':
+           write_to_output(d, "Enter the default port number : ");
+           OLC_MODE(d) = CEDIT_DFLT_PORT;
+           return;
+           
+         case 'b':
+         case 'B':
+           write_to_output(d, "Enter the default IP Address : ");
+           OLC_MODE(d) = CEDIT_DFLT_IP;
+           return;
+         
+         case 'c':
+         case 'C':
+           write_to_output(d, "Enter the default directory : ");
+           OLC_MODE(d) = CEDIT_DFLT_DIR;
+           return;
+         
+         case 'd':
+         case 'D':
+           write_to_output(d, "Enter the name of the logfile : ");
+           OLC_MODE(d) = CEDIT_LOGNAME;
+           return;
+         
+         case 'e':
+         case 'E':
+           write_to_output(d, "Enter the maximum number of players : ");
+           OLC_MODE(d) = CEDIT_MAX_PLAYING;
+           return;
+         
+         case 'f':
+         case 'F':
+           write_to_output(d, "Enter the maximum size of the logs : ");
+           OLC_MODE(d) = CEDIT_MAX_FILESIZE;
+           return;
+         
+         case 'g':
+         case 'G':
+           write_to_output(d, "Enter the maximum number of password attempts : ");
+           OLC_MODE(d) = CEDIT_MAX_BAD_PWS;
+           return;
+         
+         case 'h':
+         case 'H':
+           TOGGLE_VAR(OLC_CONFIG(d)->operation.siteok_everyone);
+           break;
+       
+         case 'i':
+         case 'I':
+           TOGGLE_VAR(OLC_CONFIG(d)->operation.nameserver_is_slow);
+           break;
+         
+         case 'j':
+         case 'J':
+           TOGGLE_VAR(OLC_CONFIG(d)->operation.use_new_socials);
+           send_to_char(d->character, 
+              "Please note that using the stock social file will disable AEDIT.\r\n");
+           break;
+
+         case 'k':
+         case 'K':
+           TOGGLE_VAR(OLC_CONFIG(d)->operation.auto_save_olc);
+           break;
+
+         case 'l':
+         case 'L':
+           OLC_MODE(d) = CEDIT_MENU;
+           clear_screen(d);
+           send_editor_help(d);
+           write_to_output(d, "Enter the new MENU :\r\n\r\n");
+           
+           if (OLC_CONFIG(d)->operation.MENU) {
+             write_to_output(d, "%s", OLC_CONFIG(d)->operation.MENU);
+             oldtext = strdup(OLC_CONFIG(d)->operation.MENU);
+           }
+           
+           string_write(d, &OLC_CONFIG(d)->operation.MENU, MAX_INPUT_LENGTH, 0, oldtext);
+           return;
+         
+         case 'm':
+         case 'M':
+           OLC_MODE(d) = CEDIT_WELC_MESSG;
+           clear_screen(d);
+           send_editor_help(d);
+           write_to_output(d, "Enter the new welcome message :\r\n\r\n");
+           
+           if (OLC_CONFIG(d)->operation.WELC_MESSG) {
+             write_to_output(d, "%s", OLC_CONFIG(d)->operation.WELC_MESSG);
+             oldtext = str_udup(OLC_CONFIG(d)->operation.WELC_MESSG);
+           }
+           
+           string_write(d, &OLC_CONFIG(d)->operation.WELC_MESSG, MAX_INPUT_LENGTH, 0, oldtext);
+           return;
+         
+         case 'n':
+         case 'N':
+           OLC_MODE(d) = CEDIT_START_MESSG;
+           clear_screen(d);
+           send_editor_help(d);
+           write_to_output(d, "Enter the new newbie start message :\r\n\r\n");
+           
+           if (OLC_CONFIG(d)->operation.START_MESSG) {
+             write_to_output(d, "%s", OLC_CONFIG(d)->operation.START_MESSG);
+             oldtext = strdup(OLC_CONFIG(d)->operation.START_MESSG);
+           }
+           
+           string_write(d, &OLC_CONFIG(d)->operation.START_MESSG, MAX_INPUT_LENGTH, 0, oldtext);
+           return;
+         
+         case 'q':
+         case 'Q':
+           cedit_disp_menu(d);
+           return;
+         
+         default:
+           write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+      }
+   
+   cedit_disp_operation_options(d);
+   return;
+   
+ /*-------------------------------------------------------------------*/
+ 
+    case CEDIT_AUTOWIZ_OPTIONS_MENU:
+      switch (*arg) {
+        case 'a':
+        case 'A':
+          TOGGLE_VAR(OLC_CONFIG(d)->autowiz.use_autowiz);
+          break;
+        
+        case 'b':
+        case 'B':
+          write_to_output(d, "Enter the minimum level for players to appear on the wizlist : ");
+          OLC_MODE(d) = CEDIT_MIN_WIZLIST_LEV;
+          return;
+        
+        case 'q':
+        case 'Q':
+          cedit_disp_menu(d);
+          return;
+        
+        default:
+          write_to_output(d, "\r\nThat is an invalid choice!\r\n");
+      }
+      
+      cedit_disp_autowiz_options(d);
+      return;
+    
+ /*-------------------------------------------------------------------*/
+
+    case CEDIT_LEVEL_CAN_SHOUT:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the minimum level a player must be to shout, gossip, etc : ");
+      } else {
+        OLC_CONFIG(d)->play.level_can_shout = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_HOLLER_MOVE_COST:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the amount it costs (in move points) to holler : ");
+      } else {
+        OLC_CONFIG(d)->play.holler_move_cost = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_TUNNEL_SIZE:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the maximum number of people allowed in a tunnel : ");
+      } else {
+        OLC_CONFIG(d)->play.tunnel_size = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_EXP_GAIN:
+      if (*arg)
+        OLC_CONFIG(d)->play.max_exp_gain = atoi(arg);
+      
+      cedit_disp_game_play_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_EXP_LOSS:
+      if (*arg)
+        OLC_CONFIG(d)->play.max_exp_loss = atoi(arg);
+      
+      cedit_disp_game_play_options(d);
+      break;
+
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_NPC_CORPSE_TIME:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the number of tics before NPC corpses decompose : ");
+      } else {
+        OLC_CONFIG(d)->play.max_npc_corpse_time = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_PC_CORPSE_TIME:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the number of tics before PC corpses decompose : ");
+        } else {
+          OLC_CONFIG(d)->play.max_pc_corpse_time = atoi(arg);
+          cedit_disp_game_play_options(d);
+        }
+        break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_IDLE_VOID:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the number of tics before PC's are sent to the void (idle) : ");
+      } else {
+        OLC_CONFIG(d)->play.idle_void = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_IDLE_RENT_TIME:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the number of tics before PC's are automatically rented and forced to quit : ");
+      } else {
+        OLC_CONFIG(d)->play.idle_rent_time = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_IDLE_MAX_LEVEL:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the level a player must be to become immune to IDLE : ");
+      } else {
+        OLC_CONFIG(d)->play.idle_max_level = atoi(arg);
+        cedit_disp_game_play_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_OK:
+      if (!genolc_checkstring(d, arg))
+        break;
+          
+      if (OLC_CONFIG(d)->play.OK)
+        free(OLC_CONFIG(d)->play.OK);
+          
+      OLC_CONFIG(d)->play.OK = str_udup(arg);
+      strcat(OLC_CONFIG(d)->play.OK, "\r\n");
+      
+      cedit_disp_game_play_options(d);
+      break;
+      
+/*-------------------------------------------------------------------*/
+        
+    case CEDIT_NOPERSON:
+      if (!genolc_checkstring(d, arg))
+        break;
+          
+      if (OLC_CONFIG(d)->play.NOPERSON)
+        free(OLC_CONFIG(d)->play.NOPERSON);
+          
+      OLC_CONFIG(d)->play.NOPERSON = str_udup(arg);
+      strcat(OLC_CONFIG(d)->play.NOPERSON, "\r\n");
+      
+      cedit_disp_game_play_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_NOEFFECT:
+      if (!genolc_checkstring(d, arg))
+        break;
+          
+      if (OLC_CONFIG(d)->play.NOEFFECT)
+        free(OLC_CONFIG(d)->play.NOEFFECT);
+          
+      OLC_CONFIG(d)->play.NOEFFECT = str_udup(arg);
+      strcat(OLC_CONFIG(d)->play.NOEFFECT, "\r\n");
+      
+      cedit_disp_game_play_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_OBJ_SAVE:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the maximum objects a player can save : ");
+        } else {
+          OLC_CONFIG(d)->csd.max_obj_save = atoi(arg);
+          cedit_disp_crash_save_options(d);
+        }
+        break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_MIN_RENT_COST:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the minimum amount it costs to rent : ");
+      } else {
+        OLC_CONFIG(d)->csd.min_rent_cost = atoi(arg);
+        cedit_disp_crash_save_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_AUTOSAVE_TIME:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the interval for player's being autosaved : ");
+      } else {
+        OLC_CONFIG(d)->csd.autosave_time = atoi(arg);
+        cedit_disp_crash_save_options(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_CRASH_FILE_TIMEOUT:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the lifetime of crash and idlesave files (days) : ");
+      } else {
+        OLC_CONFIG(d)->csd.crash_file_timeout = atoi(arg);
+        cedit_disp_crash_save_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_RENT_FILE_TIMEOUT:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the lifetime of rent files (days) : ");
+      } else {
+        OLC_CONFIG(d)->csd.rent_file_timeout = atoi(arg);
+        cedit_disp_crash_save_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_MORTAL_START_ROOM:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the room's vnum where mortals should load into : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the room's vnum where mortals should load into : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.mortal_start_room = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+    
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_IMMORT_START_ROOM:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the room's vnum where immortals should load into : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the room's vnum where immortals should load into : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.immort_start_room = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_FROZEN_START_ROOM:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the room's vnum where frozen people should load into : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the room's vnum where frozen people should load into : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.frozen_start_room = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_DONATION_ROOM_1:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the vnum for donation room #1 : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the vnum for donation room #1 : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.donation_room_1 = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_DONATION_ROOM_2:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the vnum for donation room #2 : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the vnum for donation room #2 : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.donation_room_2 = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_DONATION_ROOM_3:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the vnum for donation room #3 : ");
+      } else if (real_room(atoi(arg)) == NOWHERE) {
+        write_to_output(d,
+          "That room doesn't exist!\r\n"
+          "Enter the vnum for donation room #3 : ");
+      } else {
+        OLC_CONFIG(d)->room_nums.donation_room_3 = atoi(arg);
+        cedit_disp_room_numbers(d);
+      }
+      break;
+      
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_DFLT_PORT:
+      OLC_CONFIG(d)->operation.DFLT_PORT = atoi(arg);
+      cedit_disp_operation_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_DFLT_IP:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the default ip address : ");
+      } else {
+        OLC_CONFIG(d)->operation.DFLT_IP = str_udup(arg);
+        cedit_disp_operation_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+    
+    case CEDIT_DFLT_DIR:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the default directory : ");
+      } else {
+        OLC_CONFIG(d)->operation.DFLT_DIR = str_udup(arg);
+        cedit_disp_operation_options(d);
+      }
+      break;
+    
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_LOGNAME:
+      if (!*arg) {
+        write_to_output(d,
+          "That is an invalid choice!\r\n"
+          "Enter the name of the logfile : ");
+      } else {
+        OLC_CONFIG(d)->operation.LOGNAME = str_udup(arg);
+        cedit_disp_operation_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_PLAYING:
+      OLC_CONFIG(d)->operation.max_playing = atoi(arg);
+      cedit_disp_operation_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_FILESIZE:
+      OLC_CONFIG(d)->operation.max_filesize = atoi(arg);
+      cedit_disp_operation_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MAX_BAD_PWS:
+      OLC_CONFIG(d)->operation.max_bad_pws = atoi(arg);
+      cedit_disp_operation_options(d);
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    case CEDIT_MIN_WIZLIST_LEV:
+      if (atoi(arg) > LVL_IMPL) {
+        write_to_output(d, 
+          "The minimum wizlist level can't be greater than %d.\r\n"
+          "Enter the minimum level for players to appear on the wizlist : ", LVL_IMPL);
+      } else {
+        OLC_CONFIG(d)->autowiz.min_wizlist_lev = atoi(arg);
+        cedit_disp_autowiz_options(d);
+      }
+      break;
+
+/*-------------------------------------------------------------------*/
+
+    default:
+      /*
+       * We should never get here, but just in case...
+       */
+      cleanup_olc(d, CLEANUP_CONFIG);
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: cedit_parse(): Reached default case!");
+      write_to_output(d, "Oops...\r\n");
+      break;
+  }
+}
+
+/*
+ * End of parse_cedit()  
+ */
+void reassign_rooms(void)
+{ 
+  void assign_rooms(void);
+  int i;
+
+  /* remove old funcs */
+  for (i = 0; i < top_of_world; i++)
+    world[i].func = NULL;
+        
+  /* reassign spec_procs */
+  assign_rooms();
+}
+
+void cedit_string_cleanup(struct descriptor_data *d, int terminator)
+{
+  switch (OLC_MODE(d)) {
+  case CEDIT_MENU:
+  case CEDIT_WELC_MESSG:
+  case CEDIT_START_MESSG:
+    cedit_disp_operation_options(d);
+    break;
+  }
+}
diff -BENbdpru circle-3.1/src/class.c circle3.1_oasis206/src/class.c
--- circle-3.1/src/class.c	2002-04-30 23:00:34.000000000 +0200
+++ circle3.1_oasis206/src/class.c	2003-10-06 22:18:06.000000000 +0200
@@ -27,8 +27,6 @@
 #include "interpreter.h"
 #include "constants.h"
 
-extern int siteok_everyone;
-
 /* local functions */
 void snoop_check(struct char_data *ch);
 int parse_class(char arg);
@@ -1506,8 +1504,11 @@ void do_start(struct char_data *ch)
   GET_COND(ch, FULL) = 24;
   GET_COND(ch, DRUNK) = 0;
 
-  if (siteok_everyone)
+  if (CONFIG_SITEOK_ALL)
     SET_BIT(PLR_FLAGS(ch), PLR_SITEOK);
+
+
+  ch->player_specials->saved.olc_zone = NOWHERE;
 }
 
 
diff -BENbdpru circle-3.1/src/comm.c circle3.1_oasis206/src/comm.c
--- circle-3.1/src/comm.c	2002-11-13 21:02:18.000000000 +0100
+++ circle3.1_oasis206/src/comm.c	2003-10-07 11:28:30.000000000 +0200
@@ -59,6 +59,8 @@
 #include "handler.h"
 #include "db.h"
 #include "house.h"
+#include "oasis.h"
+#include "genolc.h"
 
 #ifdef HAVE_ARPA_TELNET_H
 #include <arpa/telnet.h>
@@ -75,18 +77,11 @@ extern struct ban_list_element *ban_list
 extern int num_invalid;
 extern char *GREETINGS;
 extern const char *circlemud_version;
+extern const char *oasisolc_version;
 extern int circle_restrict;
 extern int mini_mud;
 extern int no_rent_check;
 extern FILE *player_fl;
-extern ush_int DFLT_PORT;
-extern const char *DFLT_DIR;
-extern const char *DFLT_IP;
-extern const char *LOGNAME;
-extern int max_playing;
-extern int nameserver_is_slow;	/* see config.c */
-extern int auto_save;		/* see config.c */
-extern int autosave_time;	/* see config.c */
 extern int *cmd_sort_info;
 
 extern struct time_info_data time_info;		/* In db.c */
@@ -108,7 +103,6 @@ struct timeval null_time;	/* zero-valued
 byte reread_wizlist;		/* signal: SIGUSR1 */
 byte emergency_unban;		/* signal: SIGUSR2 */
 FILE *logfile = NULL;		/* Where to send the log messages. */
-const char *text_overflow = "**OVERFLOW**\r\n";
 
 /* functions in this file */
 RETSIGTYPE reread_wizlists(int sig);
@@ -142,6 +136,7 @@ void heartbeat(int pulse);
 struct in_addr *get_bind_addr(void);
 int parse_ip(const char *addr, struct in_addr *inaddr);
 int set_sendbuf(socket_t s);
+void free_bufpool(void);
 void setup_log(const char *filename, int fd);
 int open_logfile(const char *filename, FILE *stderr_fp);
 #if defined(POSIX)
@@ -162,7 +157,9 @@ void clear_free_list(void);
 void free_messages(void);
 void Board_clear_all(void);
 void free_social_messages(void);
+void free_mail_index(void);
 void Free_Invalid_List(void);
+void load_config(void);
 
 #ifdef __CXREF__
 #undef FD_ZERO
@@ -223,16 +220,47 @@ int main(int argc, char **argv)
   GUSIDefaultSetup();
 #endif
 
-  port = DFLT_PORT;
-  dir = DFLT_DIR;
+  /****************************************************************************/
+  /** Load the game configuration.                                           **/
+  /** We must load BEFORE we use any of the constants stored in constants.c. **/
+  /** Otherwise, there will be no variables set to set the rest of the vars  **/
+  /** to, which will mean trouble --> Mythran                                **/
+  /****************************************************************************/
+  CONFIG_CONFFILE = NULL;
+  while ((pos < argc) && (*(argv[pos]) == '-')) {
+    if (*(argv[pos] + 1) == 'f') {
+      if (*(argv[pos] + 2))
+	CONFIG_CONFFILE = argv[pos] + 2;
+      else if (++pos < argc)
+	CONFIG_CONFFILE = argv[pos];
+      else {
+	puts("SYSERR: File name to read from expected after option -f.");
+	exit(1);
+      }
+    }
+    pos++;
+  }
+  pos = 1;
+
+  if (!CONFIG_CONFFILE)
+    CONFIG_CONFFILE = strdup(CONFIG_FILE);
+
+  load_config();
+  
+  port = CONFIG_DFLT_PORT;
+  dir = CONFIG_DFLT_DIR;
 
   while ((pos < argc) && (*(argv[pos]) == '-')) {
     switch (*(argv[pos] + 1)) {
+    case 'f':
+      if (! *(argv[pos] + 2))
+	++pos;
+      break;
     case 'o':
       if (*(argv[pos] + 2))
-	LOGNAME = argv[pos] + 2;
+	CONFIG_LOGNAME = argv[pos] + 2;
       else if (++pos < argc)
-	LOGNAME = argv[pos];
+	CONFIG_LOGNAME = argv[pos];
       else {
 	puts("SYSERR: File name to log to expected after option -o.");
 	exit(1);
@@ -276,10 +304,12 @@ int main(int argc, char **argv)
               "  -d <directory> Specify library directory (defaults to 'lib').\n"
               "  -h             Print this command line argument help.\n"
               "  -m             Start in mini-MUD mode.\n"
+	      "  -f<file>       Use <file> for configuration.\n"
 	      "  -o <file>      Write log to <file> instead of stderr.\n"
               "  -q             Quick boot (doesn't scan rent for object limits)\n"
               "  -r             Restrict MUD -- no new players allowed.\n"
-              "  -s             Suppress special procedure assignments.\n",
+              "  -s             Suppress special procedure assignments.\n"
+              " Note:		These arguments are 'CaSe SeNsItIvE!!!'\n",
 		 argv[0]
       );
       exit(0);
@@ -301,13 +331,15 @@ int main(int argc, char **argv)
   }
 
   /* All arguments have been parsed, try to open log file. */
-  setup_log(LOGNAME, STDERR_FILENO);
+  setup_log(CONFIG_LOGNAME, STDERR_FILENO);
 
   /*
    * Moved here to distinguish command line options and to show up
    * in the log if stderr is redirected to a file.
    */
+  log("Using %s for configuration.", CONFIG_CONFFILE);
   log("%s", circlemud_version);
+  log("%s", oasisolc_version);
 
   if (chdir(dir) < 0) {
     perror("SYSERR: Fatal error changing to data directory");
@@ -327,15 +359,18 @@ int main(int argc, char **argv)
 
   if (!scheck) {
     log("Clearing other memory.");
+    free_bufpool();             /* comm.c */
     free_player_index();	/* db.c */
     free_messages();		/* fight.c */
     clear_free_list();		/* mail.c */
+    free_mail_index();          /* mail.c */
     free_text_files();		/* db.c */
     Board_clear_all();		/* boards.c */
     free(cmd_sort_info);	/* act.informative.c */
     free_social_messages();	/* act.social.c */
     free_help();		/* db.c */
     Free_Invalid_List();	/* ban.c */
+    free_strings(&config_info, OASIS_CFG); /* oasis_delete.c */
   }
 
   log("Done.");
@@ -383,6 +418,9 @@ void init_game(ush_int port)
   CLOSE_SOCKET(mother_desc);
   fclose(player_fl);
 
+  if (circle_reboot != 2)
+    save_all();
+
   log("Saving current MUD time.");
   save_mud_time(&time_info);
 
@@ -498,7 +536,7 @@ socket_t init_socket(ush_int port)
 int get_max_players(void)
 {
 #ifndef CIRCLE_UNIX
-  return (max_playing);
+  return (CONFIG_MAX_PLAYING);
 #else
 
   int max_descs = 0;
@@ -527,11 +565,11 @@ int get_max_players(void)
     }
 #ifdef RLIM_INFINITY
     if (limit.rlim_max == RLIM_INFINITY)
-      max_descs = max_playing + NUM_RESERVED_DESCS;
+      max_descs = CONFIG_MAX_PLAYING + NUM_RESERVED_DESCS;
     else
-      max_descs = MIN(max_playing + NUM_RESERVED_DESCS, limit.rlim_max);
+      max_descs = MIN(CONFIG_MAX_PLAYING + NUM_RESERVED_DESCS, limit.rlim_max);
 #else
-    max_descs = MIN(max_playing + NUM_RESERVED_DESCS, limit.rlim_max);
+    max_descs = MIN(CONFIG_MAX_PLAYING + NUM_RESERVED_DESCS, limit.rlim_max);
 #endif
   }
 
@@ -552,7 +590,7 @@ int get_max_players(void)
   errno = 0;
   if ((max_descs = sysconf(_SC_OPEN_MAX)) < 0) {
     if (errno == 0)
-      max_descs = max_playing + NUM_RESERVED_DESCS;
+      max_descs = CONFIG_MAX_PLAYING + NUM_RESERVED_DESCS;
     else {
       perror("SYSERR: Error calling sysconf");
       exit(1);
@@ -561,11 +599,11 @@ int get_max_players(void)
 #else
   /* if everything has failed, we'll just take a guess */
   method = "random guess";
-  max_descs = max_playing + NUM_RESERVED_DESCS;
+  max_descs = CONFIG_MAX_PLAYING + NUM_RESERVED_DESCS;
 #endif
 
   /* now calculate max _players_ based on max descs */
-  max_descs = MIN(max_playing, max_descs - NUM_RESERVED_DESCS);
+  max_descs = MIN(CONFIG_MAX_PLAYING, max_descs - NUM_RESERVED_DESCS);
 
   if (max_descs <= 0) {
     log("SYSERR: Non-positive max player limit!  (Set at %d using %s).",
@@ -737,10 +775,10 @@ void game_loop(socket_t mother_desc)
       }
       d->has_prompt = FALSE;
 
-      if (d->str)		/* Writing boards, mail, etc. */
-	string_add(d, comm);
-      else if (d->showstr_count) /* Reading something w/ pager */
+      if (d->showstr_count) /* Reading something w/ pager */
 	show_string(d, comm);
+      else if (d->str)		/* Writing boards, mail, etc. */
+	string_add(d, comm);
       else if (STATE(d) != CON_PLAYING) /* In menus, etc. */
 	nanny(d, comm);
       else {			/* else: we're playing normally. */
@@ -756,17 +794,17 @@ void game_loop(socket_t mother_desc)
     for (d = descriptor_list; d; d = next_d) {
       next_d = d->next;
       if (*(d->output) && FD_ISSET(d->descriptor, &output_set)) {
-	/* Output for this player is ready. */
-
-        process_output(d);
-        if (d->bufptr == 0)	/* All output sent. */
-          d->has_prompt = TRUE;
+	/* Output for this player is ready */
+	if (process_output(d) < 0)
+	  close_socket(d);
+	else
+	  d->has_prompt = 1;
       }
     }
 
     /* Print prompts for other descriptors who had no other output */
     for (d = descriptor_list; d; d = d->next) {
-      if (!d->has_prompt && d->bufptr == 0) {
+      if (!d->has_prompt) {
 	write_to_descriptor(d->descriptor, make_prompt(d));
 	d->has_prompt = TRUE;
       }
@@ -850,8 +888,8 @@ void heartbeat(int pulse)
     fflush(player_fl);
   }
 
-  if (auto_save && !(pulse % PULSE_AUTOSAVE)) {	/* 1 minute */
-    if (++mins_since_crashsave >= autosave_time) {
+  if (CONFIG_AUTO_SAVE && !(pulse % PULSE_AUTOSAVE)) {	/* 1 minute */
+    if (++mins_since_crashsave >= CONFIG_AUTOSAVE_TIME) {
       mins_since_crashsave = 0;
       Crash_save_all();
       House_save_all();
@@ -928,7 +966,7 @@ void record_usage(void)
 
   for (d = descriptor_list; d; d = d->next) {
     sockets_connected++;
-    if (STATE(d) == CON_PLAYING)
+    if (IS_PLAYING(d))
       sockets_playing++;
   }
 
@@ -989,13 +1027,13 @@ char *make_prompt(struct descriptor_data
 
   /* Note, prompt is truncated at MAX_PROMPT_LENGTH chars (structs.h) */
 
-  if (d->str)
-    strcpy(prompt, "] ");	/* strcpy: OK (for 'MAX_PROMPT_LENGTH >= 3') */
-  else if (d->showstr_count) {
+  if (d->showstr_count)
     snprintf(prompt, sizeof(prompt),
 	    "\r\n[ Return to continue, (q)uit, (r)efresh, (b)ack, or page number (%d/%d) ]",
 	    d->showstr_page, d->showstr_count);
-  } else if (STATE(d) == CON_PLAYING && !IS_NPC(d->character)) {
+  else if (d->str)
+    strcpy(prompt, "] ");	/* strcpy: OK (for 'MAX_PROMPT_LENGTH >= 3') */
+  else if (STATE(d) == CON_PLAYING && !IS_NPC(d->character)) {
     int count;
     size_t len = 0;
 
@@ -1006,7 +1044,25 @@ char *make_prompt(struct descriptor_data
       if (count >= 0)
         len += count;
     }
-
+    /* show only when below 25% */
+    if (PRF_FLAGGED(d->character, PRF_DISPAUTO) && len < sizeof(prompt)) {
+      struct char_data *ch = d->character;
+      if (GET_HIT(ch) << 2 < GET_MAX_HIT(ch) ) {
+        count = snprintf(prompt + len, sizeof(prompt) - len, "%dH ", GET_HIT(ch));
+        if (count >= 0)
+          len += count;
+      }
+      if (GET_MANA(ch) << 2 < GET_MAX_MANA(ch) && len < sizeof(prompt)) {
+        count = snprintf(prompt + len, sizeof(prompt) - len, "%dM ", GET_MANA(ch));
+        if (count >= 0)
+          len += count;
+      }
+      if (GET_MOVE(ch) << 2 < GET_MAX_MOVE(ch) && len < sizeof(prompt)) {
+        count = snprintf(prompt + len, sizeof(prompt) - len, "%dV ", GET_MOVE(ch));
+        if (count >= 0)
+          len += count;
+      }
+    } else { /* not auto prompt */
     if (PRF_FLAGGED(d->character, PRF_DISPHP) && len < sizeof(prompt)) {
       count = snprintf(prompt + len, sizeof(prompt) - len, "%dH ", GET_HIT(d->character));
       if (count >= 0)
@@ -1024,6 +1080,13 @@ char *make_prompt(struct descriptor_data
       if (count >= 0)
         len += count;
     }
+    }
+
+    if (PRF_FLAGGED(d->character, PRF_BUILDWALK) && len < sizeof(prompt)) {
+      count = snprintf(prompt + len, sizeof(prompt) - len, "BUILDWALKING ");
+      if (count >= 0)
+        len += count;
+    }
 
     if (len < sizeof(prompt))
       strncat(prompt, "> ", sizeof(prompt) - len - 1);	/* strncat: OK */
@@ -1115,6 +1178,7 @@ size_t write_to_output(struct descriptor
 /* Add a new string to a player's output queue. */
 size_t vwrite_to_output(struct descriptor_data *t, const char *format, va_list args)
 {
+  const char *text_overflow = "\r\nOVERFLOW\r\n";
   static char txt[MAX_STRING_LENGTH];
   size_t wantsize;
   int size;
@@ -1177,6 +1241,18 @@ size_t vwrite_to_output(struct descripto
   return (t->bufspace);
 }
 
+void free_bufpool(void)
+{
+  struct txt_block *tmp;
+ 
+  while (bufpool) {
+    tmp = bufpool->next;
+    if (bufpool->text)
+      free(bufpool->text);
+    free(bufpool);
+    bufpool = tmp;
+  }
+}
 
 
 /* ******************************************************************
@@ -1200,12 +1276,13 @@ struct in_addr *get_bind_addr()
   memset((char *) &bind_addr, 0, sizeof(bind_addr));
 
   /* If DLFT_IP is unspecified, use INADDR_ANY */
-  if (DFLT_IP == NULL) {
+  if (CONFIG_DFLT_IP == NULL) {
     bind_addr.s_addr = htonl(INADDR_ANY);
   } else {
     /* If the parsing fails, use INADDR_ANY */
-    if (!parse_ip(DFLT_IP, &bind_addr)) {
-      log("SYSERR: DFLT_IP of %s appears to be an invalid IP address",DFLT_IP);
+    if (!parse_ip(CONFIG_DFLT_IP, &bind_addr)) {
+      log("SYSERR: DFLT_IP of %s appears to be an invalid IP address",
+          CONFIG_DFLT_IP);
       bind_addr.s_addr = htonl(INADDR_ANY);
     }
   }
@@ -1311,7 +1388,7 @@ int new_descriptor(socket_t s)
   for (newd = descriptor_list; newd; newd = newd->next)
     sockets_connected++;
 
-  if (sockets_connected >= max_players) {
+  if (sockets_connected >= CONFIG_MAX_PLAYING) {
     write_to_descriptor(desc, "Sorry, CircleMUD is full right now... please try again later!\r\n");
     CLOSE_SOCKET(desc);
     return (0);
@@ -1320,11 +1397,12 @@ int new_descriptor(socket_t s)
   CREATE(newd, struct descriptor_data, 1);
 
   /* find the sitename */
-  if (nameserver_is_slow || !(from = gethostbyaddr((char *) &peer.sin_addr,
+  if (CONFIG_NS_IS_SLOW ||
+      !(from = gethostbyaddr((char *) &peer.sin_addr,
 				      sizeof(peer.sin_addr), AF_INET))) {
 
     /* resolution failed */
-    if (!nameserver_is_slow)
+    if (!CONFIG_NS_IS_SLOW)
       perror("SYSERR: gethostbyaddr");
 
     /* find the numeric site address */
@@ -1930,9 +2008,13 @@ void close_socket(struct descriptor_data
       if (*(d->str))
         free(*(d->str));
       free(d->str);
+      d->str = NULL;
+    } else if (d->backstr && !IS_NPC(d->character) && !PLR_FLAGGED(d->character, PLR_WRITING)) {
+      free(d->backstr);      /* editing description ... not olc */
+      d->backstr = NULL;
     }
 
-    if (STATE(d) == CON_PLAYING || STATE(d) == CON_DISCONNECT) {
+    if (IS_PLAYING(d) || STATE(d) == CON_DISCONNECT) {
       struct char_data *link_challenged = d->original ? d->original : d->character;
 
       /* We are guaranteed to have a person. */
@@ -1964,6 +2046,21 @@ void close_socket(struct descriptor_data
   if (d->showstr_count)
     free(d->showstr_vector);
 
+  /*. Kill any OLC stuff .*/
+  switch (d->connected) {
+    case CON_OEDIT:
+    case CON_REDIT:
+    case CON_ZEDIT:
+    case CON_MEDIT:
+    case CON_SEDIT:
+    case CON_TEDIT:
+    case CON_AEDIT:
+      cleanup_olc(d, CLEANUP_ALL);
+      break;
+    default:
+      break;
+  }
+
   free(d);
 }
 
diff -BENbdpru circle-3.1/src/conf.h circle3.1_oasis206/src/conf.h
--- circle-3.1/src/conf.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/conf.h	2003-07-26 10:20:18.000000000 +0200
@@ -0,0 +1,333 @@
+/* src/conf.h.  Generated automatically by configure.  */
+/* src/conf.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define if you don't have vprintf but do have _doprnt.  */
+/* #undef HAVE_DOPRNT */
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define if you have the vprintf function.  */
+#define HAVE_VPRINTF 1
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef pid_t */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if we're compiling CircleMUD under any type of UNIX system.  */
+#define CIRCLE_UNIX 1
+
+/* Define if the system is capable of using crypt() to encrypt.  */
+#define CIRCLE_CRYPT 1
+
+/* Define if we don't have proper support for the system's crypt().  */
+/* #undef HAVE_UNSAFE_CRYPT */
+
+/* Define is the system has struct in_addr.  */
+#define HAVE_STRUCT_IN_ADDR 1
+
+/* Define to `int' if <sys/socket.h> doesn't define.  */
+/* #undef socklen_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef ssize_t */
+
+/* Define if you have the gettimeofday function.  */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define if you have the inet_addr function.  */
+#define HAVE_INET_ADDR 1
+
+/* Define if you have the inet_aton function.  */
+#define HAVE_INET_ATON 1
+
+/* Define if you have the select function.  */
+#define HAVE_SELECT 1
+
+/* Define if you have the snprintf function.  */
+#define HAVE_SNPRINTF 1
+
+/* Define if you have the strcasecmp function.  */
+#define HAVE_STRCASECMP 1
+
+/* Define if you have the strdup function.  */
+#define HAVE_STRDUP 1
+
+/* Define if you have the strerror function.  */
+#define HAVE_STRERROR 1
+
+/* Define if you have the stricmp function.  */
+/* #undef HAVE_STRICMP */
+
+/* Define if you have the strlcpy function.  */
+#define HAVE_STRLCPY 1
+
+/* Define if you have the strncasecmp function.  */
+#define HAVE_STRNCASECMP 1
+
+/* Define if you have the strnicmp function.  */
+/* #undef HAVE_STRNICMP */
+
+/* Define if you have the strstr function.  */
+#define HAVE_STRSTR 1
+
+/* Define if you have the vsnprintf function.  */
+#define HAVE_VSNPRINTF 1
+
+/* Define if you have the <arpa/inet.h> header file.  */
+#define HAVE_ARPA_INET_H 1
+
+/* Define if you have the <arpa/telnet.h> header file.  */
+#define HAVE_ARPA_TELNET_H 1
+
+/* Define if you have the <assert.h> header file.  */
+#define HAVE_ASSERT_H 1
+
+/* Define if you have the <crypt.h> header file.  */
+#define HAVE_CRYPT_H 1
+
+/* Define if you have the <errno.h> header file.  */
+#define HAVE_ERRNO_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have the <mcheck.h> header file.  */
+/* #undef HAVE_MCHECK_H */
+
+/* Define if you have the <memory.h> header file.  */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have the <net/errno.h> header file.  */
+/* #undef HAVE_NET_ERRNO_H */
+
+/* Define if you have the <netdb.h> header file.  */
+#define HAVE_NETDB_H 1
+
+/* Define if you have the <netinet/in.h> header file.  */
+#define HAVE_NETINET_IN_H 1
+
+/* Define if you have the <signal.h> header file.  */
+#define HAVE_SIGNAL_H 1
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <strings.h> header file.  */
+#define HAVE_STRINGS_H 1
+
+/* Define if you have the <sys/fcntl.h> header file.  */
+#define HAVE_SYS_FCNTL_H 1
+
+/* Define if you have the <sys/resource.h> header file.  */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define if you have the <sys/select.h> header file.  */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define if you have the <sys/socket.h> header file.  */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define if you have the <sys/stat.h> header file.  */
+#define HAVE_SYS_STAT_H 1
+
+/* Define if you have the <sys/time.h> header file.  */
+#define HAVE_SYS_TIME_H 1
+
+/* Define if you have the <sys/types.h> header file.  */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if you have the <sys/uio.h> header file.  */
+#define HAVE_SYS_UIO_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the malloc library (-lmalloc).  */
+/* #undef HAVE_LIBMALLOC */
+
+/* Check for a prototype to accept. */
+/* #undef NEED_ACCEPT_PROTO */
+
+/* Check for a prototype to atoi. */
+/* #undef NEED_ATOI_PROTO */
+
+/* Check for a prototype to atol. */
+/* #undef NEED_ATOL_PROTO */
+
+/* Check for a prototype to bind. */
+/* #undef NEED_BIND_PROTO */
+
+/* Check for a prototype to bzero. */
+/* #undef NEED_BZERO_PROTO */
+
+/* Check for a prototype to chdir. */
+/* #undef NEED_CHDIR_PROTO */
+
+/* Check for a prototype to close. */
+/* #undef NEED_CLOSE_PROTO */
+
+/* Check for a prototype to crypt. */
+/* #undef NEED_CRYPT_PROTO */
+
+/* Check for a prototype to fclose. */
+/* #undef NEED_FCLOSE_PROTO */
+
+/* Check for a prototype to fcntl. */
+/* #undef NEED_FCNTL_PROTO */
+
+/* Check for a prototype to fflush. */
+/* #undef NEED_FFLUSH_PROTO */
+
+/* Check for a prototype to fprintf. */
+/* #undef NEED_FPRINTF_PROTO */
+
+/* Check for a prototype to fputc. */
+/* #undef NEED_FPUTC_PROTO */
+
+/* Check for a prototype to fputs. */
+/* #undef NEED_FPUTS_PROTO */
+
+/* Check for a prototype to fread. */
+/* #undef NEED_FREAD_PROTO */
+
+/* Check for a prototype to fscanf. */
+/* #undef NEED_FSCANF_PROTO */
+
+/* Check for a prototype to fseek. */
+/* #undef NEED_FSEEK_PROTO */
+
+/* Check for a prototype to fwrite. */
+/* #undef NEED_FWRITE_PROTO */
+
+/* Check for a prototype to getpeername. */
+/* #undef NEED_GETPEERNAME_PROTO */
+
+/* Check for a prototype to getpid. */
+/* #undef NEED_GETPID_PROTO */
+
+/* Check for a prototype to getrlimit. */
+/* #undef NEED_GETRLIMIT_PROTO */
+
+/* Check for a prototype to getsockname. */
+/* #undef NEED_GETSOCKNAME_PROTO */
+
+/* Check for a prototype to gettimeofday. */
+/* #undef NEED_GETTIMEOFDAY_PROTO */
+
+/* Check for a prototype to htonl. */
+/* #undef NEED_HTONL_PROTO */
+
+/* Check for a prototype to htons. */
+/* #undef NEED_HTONS_PROTO */
+
+/* Check for a prototype to inet_addr. */
+/* #undef NEED_INET_ADDR_PROTO */
+
+/* Check for a prototype to inet_aton. */
+/* #undef NEED_INET_ATON_PROTO */
+
+/* Check for a prototype to inet_ntoa. */
+/* #undef NEED_INET_NTOA_PROTO */
+
+/* Check for a prototype to listen. */
+/* #undef NEED_LISTEN_PROTO */
+
+/* Check for a prototype to ntohl. */
+/* #undef NEED_NTOHL_PROTO */
+
+/* Check for a prototype to perror. */
+/* #undef NEED_PERROR_PROTO */
+
+/* Check for a prototype to printf. */
+/* #undef NEED_PRINTF_PROTO */
+
+/* Check for a prototype to qsort. */
+/* #undef NEED_QSORT_PROTO */
+
+/* Check for a prototype to read. */
+/* #undef NEED_READ_PROTO */
+
+/* Check for a prototype to remove. */
+/* #undef NEED_REMOVE_PROTO */
+
+/* Check for a prototype to rewind. */
+/* #undef NEED_REWIND_PROTO */
+
+/* Check for a prototype to select. */
+/* #undef NEED_SELECT_PROTO */
+
+/* Check for a prototype to setitimer. */
+/* #undef NEED_SETITIMER_PROTO */
+
+/* Check for a prototype to setrlimit. */
+/* #undef NEED_SETRLIMIT_PROTO */
+
+/* Check for a prototype to setsockopt. */
+/* #undef NEED_SETSOCKOPT_PROTO */
+
+/* Check for a prototype to snprintf. */
+/* #undef NEED_SNPRINTF_PROTO */
+
+/* Check for a prototype to socket. */
+/* #undef NEED_SOCKET_PROTO */
+
+/* Check for a prototype to sprintf. */
+/* #undef NEED_SPRINTF_PROTO */
+
+/* Check for a prototype to sscanf. */
+/* #undef NEED_SSCANF_PROTO */
+
+/* Check for a prototype to strcasecmp. */
+/* #undef NEED_STRCASECMP_PROTO */
+
+/* Check for a prototype to strdup. */
+/* #undef NEED_STRDUP_PROTO */
+
+/* Check for a prototype to strerror. */
+/* #undef NEED_STRERROR_PROTO */
+
+/* Check for a prototype to stricmp. */
+/* #undef NEED_STRICMP_PROTO */
+
+/* Check for a prototype to strlcpy. */
+/* #undef NEED_STRLCPY_PROTO */
+
+/* Check for a prototype to strncasecmp. */
+/* #undef NEED_STRNCASECMP_PROTO */
+
+/* Check for a prototype to strnicmp. */
+/* #undef NEED_STRNICMP_PROTO */
+
+/* Check for a prototype to system. */
+/* #undef NEED_SYSTEM_PROTO */
+
+/* Check for a prototype to time. */
+/* #undef NEED_TIME_PROTO */
+
+/* Check for a prototype to unlink. */
+/* #undef NEED_UNLINK_PROTO */
+
+/* Check for a prototype to vsnprintf. */
+/* #undef NEED_VSNPRINTF_PROTO */
+
+/* Check for a prototype to write. */
+/* #undef NEED_WRITE_PROTO */
+
diff -BENbdpru circle-3.1/src/config.c circle3.1_oasis206/src/config.c
--- circle-3.1/src/config.c	2001-12-11 20:30:08.000000000 +0100
+++ circle3.1_oasis206/src/config.c	2003-10-07 08:51:48.000000000 +0200
@@ -16,11 +16,12 @@
 #include "structs.h"
 #include "interpreter.h"	/* alias_data definition for structs.h */
 
-#define TRUE	1
-#define YES	1
-#define FALSE	0
-#define NO	0
-
+/*
+ * Update:  The following constants and variables are now the default values
+ * for backwards compatibility with the new cedit game configurator.  If you
+ * would not like to use the cedit command, you can change the values in
+ * this file instead.  - Mythran
+ */
 /*
  * Below are several constants which you can change to alter certain aspects
  * of the way CircleMUD acts.  Since this is a .c file, all you have to do
@@ -44,6 +45,21 @@
 
 
 /* GAME PLAY OPTIONS */
+#if !defined(NO)
+#define NO 0
+#endif
+
+#if !defined(YES)
+#define YES 1
+#endif
+
+#if !defined(FALSE)
+#define FALSE 0
+#endif
+
+#if !defined(TRUE)
+#define TRUE  (!FALSE)
+#endif
 
 /*
  * pk_allowed sets the tone of the entire game.  If pk_allowed is set to
@@ -266,6 +282,17 @@ int siteok_everyone = TRUE;
 
 int nameserver_is_slow = NO;
 
+/*
+ * Will changes save automaticaly in OLC ?
+ */
+int auto_save_olc = 1;
+
+/*
+ * if you wish to enable Aedit, set this to 1 
+ * This will make the mud look for a file called socials.new,
+ * which is in a different format than the stock socials file.
+ */
+int use_new_socials = 0;
 
 const char *MENU =
 "\r\n"
diff -BENbdpru circle-3.1/src/constants.c circle3.1_oasis206/src/constants.c
--- circle-3.1/src/constants.c	2002-11-18 18:28:06.000000000 +0100
+++ circle3.1_oasis206/src/constants.c	2003-10-07 08:53:24.000000000 +0200
@@ -17,6 +17,9 @@
 cpp_extern const char *circlemud_version =
 	"CircleMUD, version 3.1";
 
+cpp_extern const char *oasisolc_version =
+	"OasisOLC 2.0.6";
+
 /* strings corresponding to ordinals/bitvectors in structs.h ***********/
 
 
@@ -184,6 +187,9 @@ const char *preference_bits[] = {
   "NO_GOS",
   "NO_GTZ",
   "RMFLG",
+  "D_AUTO",
+  "CLS",
+  "BLDWLK",
   "\n"
 };
 
@@ -237,6 +243,14 @@ const char *connected_types[] = {
   "Self-Delete 1",
   "Self-Delete 2",
   "Disconnecting",
+  "Object edit",
+  "Room edit",
+  "Zone edit",
+  "Mobile edit",
+  "Shop edit",
+  "Text edit",
+  "Config edit",
+  "Social edit",
   "\n"
 };
 
@@ -775,6 +789,26 @@ const char *month_name[] = {
   "Month of the Great Evil"
 };
 
+#if defined(CONFIG_OASIS_MPROG)
+/*
+ * Definitions necessary for MobProg support in OasisOLC
+ */
+const char *mobprog_types[] = {
+  "INFILE",
+  "ACT",
+  "SPEECH",
+  "RAND",
+  "FIGHT",
+  "DEATH",
+  "HITPRCNT",
+  "ENTRY",
+  "GREET",
+  "ALL_GREET",
+  "GIVE",
+  "BRIBE",
+  "\n"
+};
+#endif
 
 /* --- End of constants arrays. --- */
 
diff -BENbdpru circle-3.1/src/constants.h circle3.1_oasis206/src/constants.h
--- circle-3.1/src/constants.h	2001-09-14 12:08:58.000000000 +0200
+++ circle3.1_oasis206/src/constants.h	2003-07-26 10:19:22.000000000 +0200
@@ -1,4 +1,5 @@
 extern const char *circlemud_version;
+extern const char *oasisolc_version;
 extern const char *dirs[];
 extern const char *room_bits[];
 extern const char *exit_bits[];
diff -BENbdpru circle-3.1/src/db.c circle3.1_oasis206/src/db.c
--- circle-3.1/src/db.c	2002-04-25 08:05:28.000000000 +0200
+++ circle3.1_oasis206/src/db.c	2003-10-07 11:30:10.000000000 +0200
@@ -24,11 +24,14 @@
 #include "interpreter.h"
 #include "house.h"
 #include "constants.h"
+#include "oasis.h"
 
 /**************************************************************************
 *  declarations of most of the 'global' variables                         *
 **************************************************************************/
 
+struct config_data config_info; /* Game configuration list.	 */
+
 struct room_data *world = NULL;	/* array of rooms		 */
 room_rnum top_of_world = 0;	/* ref to top element of world	 */
 
@@ -77,6 +80,9 @@ char *policies = NULL;		/* policies page
 struct help_index_element *help_table = 0;	/* the help table	 */
 int top_of_helpt = 0;		/* top of help index table	 */
 
+struct social_messg *soc_mess_list = NULL;      /* list of socials */
+int top_of_socialt = -1;                        /* number of socials */
+
 struct time_info_data time_info;/* the infomation about the time    */
 struct weather_data weather_info;	/* the infomation about the weather */
 struct player_special_data dummy_mob;	/* dummy spec area for mobs	*/
@@ -132,6 +138,7 @@ void weather_and_time(int mode);
 void mag_assign_spells(void);
 void boot_social_messages(void);
 void update_obj_file(void);	/* In objsave.c */
+void create_command_list(void);
 void sort_commands(void);
 void sort_spells(void);
 void load_banned(void);
@@ -140,15 +147,15 @@ void boot_the_shops(FILE *shop_f, char *
 int hsort(const void *a, const void *b);
 void prune_crlf(char *txt);
 void destroy_shops(void);
+void free_object_strings(struct obj_data *obj);
+void free_object_strings_proto(struct obj_data *obj);
 
 /* external vars */
-extern int no_specials;
-extern int scheck;
-extern room_vnum mortal_start_room;
-extern room_vnum immort_start_room;
-extern room_vnum frozen_start_room;
 extern struct descriptor_data *descriptor_list;
 extern const char *unused_spellname;	/* spell_parser.c */
+extern int no_specials;
+extern int scheck;
+
 
 /*************************************************************************
 *  routines for booting the system                                       *
@@ -194,42 +201,69 @@ ACMD(do_reboot)
   if (!str_cmp(arg, "all") || *arg == '*') {
     if (file_to_string_alloc(GREETINGS_FILE, &GREETINGS) == 0)
       prune_crlf(GREETINGS);
-    file_to_string_alloc(WIZLIST_FILE, &wizlist);
-    file_to_string_alloc(IMMLIST_FILE, &immlist);
-    file_to_string_alloc(NEWS_FILE, &news);
-    file_to_string_alloc(CREDITS_FILE, &credits);
-    file_to_string_alloc(MOTD_FILE, &motd);
-    file_to_string_alloc(IMOTD_FILE, &imotd);
-    file_to_string_alloc(HELP_PAGE_FILE, &help);
-    file_to_string_alloc(INFO_FILE, &info);
-    file_to_string_alloc(POLICIES_FILE, &policies);
-    file_to_string_alloc(HANDBOOK_FILE, &handbook);
-    file_to_string_alloc(BACKGROUND_FILE, &background);
-  } else if (!str_cmp(arg, "wizlist"))
-    file_to_string_alloc(WIZLIST_FILE, &wizlist);
-  else if (!str_cmp(arg, "immlist"))
-    file_to_string_alloc(IMMLIST_FILE, &immlist);
-  else if (!str_cmp(arg, "news"))
-    file_to_string_alloc(NEWS_FILE, &news);
-  else if (!str_cmp(arg, "credits"))
-    file_to_string_alloc(CREDITS_FILE, &credits);
-  else if (!str_cmp(arg, "motd"))
-    file_to_string_alloc(MOTD_FILE, &motd);
-  else if (!str_cmp(arg, "imotd"))
-    file_to_string_alloc(IMOTD_FILE, &imotd);
-  else if (!str_cmp(arg, "help"))
-    file_to_string_alloc(HELP_PAGE_FILE, &help);
-  else if (!str_cmp(arg, "info"))
-    file_to_string_alloc(INFO_FILE, &info);
-  else if (!str_cmp(arg, "policy"))
-    file_to_string_alloc(POLICIES_FILE, &policies);
-  else if (!str_cmp(arg, "handbook"))
-    file_to_string_alloc(HANDBOOK_FILE, &handbook);
-  else if (!str_cmp(arg, "background"))
-    file_to_string_alloc(BACKGROUND_FILE, &background);
-  else if (!str_cmp(arg, "greetings")) {
+    if (file_to_string_alloc(WIZLIST_FILE, &wizlist) < 0) 
+      send_to_char(ch, "Can not read wizlist\r\n");
+    if (file_to_string_alloc(IMMLIST_FILE, &immlist) < 0) 
+      send_to_char(ch, "Can not read immlist\r\n");
+    if (file_to_string_alloc(NEWS_FILE, &news) < 0) 
+      send_to_char(ch, "Can not read news\r\n");
+    if (file_to_string_alloc(CREDITS_FILE, &credits) < 0) 
+      send_to_char(ch, "Can not read credits\r\n");
+    if (file_to_string_alloc(MOTD_FILE, &motd) < 0) 
+      send_to_char(ch, "Can not read motd\r\n");
+    if (file_to_string_alloc(IMOTD_FILE, &imotd) < 0) 
+      send_to_char(ch, "Can not read imotd\r\n");
+    if (file_to_string_alloc(HELP_PAGE_FILE, &help) < 0) 
+      send_to_char(ch, "Can not read help front page\r\n");
+    if (file_to_string_alloc(INFO_FILE, &info) < 0) 
+      send_to_char(ch, "Can not read info file\r\n");
+    if (file_to_string_alloc(POLICIES_FILE, &policies) < 0) 
+      send_to_char(ch, "Can not read policies\r\n");
+    if (file_to_string_alloc(HANDBOOK_FILE, &handbook) < 0) 
+      send_to_char(ch, "Can not read handbook\r\n");
+    if (file_to_string_alloc(BACKGROUND_FILE, &background) < 0) 
+      send_to_char(ch, "Can not read background\r\n");
+    if (help_table)
+      free_help();
+    index_boot(DB_BOOT_HLP);
+  } else if (!str_cmp(arg, "wizlist")) {
+    if (file_to_string_alloc(WIZLIST_FILE, &wizlist) < 0) 
+      send_to_char(ch, "Can not read wizlist\r\n");
+  } else if (!str_cmp(arg, "immlist")) {
+    if (file_to_string_alloc(IMMLIST_FILE, &immlist) < 0) 
+      send_to_char(ch, "Can not read immlist\r\n");
+  } else if (!str_cmp(arg, "news")) {
+    if (file_to_string_alloc(NEWS_FILE, &news) < 0) 
+      send_to_char(ch, "Can not read news\r\n");
+  } else if (!str_cmp(arg, "credits")) {
+    if (file_to_string_alloc(CREDITS_FILE, &credits) < 0) 
+      send_to_char(ch, "Can not read credits\r\n");
+  } else if (!str_cmp(arg, "motd")) {
+    if (file_to_string_alloc(MOTD_FILE, &motd) < 0) 
+      send_to_char(ch, "Can not read motd\r\n");
+  } else if (!str_cmp(arg, "imotd")) {
+    if (file_to_string_alloc(IMOTD_FILE, &imotd) < 0) 
+      send_to_char(ch, "Can not read imotd\r\n");
+  } else if (!str_cmp(arg, "help")) {
+    if (file_to_string_alloc(HELP_PAGE_FILE, &help) < 0) 
+      send_to_char(ch, "Can not read help front page\r\n");
+  } else if (!str_cmp(arg, "info")) {
+    if (file_to_string_alloc(INFO_FILE, &info) < 0) 
+      send_to_char(ch, "Can not read info\r\n");
+  } else if (!str_cmp(arg, "policy")) {
+    if (file_to_string_alloc(POLICIES_FILE, &policies) < 0) 
+      send_to_char(ch, "Can not read policy\r\n");
+  } else if (!str_cmp(arg, "handbook")) {
+    if (file_to_string_alloc(HANDBOOK_FILE, &handbook) < 0) 
+      send_to_char(ch, "Can not read handbook\r\n");
+  } else if (!str_cmp(arg, "background")) {
+    if (file_to_string_alloc(BACKGROUND_FILE, &background) < 0) 
+      send_to_char(ch, "Can not read background\r\n");
+  } else if (!str_cmp(arg, "greetings")) {
     if (file_to_string_alloc(GREETINGS_FILE, &GREETINGS) == 0)
       prune_crlf(GREETINGS);
+    else
+      send_to_char(ch, "Can not read greetings.\r\n");
   } else if (!str_cmp(arg, "xhelp")) {
     if (help_table)
       free_help();
@@ -239,7 +273,7 @@ ACMD(do_reboot)
     return;
   }
 
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
 }
 
 
@@ -328,6 +362,7 @@ void destroy_db(void)
     }
   }
   free(world);
+  top_of_world = 0;
 
   /* Objects */
   for (cnt = 0; cnt <= top_of_objt; cnt++) {
@@ -367,6 +402,15 @@ void destroy_db(void)
   destroy_shops();
 
   /* Zones */
+  /* zone table reset queue */
+  if (reset_q.head) {
+    struct reset_q_element *ftemp=reset_q.head, *temp;
+    while (ftemp) {
+      temp = ftemp->next;
+      free(ftemp);
+      ftemp = temp;
+    }   
+  }
   for (cnt = 0; cnt <= top_of_zone_table; cnt++) {
     if (zone_table[cnt].name)
       free(zone_table[cnt].name);
@@ -419,6 +463,9 @@ void boot_db(void)
   log("Loading social messages.");
   boot_social_messages();
 
+  log("Building command list.");
+  create_command_list(); /* aedit patch -- M. Scott */
+
   log("Assigning function pointers:");
 
   if (!no_specials) {
@@ -966,6 +1013,19 @@ void parse_room(FILE *fl, int virtual_nr
       CREATE(new_descr, struct extra_descr_data, 1);
       new_descr->keyword = fread_string(fl, buf2);
       new_descr->description = fread_string(fl, buf2);
+      /* fix for crashes in the editor when formatting 
+       * - e-descs are assumed to end with a \r\n
+       * -- Welcor 09/03 
+       */
+      { 
+      	char *t = strchr(new_descr->description, '\0');
+      	if (t > new_descr->description && *(t-1) != '\n') {
+      	  CREATE(t, char, strlen(new_descr->description)+3);
+      	  sprintf(t, "%s\r\n", new_descr->description); /* sprintf ok : size checked above*/
+      	  free(new_descr->description);
+      	  new_descr->description = t;
+      	}
+      }
       new_descr->next = world[room_nr].ex_description;
       world[room_nr].ex_description = new_descr;
       break;
@@ -987,7 +1047,7 @@ void setup_dir(FILE *fl, int room, int d
   int t[5];
   char line[READ_SIZE], buf2[128];
 
-  snprintf(buf2, sizeof(buf2), "room #%d, direction D%d", GET_ROOM_VNUM(room), dir);
+  snprintf(buf2, sizeof(buf2), "room #%d, direction D%d", GET_ROOM_VNUM(room-1)+1, dir);
 
   CREATE(world[room].dir_option[dir], struct room_direction_data, 1);
   world[room].dir_option[dir]->general_description = fread_string(fl, buf2);
@@ -1008,24 +1068,24 @@ void setup_dir(FILE *fl, int room, int d
   else
     world[room].dir_option[dir]->exit_info = 0;
 
-  world[room].dir_option[dir]->key = t[1];
-  world[room].dir_option[dir]->to_room = t[2];
+  world[room].dir_option[dir]->key = ((t[1] == -1 || t[1] == 65535) ? NOTHING : t[1]);
+  world[room].dir_option[dir]->to_room = ((t[2] == -1  || t[2] == 65535) ? NOWHERE : t[2]);
 }
 
 
 /* make sure the start rooms exist & resolve their vnums to rnums */
 void check_start_rooms(void)
 {
-  if ((r_mortal_start_room = real_room(mortal_start_room)) == NOWHERE) {
+  if ((r_mortal_start_room = real_room(CONFIG_MORTAL_START)) == NOWHERE) {
     log("SYSERR:  Mortal start room does not exist.  Change in config.c.");
     exit(1);
   }
-  if ((r_immort_start_room = real_room(immort_start_room)) == NOWHERE) {
+  if ((r_immort_start_room = real_room(CONFIG_IMMORTAL_START)) == NOWHERE) {
     if (!mini_mud)
       log("SYSERR:  Warning: Immort start room does not exist.  Change in config.c.");
     r_immort_start_room = r_mortal_start_room;
   }
-  if ((r_frozen_start_room = real_room(frozen_start_room)) == NOWHERE) {
+  if ((r_frozen_start_room = real_room(CONFIG_FROZEN_START)) == NOWHERE) {
     if (!mini_mud)
       log("SYSERR:  Warning: Frozen start room does not exist.  Change in config.c.");
     r_frozen_start_room = r_mortal_start_room;
@@ -1447,15 +1507,20 @@ char *parse_object(FILE *obj_f, int nr)
     log("SYSERR: Expecting first numeric line of %s, but file ended!", buf2);
     exit(1);
   }
-  if ((retval = sscanf(line, " %d %s %s", t, f1, f2)) != 3) {
-    log("SYSERR: Format error in first numeric line (expecting 3 args, got %d), %s", retval, buf2);
+  if ((retval = sscanf(line, " %d %s %s %d", t, f1, f2, t + 3)) != 4) {
+    if (retval == 3)
+      t[3] = 0;
+    else {
+      log("SYSERR: Format error in first numeric line (expecting 4 args, got %d), %s", retval, buf2);
     exit(1);
   }
+  }
 
   /* Object flags checked in check_object(). */
   GET_OBJ_TYPE(obj_proto + i) = t[0];
   GET_OBJ_EXTRA(obj_proto + i) = asciiflag_conv(f1);
   GET_OBJ_WEAR(obj_proto + i) = asciiflag_conv(f2);
+  GET_OBJ_PERM(obj_proto + i) = t[3];
 
   if (!get_line(obj_f, line)) {
     log("SYSERR: Expecting second numeric line of %s, but file ended!", buf2);
@@ -1474,16 +1539,23 @@ char *parse_object(FILE *obj_f, int nr)
     log("SYSERR: Expecting third numeric line of %s, but file ended!", buf2);
     exit(1);
   }
-  if ((retval = sscanf(line, "%d %d %d", t, t + 1, t + 2)) != 3) {
-    log("SYSERR: Format error in third numeric line (expecting 3 args, got %d), %s", retval, buf2);
+  if ((retval = sscanf(line, "%d %d %d %d", t, t + 1, t + 2, t + 3)) != 4) {
+    if (retval == 3)
+      t[3] = 0;
+    else {
+      log("SYSERR: Format error in third numeric line (expecting 4 args, got %d), %s", retval, buf2);
     exit(1);
   }
+  }
+  
   GET_OBJ_WEIGHT(obj_proto + i) = t[0];
   GET_OBJ_COST(obj_proto + i) = t[1];
   GET_OBJ_RENT(obj_proto + i) = t[2];
+  GET_OBJ_LEVEL(obj_proto + i) = t[3];
 
   /* check to make sure that weight of containers exceeds curr. quantity */
-  if (GET_OBJ_TYPE(obj_proto + i) == ITEM_DRINKCON || GET_OBJ_TYPE(obj_proto + i) == ITEM_FOUNTAIN) {
+  if (GET_OBJ_TYPE(obj_proto + i) == ITEM_DRINKCON ||
+      GET_OBJ_TYPE(obj_proto + i) == ITEM_FOUNTAIN) {
     if (GET_OBJ_WEIGHT(obj_proto + i) < GET_OBJ_VAL(obj_proto + i, 1))
       GET_OBJ_WEIGHT(obj_proto + i) = GET_OBJ_VAL(obj_proto + i, 1) + 5;
   }
@@ -1535,8 +1607,9 @@ char *parse_object(FILE *obj_f, int nr)
       break;
     case '$':
     case '#':
+      top_of_objt = i;
       check_object(obj_proto + i);
-      top_of_objt = i++;
+      i++;
       return (line);
     default:
       log("SYSERR: Format error in (%c): %s", *line, buf2);
@@ -1554,6 +1627,7 @@ void load_zones(FILE *fl, char *zonename
   static zone_rnum zone = 0;
   int cmd_no, num_of_cmds = 0, line_num = 0, tmp, error;
   char *ptr, buf[READ_SIZE], zname[READ_SIZE], buf2[MAX_STRING_LENGTH];
+  int zone_fix = FALSE;
 
   strlcpy(zname, zonename, sizeof(zname));
 
@@ -1588,12 +1662,31 @@ void load_zones(FILE *fl, char *zonename
   line_num += get_line(fl, buf);
   if ((ptr = strchr(buf, '~')) != NULL)	/* take off the '~' if it's there */
     *ptr = '\0';
+  Z.builders = strdup(buf);
+  
+  line_num += get_line(fl, buf);
+  if ((ptr = strchr(buf, '~')) != NULL)	/* take off the '~' if it's there */
+    *ptr = '\0';
   Z.name = strdup(buf);
 
   line_num += get_line(fl, buf);
   if (sscanf(buf, " %hd %hd %d %d ", &Z.bot, &Z.top, &Z.lifespan, &Z.reset_mode) != 4) {
-    log("SYSERR: Format error in numeric constant line of %s", zname);
+    /*
+     * This may be due to the fact that the zone has no builder.  So, we just attempt
+     * to fix this by copying the previous 2 last reads into this variable and the
+     * last one.
+     */
+    log("SYSERR: Format error in numeric constant line of %s, attempting to fix.", zname);
+    if (sscanf(Z.name, " %hd %hd %d %d ", &Z.bot, &Z.top, &Z.lifespan, &Z.reset_mode) != 4) {
+      log("SYSERR: Could not fix previous error, aborting game.");
     exit(1);
+    } else {
+      free(Z.name);
+      Z.name = strdup(Z.builders);
+      free(Z.builders);
+      Z.builders = strdup("None.");
+      zone_fix = TRUE;
+    }
   }
   if (Z.bot > Z.top) {
     log("SYSERR: Zone %d bottom (%d) > top (%d).", Z.number, Z.bot, Z.top);
@@ -1603,10 +1696,15 @@ void load_zones(FILE *fl, char *zonename
   cmd_no = 0;
 
   for (;;) {
+    /* skip reading one line if we fixed above (line is correct already) */
+    if (zone_fix != TRUE) {
     if ((tmp = get_line(fl, buf)) == 0) {
       log("SYSERR: Format error in %s - premature end of file", zname);
       exit(1);
     }
+    } else
+      zone_fix = FALSE;
+    
     line_num += tmp;
     ptr = buf;
     skip_spaces(&ptr);
@@ -1928,7 +2026,8 @@ void zone_update(void)
     if (zone_table[update_u->zone_to_reset].reset_mode == 2 ||
 	is_empty(update_u->zone_to_reset)) {
       reset_zone(update_u->zone_to_reset);
-      mudlog(CMP, LVL_GOD, FALSE, "Auto zone reset: %s", zone_table[update_u->zone_to_reset].name);
+      mudlog(CMP, LVL_GOD, FALSE, "Auto zone reset: %s (Zone %d)", 
+          zone_table[update_u->zone_to_reset].name, zone_table[update_u->zone_to_reset].number);
       /* dequeue */
       if (update_u == reset_q.head)
 	reset_q.head = reset_q.head->next;
@@ -2434,17 +2533,19 @@ char *fread_string(FILE *fl, const char 
       exit(1);
     }
     /* If there is a '~', end the string; else put an "\r\n" over the '\n'. */
-    if ((point = strchr(tmp, '~')) != NULL) {
-      *point = '\0';
+    /* now only removes trailing ~'s -- Welcor */
+    point = strchr(tmp, '\0');
+    for (point-- ; (*point=='\r' || *point=='\n'); point--);
+    if (*point=='~') {
+      *point='\0';
       done = 1;
     } else {
-      point = tmp + strlen(tmp) - 1;
-      *(point++) = '\r';
-      *(point++) = '\n';
-      *point = '\0';
+      *(++point) = '\r';
+      *(++point) = '\n';
+      *(++point) = '\0';
     }
 
-    templength = strlen(tmp);
+    templength = point - tmp;
 
     if (length + templength >= MAX_STRING_LENGTH) {
       log("SYSERR: fread_string: string too large (db.c)");
@@ -2460,6 +2561,16 @@ char *fread_string(FILE *fl, const char 
   return (strlen(buf) ? strdup(buf) : NULL);
 }
 
+/* Called to free all allocated follow_type structs */
+void free_followers(struct char_data *ch)
+{
+  struct follow_type *j, *k;
+
+  for (k = ch->followers; k; k = j) {
+    j = k->next;
+    free(k);
+  }
+}
 
 /* release memory allocated for a char struct */
 void free_char(struct char_data *ch)
@@ -2508,6 +2619,9 @@ void free_char(struct char_data *ch)
   while (ch->affected)
     affect_remove(ch, ch->affected);
 
+  if (ch->followers)
+    free_followers(ch);
+
   if (ch->desc)
     ch->desc->character = NULL;
 
@@ -2520,31 +2634,10 @@ void free_char(struct char_data *ch)
 /* release memory allocated for an obj struct */
 void free_obj(struct obj_data *obj)
 {
-  int nr;
-
-  if ((nr = GET_OBJ_RNUM(obj)) == NOTHING) {
-    if (obj->name)
-      free(obj->name);
-    if (obj->description)
-      free(obj->description);
-    if (obj->short_description)
-      free(obj->short_description);
-    if (obj->action_description)
-      free(obj->action_description);
-    if (obj->ex_description)
-      free_extra_descriptions(obj->ex_description);
-  } else {
-    if (obj->name && obj->name != obj_proto[nr].name)
-      free(obj->name);
-    if (obj->description && obj->description != obj_proto[nr].description)
-      free(obj->description);
-    if (obj->short_description && obj->short_description != obj_proto[nr].short_description)
-      free(obj->short_description);
-    if (obj->action_description && obj->action_description != obj_proto[nr].action_description)
-      free(obj->action_description);
-    if (obj->ex_description && obj->ex_description != obj_proto[nr].ex_description)
-      free_extra_descriptions(obj->ex_description);
-  }
+  if (GET_OBJ_RNUM(obj) == NOWHERE)
+    free_object_strings(obj);
+  else
+    free_object_strings_proto(obj);
 
   free(obj);
 }
@@ -2864,9 +2957,9 @@ obj_rnum real_object(obj_vnum vnum)
 
 
 /* returns the real number of the zone with given virtual number */
-room_rnum real_zone(room_vnum vnum)
+zone_rnum real_zone(zone_vnum vnum)
 {
-  room_rnum bot, top, mid;
+  zone_rnum bot, top, mid;
 
   bot = 0;
   top = top_of_zone_table;
@@ -3025,3 +3118,364 @@ int check_bitvector_names(bitvector_t bi
   return (error);
 }
 
+/* External variables from config.c */
+extern int pk_allowed;
+extern int pt_allowed;
+extern int level_can_shout;
+extern int holler_move_cost;
+extern int tunnel_size;
+extern int max_exp_gain;
+extern int max_exp_loss;
+extern int max_npc_corpse_time;
+extern int max_pc_corpse_time;
+extern int idle_void;
+extern int idle_rent_time;
+extern int idle_max_level;
+extern int dts_are_dumps;
+extern int load_into_inventory;
+extern int track_through_doors;
+extern int immort_level_ok;
+extern int free_rent;
+extern int max_obj_save;
+extern int min_rent_cost;
+extern int auto_save;
+extern int autosave_time;
+extern int crash_file_timeout;
+extern int rent_file_timeout;
+extern room_vnum mortal_start_room;
+extern room_vnum immort_start_room;
+extern room_vnum frozen_start_room;
+extern room_vnum donation_room_1;
+extern room_vnum donation_room_2;
+extern room_vnum donation_room_3;
+extern ush_int DFLT_PORT;
+extern const char *DFLT_IP;
+extern const char *DFLT_DIR;
+extern const char *LOGNAME;
+extern int max_playing;
+extern int max_filesize;
+extern int max_bad_pws;
+extern int siteok_everyone;
+extern int nameserver_is_slow;
+extern int use_new_socials;
+extern int auto_save_olc;
+extern const char *MENU;
+extern const char *WELC_MESSG;
+extern const char *START_MESSG;
+extern int use_autowiz;
+extern int min_wizlist_lev;
+extern const char *OK;
+extern const char *NOPERSON;
+extern const char *NOEFFECT;
+
+void load_default_config( void )
+{
+  /****************************************************************************/
+  /** This function is called only once, at boot-time.                       **/
+  /** - We assume config_info is empty                          -- Welcor    **/
+  /****************************************************************************/
+  /****************************************************************************/
+  /** Game play options.                                                     **/
+  /****************************************************************************/
+  CONFIG_PK_ALLOWED 	        = pk_allowed;
+  CONFIG_PT_ALLOWED             = pt_allowed;
+  CONFIG_LEVEL_CAN_SHOUT 	= level_can_shout;
+  CONFIG_HOLLER_MOVE_COST 	= holler_move_cost;
+  CONFIG_TUNNEL_SIZE 	        = tunnel_size;
+  CONFIG_MAX_EXP_GAIN	        = max_exp_gain;
+  CONFIG_MAX_EXP_LOSS 	        = max_exp_loss;
+  CONFIG_MAX_NPC_CORPSE_TIME    = max_npc_corpse_time;
+  CONFIG_MAX_PC_CORPSE_TIME	= max_pc_corpse_time;
+  CONFIG_IDLE_VOID		= idle_void;
+  CONFIG_IDLE_RENT_TIME	        = idle_rent_time;
+  CONFIG_IDLE_MAX_LEVEL	        = idle_max_level;
+  CONFIG_DTS_ARE_DUMPS	        = dts_are_dumps;
+  CONFIG_LOAD_INVENTORY         = load_into_inventory;
+  CONFIG_OK			= strdup(OK);
+  CONFIG_NOPERSON		= strdup(NOPERSON);
+  CONFIG_NOEFFECT		= strdup(NOEFFECT);
+  CONFIG_TRACK_T_DOORS          = track_through_doors;
+  CONFIG_IMMORT_LEVEL_OK	= immort_level_ok;
+  
+  /****************************************************************************/
+  /** Rent / crashsave options.                                              **/
+  /****************************************************************************/
+  CONFIG_FREE_RENT              = free_rent;
+  CONFIG_MAX_OBJ_SAVE           = max_obj_save;
+  CONFIG_MIN_RENT_COST	        = min_rent_cost;
+  CONFIG_AUTO_SAVE		= auto_save;
+  CONFIG_AUTOSAVE_TIME	        = autosave_time;
+  CONFIG_CRASH_TIMEOUT          = crash_file_timeout;
+  CONFIG_RENT_TIMEOUT	        = rent_file_timeout;
+  
+  /****************************************************************************/
+  /** Room numbers.                                                          **/
+  /****************************************************************************/
+  CONFIG_MORTAL_START           = mortal_start_room;
+  CONFIG_IMMORTAL_START         = immort_start_room;
+  CONFIG_FROZEN_START           = frozen_start_room;
+  CONFIG_DON_ROOM_1             = donation_room_1;
+  CONFIG_DON_ROOM_2             = donation_room_2;
+  CONFIG_DON_ROOM_3             = donation_room_3;
+  
+  /****************************************************************************/
+  /** Game operation options.                                                **/
+  /****************************************************************************/
+  CONFIG_DFLT_PORT              = DFLT_PORT;
+  
+  if (DFLT_IP)
+    CONFIG_DFLT_IP              = strdup(DFLT_IP);
+  else
+    CONFIG_DFLT_IP              = NULL;
+  
+  CONFIG_DFLT_DIR               = strdup(DFLT_DIR);
+  
+  if (LOGNAME)
+    CONFIG_LOGNAME              = strdup(LOGNAME);
+  else
+    CONFIG_LOGNAME              = NULL;
+  
+  CONFIG_MAX_PLAYING            = max_playing;
+  CONFIG_MAX_FILESIZE           = max_filesize;
+  CONFIG_MAX_BAD_PWS            = max_bad_pws;
+  CONFIG_SITEOK_ALL             = siteok_everyone;
+  CONFIG_NS_IS_SLOW             = nameserver_is_slow;
+  CONFIG_NEW_SOCIALS            = use_new_socials;
+  CONFIG_OLC_SAVE               = auto_save_olc;
+  CONFIG_MENU                   = strdup(MENU);
+  CONFIG_WELC_MESSG             = strdup(WELC_MESSG);
+  CONFIG_START_MESSG            = strdup(START_MESSG);
+  
+  /****************************************************************************/
+  /** Autowiz options.                                                       **/
+  /****************************************************************************/
+  CONFIG_USE_AUTOWIZ            = use_autowiz;
+  CONFIG_MIN_WIZLIST_LEV        = min_wizlist_lev;
+}
+
+void load_config( void )
+{
+  FILE *fl;
+  char line[MAX_STRING_LENGTH];
+  char tag[MAX_INPUT_LENGTH];
+  int  num;
+  char buf[MAX_INPUT_LENGTH];
+
+  load_default_config();
+  
+  snprintf(buf, sizeof(buf), "%s/%s", DFLT_DIR, CONFIG_CONFFILE);
+  if ( !(fl = fopen(CONFIG_CONFFILE, "r")) && !(fl = fopen(buf, "r")) ) {
+    snprintf(buf, sizeof(buf), "Game Config File: %s", CONFIG_CONFFILE);
+    perror(buf);
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Load the game configuration file.                                      **/
+  /****************************************************************************/
+  while (get_line(fl, line)) {
+    split_argument(line, tag);
+    num = atoi(line);
+    
+    switch (LOWER(*tag)) {
+      case 'a':
+        if (!str_cmp(tag, "auto_save"))
+          CONFIG_AUTO_SAVE = num;
+        else if (!str_cmp(tag, "autosave_time"))
+          CONFIG_AUTOSAVE_TIME = num;
+        else if (!str_cmp(tag, "auto_save_olc"))
+          CONFIG_OLC_SAVE = num;
+        break;
+        
+      case 'c':
+        if (!str_cmp(tag, "crash_file_timeout"))
+          CONFIG_CRASH_TIMEOUT = num;
+        break;
+        
+      case 'd':
+        if (!str_cmp(tag, "dts_are_dumps"))
+          CONFIG_DTS_ARE_DUMPS = num;
+        else if (!str_cmp(tag, "donation_room_1"))
+          if (num == -1)
+            CONFIG_DON_ROOM_1 = NOWHERE;
+          else
+            CONFIG_DON_ROOM_1 = num;
+        else if (!str_cmp(tag, "donation_room_2"))
+          if (num == -1)
+            CONFIG_DON_ROOM_2 = NOWHERE;
+          else
+            CONFIG_DON_ROOM_2 = num;
+        else if (!str_cmp(tag, "donation_room_3"))
+          if (num == -1)
+            CONFIG_DON_ROOM_3 = NOWHERE;
+          else
+            CONFIG_DON_ROOM_3 = num;
+        else if (!str_cmp(tag, "dflt_dir")) {
+          if (CONFIG_DFLT_DIR)
+            free(CONFIG_DFLT_DIR);
+          if (line && *line)
+            CONFIG_DFLT_DIR = strdup(line);
+          else
+            CONFIG_DFLT_DIR = strdup(DFLT_DIR);
+        } else if (!str_cmp(tag, "dflt_ip")) {
+          if (CONFIG_DFLT_IP)
+            free(CONFIG_DFLT_IP);
+          if (line && *line)
+            CONFIG_DFLT_IP = strdup(line);
+          else
+            CONFIG_DFLT_IP = NULL;
+        } else if (!str_cmp(tag, "dflt_port"))
+          CONFIG_DFLT_PORT = num;
+        break;
+        
+      case 'f':
+        if (!str_cmp(tag, "free_rent"))
+          CONFIG_FREE_RENT = num;
+        else if (!str_cmp(tag, "frozen_start_room"))
+          CONFIG_FROZEN_START = num;
+        break;
+        
+      case 'h':
+        if (!str_cmp(tag, "holler_move_cost"))
+          CONFIG_HOLLER_MOVE_COST = num;
+        break;
+        
+      case 'i':
+        if (!str_cmp(tag, "idle_void"))
+          CONFIG_IDLE_VOID = num;
+        else if (!str_cmp(tag, "idle_rent_time"))
+          CONFIG_IDLE_RENT_TIME = num;
+        else if (!str_cmp(tag, "idle_max_level"))
+          CONFIG_IDLE_MAX_LEVEL = num;
+        else if (!str_cmp(tag, "immort_level_ok"))
+          CONFIG_IMMORT_LEVEL_OK = num;
+        else if (!str_cmp(tag, "immort_start_room"))
+          CONFIG_IMMORTAL_START = num;
+        break;
+        
+      case 'l':
+        if (!str_cmp(tag, "level_can_shout"))
+          CONFIG_LEVEL_CAN_SHOUT = num;
+        else if (!str_cmp(tag, "load_into_inventory"))
+          CONFIG_LOAD_INVENTORY = num;
+        else if (!str_cmp(tag, "logname")) {
+          if (CONFIG_LOGNAME)
+            free(CONFIG_LOGNAME);
+          if (line && *line)
+            CONFIG_LOGNAME = strdup(line);
+          else
+            CONFIG_LOGNAME = NULL;
+        }
+        break;
+        
+      case 'm':
+        if (!str_cmp(tag, "max_bad_pws"))
+          CONFIG_MAX_BAD_PWS = num;
+        else if (!str_cmp(tag, "max_exp_gain"))
+          CONFIG_MAX_EXP_GAIN = num;
+        else if (!str_cmp(tag, "max_exp_loss"))
+          CONFIG_MAX_EXP_LOSS = num;
+        else if (!str_cmp(tag, "max_filesize"))
+          CONFIG_MAX_FILESIZE = num;
+        else if (!str_cmp(tag, "max_npc_corpse_time"))
+          CONFIG_MAX_NPC_CORPSE_TIME = num;
+        else if (!str_cmp(tag, "max_obj_save"))
+          CONFIG_MAX_OBJ_SAVE = num;
+        else if (!str_cmp(tag, "max_pc_corpse_time"))
+          CONFIG_MAX_PC_CORPSE_TIME = num;
+        else if (!str_cmp(tag, "max_playing"))
+          CONFIG_MAX_PLAYING = num;
+        else if (!str_cmp(tag, "menu")) {
+          if (CONFIG_MENU)
+            free(CONFIG_MENU);
+          strncpy(buf, "Reading menu in load_config()", sizeof(buf));
+          CONFIG_MENU = fread_string(fl, buf);
+        } else if (!str_cmp(tag, "min_rent_cost"))
+          CONFIG_MIN_RENT_COST = num;
+        else if (!str_cmp(tag, "min_wizlist_lev"))
+          CONFIG_MIN_WIZLIST_LEV = num;
+        else if (!str_cmp(tag, "mortal_start_room"))
+          CONFIG_MORTAL_START = num;
+        break;
+        
+      case 'n':
+        if (!str_cmp(tag, "nameserver_is_slow"))
+          CONFIG_NS_IS_SLOW = num;
+        else if (!str_cmp(tag, "noperson")) {
+          char tmp[READ_SIZE];
+          if (CONFIG_NOPERSON)
+            free(CONFIG_NOPERSON);
+          snprintf(tmp, sizeof(tmp), "%s\r\n", line);
+          CONFIG_NOPERSON = strdup(tmp);
+        } else if (!str_cmp(tag, "noeffect")) {
+          char tmp[READ_SIZE];
+          if (CONFIG_NOEFFECT)
+            free(CONFIG_NOEFFECT);
+          snprintf(tmp, sizeof(tmp), "%s\r\n", line);
+          CONFIG_NOEFFECT = strdup(tmp);
+        }
+        break;
+      
+      case 'o':
+        if (!str_cmp(tag, "ok")) {
+          char tmp[READ_SIZE];
+          if (CONFIG_OK)
+            free(CONFIG_OK);
+          snprintf(tmp, sizeof(tmp), "%s\r\n", line);
+          CONFIG_OK = strdup(tmp);
+        }
+        break;
+                  
+      case 'p':
+        if (!str_cmp(tag, "pk_allowed"))
+          CONFIG_PK_ALLOWED = num;
+        else if (!str_cmp(tag, "pt_allowed"))
+          CONFIG_PT_ALLOWED = num;
+        break;
+        
+      case 'r':
+        if (!str_cmp(tag, "rent_file_timeout"))
+          CONFIG_RENT_TIMEOUT = num;
+        break;
+        
+      case 's':
+        if (!str_cmp(tag, "siteok_everyone"))
+          CONFIG_SITEOK_ALL = num;
+        else if (!str_cmp(tag, "start_messg")) {
+          strncpy(buf, "Reading start message in load_config()", sizeof(buf));
+          if (CONFIG_START_MESSG)
+            free(CONFIG_START_MESSG);
+          CONFIG_START_MESSG = fread_string(fl, buf);
+        }
+        break;
+        
+      case 't':
+        if (!str_cmp(tag, "tunnel_size"))
+          CONFIG_TUNNEL_SIZE = num;
+        else if (!str_cmp(tag, "track_through_doors"))
+          CONFIG_TRACK_T_DOORS = num;
+        break;
+        
+      case 'u':
+        if (!str_cmp(tag, "use_autowiz"))
+          CONFIG_USE_AUTOWIZ = num;
+        else if (!str_cmp(tag, "use_new_socials")) 
+          CONFIG_NEW_SOCIALS = num;
+        break;
+        
+      case 'w':
+        if (!str_cmp(tag, "welc_messg")) {
+          strncpy(buf, "Reading welcome message in load_config()", sizeof(buf));
+          if (CONFIG_WELC_MESSG)
+            free(CONFIG_WELC_MESSG);
+          CONFIG_WELC_MESSG = fread_string(fl, buf);
+        }
+        break;
+        
+      default:
+        break;
+    }
+  }
+  
+  fclose(fl);
+}
diff -BENbdpru circle-3.1/src/db.h circle3.1_oasis206/src/db.h
--- circle-3.1/src/db.h	2002-02-01 01:26:52.000000000 +0100
+++ circle3.1_oasis206/src/db.h	2003-10-07 09:10:18.000000000 +0200
@@ -88,8 +88,10 @@
 #define BUG_FILE	LIB_MISC"bugs"	   /*         'bug'		*/
 #define MESS_FILE	LIB_MISC"messages" /* damage messages		*/
 #define SOCMESS_FILE	LIB_MISC"socials"  /* messages for social acts	*/
+#define SOCMESS_FILE_NEW LIB_MISC"socials.new"  /* messages for social acts with aedit patch*/
 #define XNAME_FILE	LIB_MISC"xnames"   /* invalid name substrings	*/
 
+#define CONFIG_FILE	LIB_ETC"config"    /* OasisOLC * GAME CONFIG FL */
 #define PLAYER_FILE	LIB_ETC"players"   /* the player database	*/
 #define MAIL_FILE	LIB_ETC"plrmail"   /* for the mudmail system	*/
 #define BAN_FILE	LIB_ETC"badsites"  /* for the siteban system	*/
@@ -163,6 +165,8 @@ struct reset_com {
 /* zone definition structure. for the 'zone-table'   */
 struct zone_data {
    char	*name;		    /* name of this zone                  */
+   char *builders;          /* namelist of builders allowed to    */
+                            /* modify this zone.		  */
    int	lifespan;           /* how long between resets (minutes)  */
    int	age;                /* current age of this zone (minutes) */
    room_vnum bot;           /* starting room number for this zone */
@@ -230,6 +234,8 @@ struct ban_list_element {
 /* global buffering system */
 
 #ifndef __DB_C__
+extern struct config_data config_info;
+
 extern struct room_data *world;
 extern room_rnum top_of_world;
 
@@ -248,10 +254,8 @@ extern struct index_data *obj_index;
 extern struct obj_data *object_list;
 extern struct obj_data *obj_proto;
 extern obj_rnum top_of_objt;
-#endif
 
-#ifndef __CONFIG_C__
-extern char	*OK;
-extern char	*NOPERSON;
-extern char	*NOEFFECT;
-#endif
+extern struct social_messg *soc_mess_list;
+extern int top_of_socialt;
+
+#endif /* __DB_C__ */
diff -BENbdpru circle-3.1/src/depend circle3.1_oasis206/src/depend
--- circle-3.1/src/depend	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/depend	2003-07-26 10:20:26.000000000 +0200
@@ -0,0 +1,115 @@
+act.comm.o: act.comm.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h screen.h improved-edit.h
+act.informative.o: act.informative.c conf.h sysdep.h structs.h utils.h \
+  comm.h interpreter.h handler.h db.h spells.h screen.h constants.h
+act.item.o: act.item.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h constants.h
+act.movement.o: act.movement.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h house.h constants.h
+act.offensive.o: act.offensive.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h
+act.other.o: act.other.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h screen.h house.h constants.h
+act.social.o: act.social.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h
+act.wizard.o: act.wizard.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h house.h screen.h constants.h
+alias.o: alias.c conf.h sysdep.h structs.h utils.h interpreter.h db.h
+ban.o: ban.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  handler.h db.h
+boards.o: boards.c conf.h sysdep.h structs.h utils.h comm.h db.h boards.h \
+  interpreter.h handler.h
+bsd-snprintf.o: bsd-snprintf.c conf.h sysdep.h
+castle.o: castle.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  handler.h db.h spells.h
+cedit.o: cedit.c conf.h sysdep.h structs.h comm.h interpreter.h utils.h \
+  db.h constants.h genolc.h oasis.h improved-edit.h
+class.o: class.c conf.h sysdep.h structs.h db.h utils.h spells.h \
+  interpreter.h constants.h
+comm.o: comm.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  handler.h db.h house.h oasis.h genolc.h
+config.o: config.c conf.h sysdep.h structs.h interpreter.h
+constants.o: constants.c conf.h sysdep.h structs.h interpreter.h
+db.o: db.c conf.h sysdep.h structs.h utils.h db.h comm.h handler.h \
+  spells.h mail.h interpreter.h house.h constants.h oasis.h
+fight.o: fight.c conf.h sysdep.h structs.h utils.h comm.h handler.h \
+  interpreter.h db.h spells.h screen.h constants.h
+genmob.o: genmob.c conf.h sysdep.h structs.h utils.h db.h shop.h \
+  handler.h genolc.h genmob.h genzon.h
+genobj.o: genobj.c conf.h sysdep.h structs.h utils.h db.h boards.h shop.h \
+  genolc.h genobj.h genzon.h
+genolc.o: genolc.c conf.h sysdep.h structs.h utils.h db.h handler.h \
+  comm.h shop.h oasis.h genolc.h genwld.h genmob.h genshp.h genzon.h \
+  genobj.h interpreter.h
+genshp.o: genshp.c conf.h sysdep.h structs.h utils.h db.h shop.h genolc.h \
+  genshp.h genzon.h
+genwld.o: genwld.c conf.h sysdep.h structs.h utils.h db.h handler.h \
+  comm.h genolc.h genwld.h genzon.h
+genzon.o: genzon.c conf.h sysdep.h structs.h utils.h db.h genolc.h \
+  genzon.h
+graph.o: graph.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  handler.h db.h spells.h
+handler.o: handler.c conf.h sysdep.h structs.h utils.h comm.h db.h \
+  handler.h interpreter.h spells.h
+house.o: house.c conf.h sysdep.h structs.h comm.h handler.h db.h \
+  interpreter.h utils.h house.h constants.h
+improved-edit.o: improved-edit.c conf.h sysdep.h structs.h utils.h db.h \
+  comm.h interpreter.h improved-edit.h
+interpreter.o: interpreter.c conf.h sysdep.h structs.h comm.h \
+  interpreter.h db.h utils.h spells.h handler.h mail.h screen.h genolc.h \
+  oasis.h tedit.h improved-edit.h
+limits.o: limits.c conf.h sysdep.h structs.h utils.h spells.h comm.h db.h \
+  handler.h interpreter.h
+magic.o: magic.c conf.h sysdep.h structs.h utils.h comm.h spells.h \
+  handler.h db.h interpreter.h constants.h
+mail.o: mail.c conf.h sysdep.h structs.h utils.h comm.h db.h \
+  interpreter.h handler.h mail.h
+medit.o: medit.c conf.h sysdep.h structs.h interpreter.h comm.h spells.h \
+  utils.h db.h shop.h genolc.h genmob.h genzon.h genshp.h oasis.h \
+  handler.h constants.h improved-edit.h
+mobact.o: mobact.c conf.h sysdep.h structs.h utils.h db.h comm.h \
+  interpreter.h handler.h spells.h constants.h
+modify.o: modify.c conf.h sysdep.h structs.h utils.h interpreter.h \
+  handler.h db.h comm.h spells.h mail.h boards.h improved-edit.h oasis.h \
+  tedit.h
+oasis.o: oasis.c conf.h sysdep.h structs.h utils.h interpreter.h comm.h \
+  db.h shop.h genolc.h genmob.h genshp.h genzon.h genwld.h genobj.h \
+  oasis.h screen.h
+oasis_copy.o: oasis_copy.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h genolc.h genzon.h oasis.h improved-edit.h \
+  constants.h
+oasis_delete.o: oasis_delete.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h genolc.h oasis.h improved-edit.h
+oasis_list.o: oasis_list.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h genolc.h oasis.h improved-edit.h shop.h \
+  screen.h constants.h
+objsave.o: objsave.c conf.h sysdep.h structs.h comm.h handler.h db.h \
+  interpreter.h utils.h spells.h
+oedit.o: oedit.c conf.h sysdep.h structs.h comm.h interpreter.h spells.h \
+  utils.h db.h boards.h constants.h shop.h genolc.h genobj.h genzon.h \
+  oasis.h improved-edit.h
+olc.o: olc.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  handler.h db.h olc.h
+random.o: random.c
+redit.o: redit.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  db.h boards.h genolc.h genwld.h genzon.h oasis.h improved-edit.h
+sedit.o: sedit.c conf.h sysdep.h structs.h utils.h comm.h interpreter.h \
+  db.h shop.h genolc.h genshp.h genzon.h oasis.h
+shop.o: shop.c conf.h sysdep.h structs.h comm.h handler.h db.h \
+  interpreter.h utils.h shop.h constants.h
+spec_assign.o: spec_assign.c conf.h sysdep.h structs.h db.h interpreter.h \
+  utils.h
+spec_procs.o: spec_procs.c conf.h sysdep.h structs.h utils.h comm.h \
+  interpreter.h handler.h db.h spells.h constants.h
+spell_parser.o: spell_parser.c conf.h sysdep.h structs.h utils.h \
+  interpreter.h spells.h handler.h comm.h db.h
+spells.o: spells.c conf.h sysdep.h structs.h utils.h comm.h spells.h \
+  handler.h db.h constants.h interpreter.h
+tedit.o: tedit.c conf.h sysdep.h structs.h utils.h interpreter.h comm.h \
+  db.h genolc.h oasis.h improved-edit.h tedit.h
+utils.o: utils.c conf.h sysdep.h structs.h utils.h db.h comm.h screen.h \
+  spells.h handler.h interpreter.h
+weather.o: weather.c conf.h sysdep.h structs.h utils.h comm.h handler.h \
+  interpreter.h db.h
+zedit.o: zedit.c conf.h sysdep.h structs.h comm.h interpreter.h utils.h \
+  db.h constants.h genolc.h genzon.h oasis.h
diff -BENbdpru circle-3.1/src/fight.c circle3.1_oasis206/src/fight.c
--- circle-3.1/src/fight.c	2002-03-03 06:25:26.000000000 +0100
+++ circle3.1_oasis206/src/fight.c	2003-07-26 10:19:22.000000000 +0200
@@ -28,10 +28,6 @@ struct char_data *next_combat_list = NUL
 
 /* External structures */
 extern struct message_list fight_messages[MAX_MESSAGES];
-extern int pk_allowed;		/* see config.c */
-extern int max_exp_gain;	/* see config.c */
-extern int max_exp_loss;	/* see config.c */
-extern int max_npc_corpse_time, max_pc_corpse_time;
 
 /* External procedures */
 char *fread_action(FILE *fl, int nr);
@@ -246,7 +242,7 @@ void set_fighting(struct char_data *ch, 
   FIGHTING(ch) = vict;
   GET_POS(ch) = POS_FIGHTING;
 
-  if (!pk_allowed)
+  if (!CONFIG_PK_ALLOWED)
     check_killer(ch, vict);
 }
 
@@ -296,9 +292,9 @@ void make_corpse(struct char_data *ch)
   GET_OBJ_WEIGHT(corpse) = GET_WEIGHT(ch) + IS_CARRYING_W(ch);
   GET_OBJ_RENT(corpse) = 100000;
   if (IS_NPC(ch))
-    GET_OBJ_TIMER(corpse) = max_npc_corpse_time;
+    GET_OBJ_TIMER(corpse) = CONFIG_MAX_NPC_CORPSE_TIME;
   else
-    GET_OBJ_TIMER(corpse) = max_pc_corpse_time;
+    GET_OBJ_TIMER(corpse) = CONFIG_MAX_PC_CORPSE_TIME;
 
   /* transfer character's inventory to the corpse */
   corpse->contains = ch->carrying;
@@ -390,7 +386,7 @@ void perform_group_gain(struct char_data
 {
   int share;
 
-  share = MIN(max_exp_gain, MAX(1, base));
+  share = MIN(CONFIG_MAX_EXP_GAIN, MAX(1, base));
 
   if (share > 1)
     send_to_char(ch, "You receive your share of experience -- %d points.\r\n", share);
@@ -425,7 +421,7 @@ void group_gain(struct char_data *ch, st
 
   /* prevent illegal xp creation when killing players */
   if (!IS_NPC(victim))
-    tot_gain = MIN(max_exp_loss * 2 / 3, tot_gain);
+    tot_gain = MIN(CONFIG_MAX_EXP_LOSS * 2 / 3, tot_gain);
 
   if (tot_members >= 1)
     base = MAX(1, tot_gain / tot_members);
@@ -445,7 +441,7 @@ void solo_gain(struct char_data *ch, str
 {
   int exp;
 
-  exp = MIN(max_exp_gain, GET_EXP(victim) / 3);
+  exp = MIN(CONFIG_MAX_EXP_GAIN, GET_EXP(victim) / 3);
 
   /* Calculate level-difference bonus */
   if (IS_NPC(ch))
@@ -727,7 +723,7 @@ int damage(struct char_data *ch, struct 
     dam /= 2;
 
   /* Check for PK if this is not a PK MUD */
-  if (!pk_allowed) {
+  if (!CONFIG_PK_ALLOWED) {
     check_killer(ch, victim);
     if (PLR_FLAGGED(ch, PLR_KILLER) && (ch != victim))
       dam = 0;
diff -BENbdpru circle-3.1/src/genmob.c circle3.1_oasis206/src/genmob.c
--- circle-3.1/src/genmob.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genmob.c	2003-10-07 09:12:26.000000000 +0200
@@ -0,0 +1,443 @@
+/************************************************************************
+ * Generic OLC Library - Mobiles / genmob.c			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "shop.h"
+#include "handler.h"
+#include "genolc.h"
+#include "genmob.h"
+#include "genzon.h"
+
+int update_mobile_strings(struct char_data *t, struct char_data *f);
+void check_mobile_strings(struct char_data *mob);
+void check_mobile_string(mob_vnum i, char **string, const char *dscr);
+int write_mobile_record(mob_vnum mvnum, struct char_data *mob, FILE *fd);
+int write_mobile_espec(mob_vnum mvnum, struct char_data *mob, FILE *fd);
+int free_mobile_strings(struct char_data *mob);
+int copy_mobile_strings(struct char_data *t, struct char_data *f);
+#if CONFIG_GENOLC_MOBPROG
+int write_mobile_mobprog(mob_vnum mvnum, struct char_data *mob, FILE *fd);
+#endif
+
+extern int top_shop;
+extern mob_rnum top_of_mobt;
+extern zone_rnum top_of_zone_table;
+extern struct zone_data *zone_table;
+extern struct shop_data *shop_index;
+extern struct char_data *character_list;
+extern struct char_data *mob_proto;
+extern struct index_data *mob_index;
+
+extern void smash_tilde(char *str);
+
+int add_mobile(struct char_data *mob, mob_vnum vnum)
+{
+  int rnum, i, found = FALSE, shop, cmd_no;
+  zone_rnum zone;
+  struct char_data *live_mob;
+
+  if ((rnum = real_mobile(vnum)) != NOBODY) {
+    /* Copy over the mobile and free() the old strings. */
+    copy_mobile(&mob_proto[rnum], mob);
+
+    /* Now re-point all existing mobile strings to here. */
+    for (live_mob = character_list; live_mob; live_mob = live_mob->next)
+      if (rnum == live_mob->nr)
+        update_mobile_strings(live_mob, &mob_proto[rnum]);
+
+    add_to_save_list(zone_table[real_zone_by_thing(vnum)].number, SL_MOB);
+    log("GenOLC: add_mobile: Updated existing mobile #%d.", vnum);
+    return rnum;
+  }
+
+  RECREATE(mob_proto, struct char_data, top_of_mobt + 2);
+  RECREATE(mob_index, struct index_data, top_of_mobt + 2);
+  top_of_mobt++;
+
+  for (i = top_of_mobt; i > 0; i--) {
+    if (vnum > mob_index[i - 1].vnum) {
+      mob_proto[i] = *mob;
+      mob_proto[i].nr = i;
+      copy_mobile_strings(mob_proto + i, mob);
+      mob_index[i].vnum = vnum;
+      mob_index[i].number = 0;
+      mob_index[i].func = 0;
+      found = i;
+      break;
+    }
+    mob_index[i] = mob_index[i - 1];
+    mob_proto[i] = mob_proto[i - 1];
+    mob_proto[i].nr++;
+  }
+  if (!found) {
+    mob_proto[0] = *mob;
+    mob_proto[0].nr = 0;
+    copy_mobile_strings(&mob_proto[0], mob);
+    mob_index[0].vnum = vnum;
+    mob_index[0].number = 0;
+    mob_index[0].func = 0;
+  }
+
+  log("GenOLC: add_mobile: Added mobile %d at index #%d.", vnum, found);
+
+#if CONFIG_GENOLC_MOBPROG
+  GET_MPROG(OLC_MOB(d)) = OLC_MPROGL(d);
+  GET_MPROG_TYPE(OLC_MOB(d)) = (OLC_MPROGL(d) ? OLC_MPROGL(d)->type : 0);
+  while (OLC_MPROGL(d)) {
+    GET_MPROG_TYPE(OLC_MOB(d)) |= OLC_MPROGL(d)->type;
+    OLC_MPROGL(d) = OLC_MPROGL(d)->next;
+  }
+#endif
+
+  /*
+   * Update live mobile rnums.
+   */
+  for (live_mob = character_list; live_mob; live_mob = live_mob->next)
+    GET_MOB_RNUM(live_mob) += (GET_MOB_RNUM(live_mob) >= found);
+
+  /*
+   * Update zone table.
+   */
+  for (zone = 0; zone <= top_of_zone_table; zone++)
+    for (cmd_no = 0; ZCMD(zone, cmd_no).command != 'S'; cmd_no++)
+      if (ZCMD(zone, cmd_no).command == 'M')
+	ZCMD(zone, cmd_no).arg1 += (ZCMD(zone, cmd_no).arg1 >= found);
+
+  /*
+   * Update shop keepers.
+   */
+  if (shop_index)
+    for (shop = 0; shop <= top_shop - top_shop_offset; shop++)
+      SHOP_KEEPER(shop) += (SHOP_KEEPER(shop) >= found);
+
+  add_to_save_list(zone_table[real_zone_by_thing(vnum)].number, SL_MOB);
+  return found;
+}
+
+int copy_mobile(struct char_data *to, struct char_data *from)
+{
+  free_mobile_strings(to);
+  *to = *from;
+  check_mobile_strings(from);
+  copy_mobile_strings(to, from);
+  return TRUE;
+}
+
+void extract_mobile_all(mob_vnum vnum)
+{
+  struct char_data *next, *ch;
+
+  for (ch = character_list; ch; ch = next) {
+    next = ch->next;
+    if (GET_MOB_VNUM(ch) == vnum)
+      extract_char(ch);
+  }
+}
+
+int delete_mobile(mob_rnum refpt)
+{
+  struct char_data *live_mob;
+  int counter, cmd_no;
+  mob_vnum vnum;
+  zone_rnum zone;
+  
+#if CIRCLE_UNSIGNED_INDEX
+  if (refpt == NOBODY || refpt > top_of_mobt) {
+#else
+  if (refpt < 0 || refpt > top_of_mobt) {
+#endif
+    log("SYSERR: GenOLC: delete_mobile: Invalid rnum %d.", refpt);
+    return NOBODY;
+  }
+
+  vnum = mob_index[refpt].vnum;
+  add_to_save_list(zone_table[real_zone_by_thing(vnum)].number, SL_MOB);
+  extract_mobile_all(vnum);
+  free_mobile_strings(&mob_proto[refpt]);
+
+  for (counter = refpt; counter < top_of_mobt; counter++) {
+    mob_index[counter] = mob_index[counter + 1];
+    mob_proto[counter] = mob_proto[counter + 1];
+    mob_proto[counter].nr--;
+  }
+
+  top_of_mobt--;
+  RECREATE(mob_index, struct index_data, top_of_mobt + 1);
+  RECREATE(mob_proto, struct char_data, top_of_mobt + 1);
+
+  /*
+   * Update live mobile rnums.
+   */
+  for (live_mob = character_list; live_mob; live_mob = live_mob->next)
+    GET_MOB_RNUM(live_mob) -= (GET_MOB_RNUM(live_mob) >= refpt);
+
+  /*
+   * Update zone table.
+   */
+  for (zone = 0; zone <= top_of_zone_table; zone++)
+    for (cmd_no = 0; ZCMD(zone, cmd_no).command != 'S'; cmd_no++)
+      if (ZCMD(zone, cmd_no).command == 'M')
+	ZCMD(zone, cmd_no).arg1 -= (ZCMD(zone, cmd_no).arg1 >= refpt);
+
+  /*
+   * Update shop keepers.
+   */
+  if (shop_index)
+    for (counter = 0; counter <= top_shop - top_shop_offset; counter++)
+      SHOP_KEEPER(counter) -= (SHOP_KEEPER(counter) >= refpt);
+
+  return refpt;
+}
+
+int copy_mobile_strings(struct char_data *t, struct char_data *f)
+{
+  if (f->player.name)
+    t->player.name = strdup(f->player.name);
+  if (f->player.title)
+    t->player.title = strdup(f->player.title);
+  if (f->player.short_descr)
+    t->player.short_descr = strdup(f->player.short_descr);
+  if (f->player.long_descr)
+    t->player.long_descr = strdup(f->player.long_descr);
+  if (f->player.description)
+    t->player.description = strdup(f->player.description);
+  return TRUE;
+}
+
+int update_mobile_strings(struct char_data *t, struct char_data *f)
+{
+  if (f->player.name)
+    t->player.name = f->player.name;
+  if (f->player.title)
+    t->player.title = f->player.title;
+  if (f->player.short_descr)
+    t->player.short_descr = f->player.short_descr;
+  if (f->player.long_descr)
+    t->player.long_descr = f->player.long_descr;
+  if (f->player.description)
+    t->player.description = f->player.description;
+  return TRUE;
+}
+
+int free_mobile_strings(struct char_data *mob)
+{
+  if (mob->player.name)
+    free(mob->player.name);
+  if (mob->player.title)
+    free(mob->player.title);
+  if (mob->player.short_descr)
+    free(mob->player.short_descr);
+  if (mob->player.long_descr)
+    free(mob->player.long_descr);
+  if (mob->player.description)
+    free(mob->player.description);
+  return TRUE;
+}
+
+/*
+ * Free a mobile structure that has been edited.
+ * Take care of existing mobiles and their mob_proto!
+ */
+int free_mobile(struct char_data *mob)
+{
+  mob_rnum i;
+
+  if (mob == NULL)
+    return FALSE;
+
+  /*
+   * Non-prototyped mobile.  Also known as new mobiles.
+   */
+  if ((i = GET_MOB_RNUM(mob)) == NOBODY)
+    free_mobile_strings(mob);
+  else {	/* Prototyped mobile. */
+    if (mob->player.name && mob->player.name != mob_proto[i].player.name)
+      free(mob->player.name);
+    if (mob->player.title && mob->player.title != mob_proto[i].player.title)
+      free(mob->player.title);
+    if (mob->player.short_descr &&
+      mob->player.short_descr != mob_proto[i].player.short_descr)
+      free(mob->player.short_descr);
+    if (mob->player.long_descr &&
+      mob->player.long_descr != mob_proto[i].player.long_descr)
+      free(mob->player.long_descr);
+    if (mob->player.description &&
+      mob->player.description != mob_proto[i].player.description)
+      free(mob->player.description);
+  }
+  while (mob->affected)
+    affect_remove(mob, mob->affected);
+
+  free(mob);
+  return TRUE;
+}
+
+int save_mobiles(zone_rnum rznum)
+{
+  zone_vnum vznum;
+  FILE *mobfd;
+  room_vnum i;
+  mob_rnum rmob;
+  int written;
+  char mobfname[64], usedfname[64];
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (rznum == NOWHERE || rznum > top_of_zone_table) {
+#else
+  if (rznum < 0 || rznum > top_of_zone_table) {
+#endif
+    log("SYSERR: GenOLC: save_mobiles: Invalid real zone number %d. (0-%d)",
+      rznum, top_of_zone_table);
+    return FALSE;
+  }
+
+  vznum = zone_table[rznum].number;
+  snprintf(mobfname, sizeof(mobfname), "%s%d.new", MOB_PREFIX, vznum);
+  if ((mobfd = fopen(mobfname, "w")) == NULL) {
+    mudlog(BRF, LVL_GOD, TRUE,
+      "SYSERR: GenOLC: Cannot open mob file for writing.");
+    return FALSE;
+  }
+
+  for (i = genolc_zone_bottom(rznum); i <= zone_table[rznum].top; i++) {
+    if ((rmob = real_mobile(i)) == NOBODY)
+      continue;
+    check_mobile_strings(&mob_proto[rmob]);
+    if (write_mobile_record(i, &mob_proto[rmob], mobfd) < 0)
+      log("SYSERR: GenOLC: Error writing mobile #%d.", i);
+  }
+  fputs("$\n", mobfd);
+  written = ftell(mobfd);
+  fclose(mobfd);
+  snprintf(usedfname, sizeof(usedfname), "%s%d.mob", MOB_PREFIX, vznum);
+  remove(usedfname);
+  rename(mobfname, usedfname);
+  
+  if (in_save_list(vznum, SL_MOB))
+    remove_from_save_list(vznum, SL_MOB);
+  log("GenOLC: '%s' saved, %d bytes written.", usedfname, written);
+  return written;
+}
+
+#if CONFIG_GENOLC_MOBPROG
+int write_mobile_mobprog(mob_vnum mvnum, struct char_data *mob, FILE *fd)
+{
+  char wmmarg[MAX_STRING_LENGTH], wmmcom[MAX_STRING_LENGTH];
+  MPROG_DATA *mob_prog;
+
+  for (mob_prog = GET_MPROG(mob); mob_prog; mob_prog = mob_prog->next) {
+    wmmarg[MAX_STRING_LENGTH - 1] = '\0';
+    wmmcom[MAX_STRING_LENGTH - 1] = '\0';
+    strip_cr(strncpy(wmmarg, mob_prog->arglist, MAX_STRING_LENGTH - 1));
+    strip_cr(strncpy(wmmcom, mob_prog->comlist, MAX_STRING_LENGTH - 1));
+    fprintf(fd,	"%s %s~\n"
+		"%s%c\n",
+	medit_get_mprog_type(mob_prog), wmmarg,
+	wmmcom, STRING_TERMINATOR
+    );
+    if (mob_prog->next == NULL)
+      fputs("|\n", fd);
+  }
+  return TRUE;
+}
+#endif
+
+int write_mobile_espec(mob_vnum mvnum, struct char_data *mob, FILE *fd)
+{
+  if (GET_ATTACK(mob) != 0)
+    fprintf(fd, "BareHandAttack: %d\n", GET_ATTACK(mob));
+  if (GET_STR(mob) != 11)
+    fprintf(fd, "Str: %d\n", GET_STR(mob));
+  if (GET_ADD(mob) != 0)
+    fprintf(fd, "StrAdd: %d\n", GET_ADD(mob));
+  if (GET_DEX(mob) != 11)
+    fprintf(fd, "Dex: %d\n", GET_DEX(mob));
+  if (GET_INT(mob) != 11)
+    fprintf(fd, "Int: %d\n", GET_INT(mob));
+  if (GET_WIS(mob) != 11)
+    fprintf(fd, "Wis: %d\n", GET_WIS(mob));
+  fputs("E\n", fd);
+  return TRUE;
+}
+
+
+int write_mobile_record(mob_vnum mvnum, struct char_data *mob, FILE *fd)
+{
+
+  char bit1[64]; 
+  char bit2[64];
+  char ldesc[MAX_STRING_LENGTH];
+  char ddesc[MAX_STRING_LENGTH];
+
+  ldesc[MAX_STRING_LENGTH - 1] = '\0';
+  ddesc[MAX_STRING_LENGTH - 1] = '\0';
+  strip_cr(strncpy(ldesc, GET_LDESC(mob), MAX_STRING_LENGTH - 1));
+  strip_cr(strncpy(ddesc, GET_DDESC(mob), MAX_STRING_LENGTH - 1));
+
+  fprintf(fd,	"#%d\n"
+		"%s%c\n"
+		"%s%c\n"
+		"%s%c\n"
+		"%s%c\n",
+	mvnum,
+	GET_ALIAS(mob), STRING_TERMINATOR,
+	GET_SDESC(mob), STRING_TERMINATOR,
+	ldesc, STRING_TERMINATOR,
+	ddesc, STRING_TERMINATOR
+  );
+
+  sprintascii(bit1, MOB_FLAGS(mob));
+  sprintascii(bit2, AFF_FLAGS(mob));
+
+  fprintf(fd,	"%s %s %d E\n"
+		"%d %d %d %dd%d+%d %dd%d+%d\n",
+		bit1, bit2, GET_ALIGNMENT(mob),
+		GET_LEVEL(mob), 20 - GET_HITROLL(mob), GET_AC(mob) / 10, GET_HIT(mob),
+		GET_MANA(mob), GET_MOVE(mob), GET_NDD(mob), GET_SDD(mob),
+		GET_DAMROLL(mob)
+  );
+  fprintf(fd, 	"%d %d\n"
+		"%d %d %d\n",
+		GET_GOLD(mob), GET_EXP(mob),
+		GET_POS(mob), GET_DEFAULT_POS(mob), GET_SEX(mob)
+  );
+
+  if (write_mobile_espec(mvnum, mob, fd) < 0)
+    log("SYSERR: GenOLC: Error writing E-specs for mobile #%d.", mvnum);
+
+#if CONFIG_GENOLC_MOBPROG
+  if (write_mobile_mobprog(mvnum, mob, fd) < 0)
+    log("SYSERR: GenOLC: Error writing MobProgs for mobile #%d.", mvnum);
+#endif
+
+  return TRUE;
+}
+
+void check_mobile_strings(struct char_data *mob)
+{
+  mob_vnum mvnum = mob_index[mob->nr].vnum;
+  check_mobile_string(mvnum, &GET_LDESC(mob), "long description");
+  check_mobile_string(mvnum, &GET_DDESC(mob), "detailed description");
+  check_mobile_string(mvnum, &GET_ALIAS(mob), "alias list");
+  check_mobile_string(mvnum, &GET_SDESC(mob), "short description");
+}
+
+void check_mobile_string(mob_vnum i, char **string, const char *dscr)
+{
+  if (*string == NULL || **string == '\0') {
+    char smbuf[128];
+    sprintf(smbuf, "GenOLC: Mob #%d has an invalid %s.", i, dscr);
+    mudlog(BRF, LVL_GOD, TRUE, smbuf);
+    if (*string)
+      free(*string);
+    *string = strdup("An undefined string.");
+  }
+}
diff -BENbdpru circle-3.1/src/genmob.h circle3.1_oasis206/src/genmob.h
--- circle-3.1/src/genmob.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genmob.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,23 @@
+/************************************************************************
+ * Generic OLC Library - Mobiles / genmob.h			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+int delete_mobile(mob_rnum);
+int copy_mobile(struct char_data *to, struct char_data *from);
+int add_mobile(struct char_data *, mob_vnum);
+int copy_mob_strings(struct char_data *to, struct char_data *from);
+int free_mob_strings(struct char_data *);
+int free_mobile(struct char_data *mob);
+int save_mobiles(zone_rnum rznum);
+void extract_mobile_all(mob_vnum vnum);
+
+/* Handy macros. */
+#define GET_NDD(mob)	((mob)->mob_specials.damnodice)
+#define GET_SDD(mob)	((mob)->mob_specials.damsizedice)
+#define GET_ALIAS(mob)	((mob)->player.name)
+#define GET_SDESC(mob)	((mob)->player.short_descr)
+#define GET_LDESC(mob)	((mob)->player.long_descr)
+#define GET_DDESC(mob)	((mob)->player.description)
+#define GET_ATTACK(mob)	((mob)->mob_specials.attack_type)
diff -BENbdpru circle-3.1/src/genobj.c circle3.1_oasis206/src/genobj.c
--- circle-3.1/src/genobj.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genobj.c	2003-10-07 09:14:40.000000000 +0200
@@ -0,0 +1,418 @@
+/************************************************************************
+ * Generic OLC Library - Objects / genobj.c			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "boards.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genobj.h"
+#include "genzon.h"
+
+static int copy_object_main(struct obj_data *to, struct obj_data *from, int free_object);
+
+extern struct obj_data *obj_proto;
+extern struct obj_data *object_list;
+extern struct index_data *obj_index;
+extern struct zone_data *zone_table;
+extern struct board_info_type board_info[];
+extern struct shop_data *shop_index;
+extern zone_rnum top_of_zone_table;
+extern obj_rnum top_of_objt;
+extern int top_shop;
+
+obj_rnum add_object(struct obj_data *newobj, obj_vnum ovnum)
+{
+  int found = NOTHING;
+  zone_rnum rznum = real_zone_by_thing(ovnum);
+
+  /*
+   * Write object to internal tables.
+   */
+  if ((newobj->item_number = real_object(ovnum)) != NOTHING) {
+    copy_object(&obj_proto[newobj->item_number], newobj);
+    update_objects(&obj_proto[newobj->item_number]);
+    add_to_save_list(zone_table[rznum].number, SL_OBJ);
+    return newobj->item_number;
+  }
+
+  found = insert_object(newobj, ovnum);
+  adjust_objects(found);
+  add_to_save_list(zone_table[rznum].number, SL_OBJ);
+  return found;
+}
+
+/* ------------------------------------------------------------------------------------------------------------------------------ */
+
+/*
+ * Fix all existing objects to have these values.
+ * We need to run through each and every object currently in the
+ * game to see which ones are pointing to this prototype.
+ * if object is pointing to this prototype, then we need to replace it
+ * with the new one.
+ */
+int update_objects(struct obj_data *refobj)
+{
+  struct obj_data *obj, swap;
+  int count = 0;
+
+  for (obj = object_list; obj; obj = obj->next) {
+    if (obj->item_number != refobj->item_number)
+      continue;
+
+    count++;
+
+    /* Update the existing object but save a copy for private information. */
+    swap = *obj;
+    *obj = *refobj;
+
+    /* Copy game-time dependent variables over. */
+    IN_ROOM(obj) = swap.in_room;
+    obj->carried_by = swap.carried_by;
+    obj->worn_by = swap.worn_by;
+    obj->worn_on = swap.worn_on;
+    obj->in_obj = swap.in_obj;
+    obj->contains = swap.contains;
+    obj->next_content = swap.next_content;
+    obj->next = swap.next;
+  }
+
+  return count;
+}
+
+/* ------------------------------------------------------------------------------------------------------------------------------ */
+
+/*
+ * Adjust the internal values of other objects as if something was inserted at the given array index.
+ * Might also be useful to make 'holes' in the array for some reason.
+ */
+obj_rnum adjust_objects(obj_rnum refpt)
+{
+  int shop, i, zone, cmd_no;
+  struct obj_data *obj;
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (refpt == NOTHING || refpt > top_of_objt)
+#else
+  if (refpt < 0 || refpt > top_of_objt)
+#endif
+    return NOTHING;
+
+  /*
+   * Renumber live objects.
+   */
+  for (obj = object_list; obj; obj = obj->next)
+    GET_OBJ_RNUM(obj) += (GET_OBJ_RNUM(obj) >= refpt);
+
+  /*
+   * Renumber zone table.
+   */
+  for (zone = 0; zone <= top_of_zone_table; zone++) {
+    for (cmd_no = 0; ZCMD(zone, cmd_no).command != 'S'; cmd_no++) {
+      switch (ZCMD(zone, cmd_no).command) {
+      case 'P':
+        ZCMD(zone, cmd_no).arg3 += (ZCMD(zone, cmd_no).arg3 >= refpt);
+         /*
+          * No break here - drop into next case.
+          */
+      case 'O':
+      case 'G':
+      case 'E':
+        ZCMD(zone, cmd_no).arg1 += (ZCMD(zone, cmd_no).arg1 >= refpt);
+        break;
+      case 'R':
+        ZCMD(zone, cmd_no).arg2 += (ZCMD(zone, cmd_no).arg2 >= refpt);
+        break;
+      }
+    }
+  }
+
+  /*
+   * Renumber notice boards.
+   */
+  for (i = 0; i < NUM_OF_BOARDS; i++)
+    BOARD_RNUM(i) += (BOARD_RNUM(i) >= refpt);
+
+  /*
+   * Renumber shop produce.
+   */
+  for (shop = 0; shop <= top_shop - top_shop_offset; shop++)
+    for (i = 0; SHOP_PRODUCT(shop, i) != NOTHING; i++)
+      SHOP_PRODUCT(shop, i) += (SHOP_PRODUCT(shop, i) >= refpt);
+
+  return refpt;
+}
+
+/* ------------------------------------------------------------------------------------------------------------------------------ */
+
+/*
+ * Function handle the insertion of an object within the prototype framework.  Note that this does not adjust internal values
+ * of other objects, use add_object() for that.
+ */
+obj_rnum insert_object(struct obj_data *obj, obj_vnum ovnum)
+{
+  obj_rnum i;
+
+  top_of_objt++;
+  RECREATE(obj_index, struct index_data, top_of_objt + 1);
+  RECREATE(obj_proto, struct obj_data, top_of_objt + 1);
+
+  /*
+   * Start counting through both tables.
+   */
+  for (i = top_of_objt; i > 0; i--) {
+    /*
+     * Check if current virtual is bigger than our virtual number.
+     */
+    if (ovnum > obj_index[i - 1].vnum)
+      return index_object(obj, ovnum, i);
+
+    /* Copy over the object that should be here. */
+    obj_index[i] = obj_index[i - 1];
+    obj_proto[i] = obj_proto[i - 1];
+    obj_proto[i].item_number = i;
+  }
+
+  /* Not found, place at 0. */
+  return index_object(obj, ovnum, 0);
+}
+
+/* ------------------------------------------------------------------------------------------------------------------------------ */
+
+obj_rnum index_object(struct obj_data *obj, obj_vnum ovnum, obj_rnum ornum)
+{
+#if CIRCLE_UNSIGNED_INDEX
+  if (obj == NULL || ornum == NOTHING || ornum > top_of_objt)
+#else
+  if (obj == NULL || ovnum < 0 || ornum < 0 || ornum > top_of_objt)
+#endif
+    return NOWHERE;
+
+  obj->item_number = ornum;
+  obj_index[ornum].vnum = ovnum;
+  obj_index[ornum].number = 0;
+  obj_index[ornum].func = NULL;
+
+  copy_object_preserve(&obj_proto[ornum], obj);
+  obj_proto[ornum].in_room = NOWHERE;
+
+  return ornum;
+}
+
+/* ------------------------------------------------------------------------------------------------------------------------------ */
+
+int save_objects(zone_rnum zone_num)
+{
+  char fname[128], buf[MAX_STRING_LENGTH], bit1[64], bit2[64];
+  int counter, counter2, realcounter;
+  FILE *fp;
+  struct obj_data *obj;
+  struct extra_descr_data *ex_desc;
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (zone_num == NOWHERE || zone_num > top_of_zone_table) {
+#else
+  if (zone_num < 0 || zone_num > top_of_zone_table) {
+#endif
+    log("SYSERR: GenOLC: save_objects: Invalid real zone number %d. (0-%d)", zone_num, top_of_zone_table);
+    return FALSE;
+  }
+
+  snprintf(fname, sizeof(fname), "%s/%d.new", OBJ_PREFIX, zone_table[zone_num].number);
+  if (!(fp = fopen(fname, "w+"))) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: OLC: Cannot open objects file %s!", fname);
+    return FALSE;
+  }
+  /*
+   * Start running through all objects in this zone.
+   */
+  for (counter = genolc_zone_bottom(zone_num); counter <= zone_table[zone_num].top; counter++) {
+    if ((realcounter = real_object(counter)) != NOTHING) {
+      if ((obj = &obj_proto[realcounter])->action_description) {
+	strncpy(buf, obj->action_description, sizeof(buf) - 1);
+	strip_cr(buf);
+      } else
+	*buf = '\0';
+
+      fprintf(fp,
+	      "#%d\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n",
+
+	      GET_OBJ_VNUM(obj),
+	      (obj->name && *obj->name) ? obj->name : "undefined",
+	      (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
+	      (obj->description && *obj->description) ?	obj->description : "undefined",
+	      buf);
+
+      sprintascii(buf, GET_OBJ_EXTRA(obj));
+      sprintascii(bit1, GET_OBJ_WEAR(obj));
+      sprintascii(bit2, GET_OBJ_PERM(obj));
+
+      fprintf(fp,
+	      "%d %s %s %s\n"
+	      "%d %d %d %d\n"
+	      "%d %d %d %d\n",
+
+	      GET_OBJ_TYPE(obj), buf, bit1, bit2,
+	      GET_OBJ_VAL(obj, 0), GET_OBJ_VAL(obj, 1), GET_OBJ_VAL(obj, 2), GET_OBJ_VAL(obj, 3),
+	      GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj)
+      );
+
+      /*
+       * Do we have extra descriptions? 
+       */
+      if (obj->ex_description) {	/* Yes, save them too. */
+	for (ex_desc = obj->ex_description; ex_desc; ex_desc = ex_desc->next) {
+	  /*
+	   * Sanity check to prevent nasty protection faults.
+	   */
+	  if (!ex_desc->keyword || !ex_desc->description || !*ex_desc->keyword || !*ex_desc->description) {
+	    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: OLC: oedit_save_to_disk: Corrupt ex_desc!");
+	    continue;
+	  }
+	  strncpy(buf, ex_desc->description, sizeof(buf) - 1);
+	  strip_cr(buf);
+	  fprintf(fp, "E\n"
+		  "%s~\n"
+		  "%s~\n", ex_desc->keyword, buf);
+	}
+      }
+      /*
+       * Do we have affects? 
+       */
+      for (counter2 = 0; counter2 < MAX_OBJ_AFFECT; counter2++)
+	if (obj->affected[counter2].modifier)
+	  fprintf(fp, "A\n"
+		  "%d %d\n", obj->affected[counter2].location,
+		  obj->affected[counter2].modifier);
+    }
+  }
+
+  /*
+   * Write the final line, close the file.
+   */
+  fprintf(fp, "$~\n");
+  fclose(fp);
+  snprintf(buf, sizeof(buf), "%s/%d.obj", OBJ_PREFIX, zone_table[zone_num].number);
+  remove(buf);
+  rename(fname, buf);
+
+  if (in_save_list(zone_table[zone_num].number, SL_OBJ))
+    remove_from_save_list(zone_table[zone_num].number, SL_OBJ);
+  return TRUE;
+}
+
+/*
+ * Free all, unconditionally.
+ */
+void free_object_strings(struct obj_data *obj)
+{
+#if 0 /* Debugging, do not enable. */
+  extern struct obj_data *object_list;
+  struct obj_data *t;
+  int i = 0;
+
+  for (t = object_list; t; t = t->next) {
+    if (t == obj) {
+      i++;
+      continue;
+    }
+    assert(obj->name != t->name);
+    assert(obj->description != t->description);
+    assert(obj->short_description != t->short_description);
+    assert(obj->action_description != t->action_description);
+    assert(obj->ex_description != t->ex_description);
+  }
+  assert(i <= 1);
+#endif
+
+  if (obj->name)
+    free(obj->name);
+  if (obj->description)
+    free(obj->description);
+  if (obj->short_description)
+    free(obj->short_description);
+  if (obj->action_description)
+    free(obj->action_description);
+  if (obj->ex_description)
+    free_ex_descriptions(obj->ex_description);
+}
+
+/*
+ * For object instances that are not the prototype.
+ */
+void free_object_strings_proto(struct obj_data *obj)
+{
+  int robj_num = GET_OBJ_RNUM(obj);
+
+  if (obj->name && obj->name != obj_proto[robj_num].name)
+    free(obj->name);
+  if (obj->description && obj->description != obj_proto[robj_num].description)
+    free(obj->description);
+  if (obj->short_description && obj->short_description != obj_proto[robj_num].short_description)
+    free(obj->short_description);
+  if (obj->action_description && obj->action_description != obj_proto[robj_num].action_description)
+    free(obj->action_description);
+  if (obj->ex_description) {
+    struct extra_descr_data *thised, *plist, *next_one; /* O(horrible) */
+    int ok_key, ok_desc, ok_item;
+    for (thised = obj->ex_description; thised; thised = next_one) {
+      next_one = thised->next;
+      for (ok_item = ok_key = ok_desc = 1, plist = obj_proto[robj_num].ex_description; plist; plist = plist->next) {
+        if (plist->keyword == thised->keyword)
+          ok_key = 0;
+        if (plist->description == thised->description)
+          ok_desc = 0;
+        if (plist == thised)
+          ok_item = 0;
+      }
+      if (thised->keyword && ok_key)
+        free(thised->keyword);
+      if (thised->description && ok_desc)
+        free(thised->description);
+      if (ok_item)
+        free(thised);
+    }
+  }
+}
+
+void copy_object_strings(struct obj_data *to, struct obj_data *from)
+{
+  to->name = from->name ? strdup(from->name) : NULL;
+  to->description = from->description ? strdup(from->description) : NULL;
+  to->short_description = from->short_description ? strdup(from->short_description) : NULL;
+  to->action_description = from->action_description ? strdup(from->action_description) : NULL;
+
+  if (from->ex_description)
+    copy_ex_descriptions(&to->ex_description, from->ex_description);
+  else
+    to->ex_description = NULL;
+}
+
+int copy_object(struct obj_data *to, struct obj_data *from)
+{
+  free_object_strings(to);
+  return copy_object_main(to, from, TRUE);
+}
+
+int copy_object_preserve(struct obj_data *to, struct obj_data *from)
+{
+  return copy_object_main(to, from, FALSE);
+}
+
+static int copy_object_main(struct obj_data *to, struct obj_data *from, int free_object)
+{
+  *to = *from;
+  copy_object_strings(to, from);
+  return TRUE;
+}
diff -BENbdpru circle-3.1/src/genobj.h circle3.1_oasis206/src/genobj.h
--- circle-3.1/src/genobj.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genobj.h	2003-10-07 09:14:38.000000000 +0200
@@ -0,0 +1,19 @@
+/************************************************************************
+ * Generic OLC Library - Objects / genobj.h			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+void copy_object_strings(struct obj_data *to, struct obj_data *from);
+void free_object_strings(struct obj_data *obj);
+void free_object_strings_proto(struct obj_data *obj);
+int copy_object(struct obj_data *to, struct obj_data *from);
+int copy_object_preserve(struct obj_data *to, struct obj_data *from);
+int save_objects(zone_rnum vznum);
+obj_rnum insert_object(struct obj_data *obj, obj_vnum ovnum);
+obj_rnum adjust_objects(obj_rnum refpt);
+obj_rnum index_object(struct obj_data *obj, obj_vnum ovnum, obj_rnum ornum);
+int update_objects(struct obj_data *refobj);
+obj_rnum add_object(struct obj_data *, obj_vnum ovnum);
+
diff -BENbdpru circle-3.1/src/genolc.c circle3.1_oasis206/src/genolc.c
--- circle-3.1/src/genolc.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genolc.c	2003-10-07 09:25:34.000000000 +0200
@@ -0,0 +1,380 @@
+/************************************************************************
+ * Generic OLC Library - General / genolc.c			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#define __GENOLC_C__
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "handler.h"
+#include "comm.h"
+#include "shop.h"
+#include "oasis.h"
+#include "genolc.h"
+#include "genwld.h"
+#include "genmob.h"
+#include "genshp.h"
+#include "genzon.h"
+#include "genobj.h"
+
+extern struct zone_data *zone_table;
+extern zone_rnum top_of_zone_table;
+extern struct room_data *world;
+extern struct char_data *mob_proto;
+extern struct index_data *mob_index;
+
+int save_config( IDXTYPE nowhere );        /* Exported from cedit.c */
+
+/* Adjustment for top_shop change between bpl15 and bpl16. */
+#if _CIRCLEMUD < CIRCLEMUD_VERSION(3,0,16)
+int top_shop_offset = 1;
+#else
+int top_shop_offset = 0;
+#endif
+
+/*
+ * List of zones to be saved.
+ */
+struct save_list_data *save_list;
+
+/*
+ * Structure defining all known save types.
+ */
+struct {
+  int save_type;
+  int (*func)(IDXTYPE rnum);
+  const char *message;
+} save_types[] = {
+  { SL_MOB, save_mobiles , "mobile" },
+  { SL_OBJ, save_objects, "object" },
+  { SL_SHP, save_shops, "shop" },
+  { SL_WLD, save_rooms, "room" },
+  { SL_ZON, save_zone, "zone" },
+  { SL_CFG, save_config, "config" },
+  { SL_ACTION, NULL, "social" },
+  { -1, NULL, NULL },
+};
+
+/* -------------------------------------------------------------------------- */
+
+int genolc_checkstring(struct descriptor_data *d, char *arg)
+{
+  smash_tilde(arg);
+  return TRUE;
+}
+
+char *str_udup(const char *txt)
+{
+  return strdup((txt && *txt) ? txt : "undefined");
+}
+
+/*
+ * Original use: to be called at shutdown time.
+ */
+int save_all(void)
+{
+  while (save_list) {
+    if (save_list->type < 0 || save_list->type > SL_MAX) {
+      if (save_list->type == SL_ACTION) {
+        log("Actions not saved - can not autosave. Use 'aedit save'.");
+        save_list = save_list->next;	/* Fatal error, skip this one. */
+      } else
+        log("SYSERR: GenOLC: Invalid save type %d in save list.\n", save_list->type);
+    } else if ((*save_types[save_list->type].func)(real_zone(save_list->zone)) < 0)
+      save_list = save_list->next;	/* Fatal error, skip this one. */
+  }
+
+  return TRUE;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * NOTE: This changes the buffer passed in.
+ */
+void strip_cr(char *buffer)
+{
+  int rpos, wpos;
+
+  if (buffer == NULL)
+    return;
+
+  for (rpos = 0, wpos = 0; buffer[rpos]; rpos++) {
+    buffer[wpos] = buffer[rpos];
+    wpos += (buffer[rpos] != '\r');
+  }
+  buffer[wpos] = '\0';
+}
+
+/* -------------------------------------------------------------------------- */
+
+void copy_ex_descriptions(struct extra_descr_data **to, struct extra_descr_data *from)
+{
+  struct extra_descr_data *wpos;
+
+  CREATE(*to, struct extra_descr_data, 1);
+  wpos = *to;
+
+  for (; from; from = from->next, wpos = wpos->next) {
+    wpos->keyword = str_udup(from->keyword);
+    wpos->description = str_udup(from->description);
+    if (from->next)
+      CREATE(wpos->next, struct extra_descr_data, 1);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+
+void free_ex_descriptions(struct extra_descr_data *head)
+{
+  struct extra_descr_data *thised, *next_one;
+
+  if (!head) {
+    log("free_ex_descriptions: NULL pointer or NULL data.");
+    return;
+  }
+
+  for (thised = head; thised; thised = next_one) {
+    next_one = thised->next;
+    if (thised->keyword)
+      free(thised->keyword);
+    if (thised->description)
+      free(thised->description);
+    free(thised);
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+
+int remove_from_save_list(zone_vnum zone, int type)
+{
+  struct save_list_data *ritem, *temp;
+
+  for (ritem = save_list; ritem; ritem = ritem->next)
+    if (ritem->zone == zone && ritem->type == type)
+      break;
+
+  if (ritem == NULL) {
+    log("SYSERR: remove_from_save_list: Saved item not found. (%d/%d)", zone, type);
+    return FALSE;
+  }
+  REMOVE_FROM_LIST(ritem, save_list, next);
+  free(ritem);
+  return TRUE;
+}
+
+/* -------------------------------------------------------------------------- */
+
+int add_to_save_list(zone_vnum zone, int type)
+{
+  struct save_list_data *nitem;
+  zone_rnum rznum;
+  
+  if (type == SL_CFG)
+    return FALSE; 
+    
+  rznum = real_zone(zone);
+  if (rznum == NOWHERE || rznum > top_of_zone_table) {
+    if (zone != AEDIT_PERMISSION) {
+      log("SYSERR: add_to_save_list: Invalid zone number passed. (%d => %d, 0-%d)", zone, rznum, top_of_zone_table);
+      return FALSE;
+    }
+  }
+  
+  for (nitem = save_list; nitem; nitem = nitem->next)
+    if (nitem->zone == zone && nitem->type == type)
+      return FALSE;
+  
+  CREATE(nitem, struct save_list_data, 1);
+  nitem->zone = zone;
+  nitem->type = type;
+  nitem->next = save_list;
+  save_list = nitem;
+  return TRUE;
+}
+
+/* -------------------------------------------------------------------------- */
+
+int in_save_list(zone_vnum zone, int type)
+{
+  struct save_list_data *nitem;
+  
+  for (nitem = save_list; nitem; nitem = nitem->next)
+    if (nitem->zone == zone && nitem->type == type)
+      return TRUE;
+  
+  return FALSE;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Used from do_show(), ideally.
+ */
+void do_show_save_list(struct char_data *ch)
+{
+  if (save_list == NULL)
+    send_to_char(ch, "All world files are up to date.\r\n");
+  else {
+    struct save_list_data *item;
+
+    send_to_char(ch, "The following files need saving:\r\n");
+    for (item = save_list; item; item = item->next) {
+      if (item->type != SL_CFG)
+        send_to_char(ch, " - %s data for zone %d.\r\n", save_types[item->type].message, item->zone);
+      else
+        send_to_char(ch, " - Game configuration data.\r\n");
+    }
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * TEST FUNCTION! Not meant to be pretty!
+ *
+ * edit q	- Query unsaved files.
+ * edit a	- Save all.
+ * edit r1204 c	- Copies current room to 1204.
+ * edit r1204 d	- Deletes room 1204.
+ * edit r12 s	- Saves rooms in zone 12.
+ * edit m3000 c3001	- Copies mob 3000 to 3001.
+ * edit m3000 d	- Deletes mob 3000.
+ * edit m30 s	- Saves mobiles in zone 30.
+ * edit o186 s	- Saves objects in zone 186.
+ * edit s25 s	- Saves shops in zone 25.
+ * edit z31 s	- Saves zone 31.
+ */
+#include "interpreter.h"
+ACMD(do_edit);
+ACMD(do_edit)
+{
+  int idx, num, mun;
+  char a[MAX_INPUT_LENGTH], b[MAX_INPUT_LENGTH];
+
+  two_arguments(argument, a, b);
+  num = atoi(a + 1);
+  mun = atoi(b + 1);
+  switch (a[0]) {
+  case 'a':
+    save_all();
+    break;
+  case 'm':
+    switch (b[0]) {
+    case 'd':
+      if ((idx = real_mobile(num)) != NOBODY) {
+	delete_mobile(idx);	/* Delete -> Real */
+	send_to_char(ch, "%s", CONFIG_OK);
+      } else
+	send_to_char(ch, "What mobile?\r\n");
+      break;
+    case 's':
+      save_mobiles(num);
+      break;
+    case 'c':
+      if ((num = real_mobile(num)) == NOBODY)
+	send_to_char(ch, "What mobile?\r\n");
+      else if ((mun = real_mobile(mun)) == NOBODY)
+	send_to_char(ch, "Can only copy over an existing mob.\r\n");
+      else {
+        /* Otherwise the old ones have dangling string pointers. */
+        extract_mobile_all(mob_index[mun].vnum);
+        /* To <- From */
+	copy_mobile(mob_proto + mun, mob_proto + num);
+	send_to_char(ch, "%s", CONFIG_OK);
+      }
+      break;
+    }
+    break;
+  case 's':
+    switch (b[0]) {
+    case 's':
+      save_objects(real_zone(num));
+      break;
+    }
+    break;
+  case 'z':
+    switch (b[0]) {
+    case 's':
+      save_zone(real_zone(num));
+      break;
+    }
+    break;
+  case 'o':
+    switch (b[0]) {
+    case 's':
+      save_objects(real_zone(num));
+      break;
+    }
+    break;
+  case 'r':
+    switch (b[0]) {
+    case 'd':
+      if ((idx = real_room(num)) != NOWHERE) {
+	delete_room(idx);
+	send_to_char(ch, "%s", CONFIG_OK);
+      } else
+	send_to_char(ch, "What room?\r\n");
+      break;
+    case 's':
+      save_rooms(real_zone(num));
+      break;
+    case 'c':
+      duplicate_room(num, IN_ROOM(ch));	/* To -> Virtual, From -> Real */
+      break;
+    }
+  case 'q':
+    do_show_save_list(ch);
+    break;
+  default:
+    send_to_char(ch, "What?\r\n");
+    break;
+  }
+}
+
+/* -------------------------------------------------------------------------- */
+
+room_vnum genolc_zonep_bottom(struct zone_data *zone)
+{
+#if _CIRCLEMUD < CIRCLEMUD_VERSION(3,0,21)
+  return zone->number * 100;
+#else
+  return zone->bot;
+#endif
+}
+
+zone_vnum genolc_zone_bottom(zone_rnum rznum)
+{
+#if _CIRCLEMUD < CIRCLEMUD_VERSION(3,0,21)
+  return zone_table[rznum].number * 100;
+#else /* bpl21+ */
+  return zone_table[rznum].bot;
+#endif
+}
+
+/* -------------------------------------------------------------------------- */
+
+int sprintascii(char *out, bitvector_t bits)
+{
+  int i, j = 0;
+  /* 32 bits, don't just add letters to try to get more unless your bitvector_t is also as large. */
+  char *flags = "abcdefghijklmnopqrstuvwxyzABCDEF";
+
+  for (i = 0; flags[i] != '\0'; i++)
+    if (bits & (1 << i))
+      out[j++] = flags[i];
+
+  if (j == 0) /* Didn't write anything. */
+    out[j++] = '0';
+
+  /* NUL terminate the output string. */
+  out[j++] = '\0';
+  return j;
+}
diff -BENbdpru circle-3.1/src/genolc.h circle3.1_oasis206/src/genolc.h
--- circle-3.1/src/genolc.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genolc.h	2003-10-07 09:25:32.000000000 +0200
@@ -0,0 +1,65 @@
+/************************************************************************
+ * Generic OLC Library - General / genolc.h			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#if !defined(_CIRCLEMUD) || !defined(CIRCLEMUD_VERSION)
+# error "This version of GenOLC only supports CircleMUD 3.0 bpl15 or later."
+#else
+# if _CIRCLEMUD < CIRCLEMUD_VERSION(3,0,15)
+#  error "This version of GenOLC only supports CircleMUD 3.0 bpl15 or later."
+# endif
+#endif
+
+#define STRING_TERMINATOR       '~'
+
+#define CONFIG_GENOLC_MOBPROG	0
+
+#ifndef LVL_BUILDER
+#define LVL_BUILDER	LVL_GOD
+#endif
+
+/* from modify.c */
+void smash_tilde(char *str);
+int genolc_checkstring(struct descriptor_data *d, char *arg);
+
+int remove_from_save_list(zone_vnum, int type);
+int add_to_save_list(zone_vnum, int type);
+int in_save_list(zone_vnum, int type);
+void strip_cr(char *);
+void do_show_save_list(struct char_data *);
+int save_all(void);
+char *str_udup(const char *);
+void copy_ex_descriptions(struct extra_descr_data **to, struct extra_descr_data *from);
+void free_ex_descriptions(struct extra_descr_data *head);
+int sprintascii(char *out, bitvector_t bits);
+
+struct save_list_data {
+  int zone;
+  int type;
+  struct save_list_data *next;
+};
+
+extern struct save_list_data *save_list;
+extern int top_shop_offset;
+
+/* save_list_data.type */
+#define SL_MOB	0
+#define SL_OBJ	1
+#define SL_SHP	2
+#define SL_WLD	3
+#define SL_ZON	4
+#define SL_CFG	5
+#define SL_MAX	5
+#define SL_ACTION 100 /* must be above MAX */
+
+
+#define ZCMD(zon, cmds)	zone_table[(zon)].cmd[(cmds)]
+
+#define LIMIT(var, low, high)	MIN(high, MAX(var, low))
+
+room_vnum genolc_zone_bottom(zone_rnum rznum);
+room_vnum genolc_zonep_bottom(struct zone_data *zone);
+
diff -BENbdpru circle-3.1/src/genshp.c circle3.1_oasis206/src/genshp.c
--- circle-3.1/src/genshp.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genshp.c	2003-10-07 09:25:32.000000000 +0200
@@ -0,0 +1,548 @@
+/************************************************************************
+ * Generic OLC Library - Shops / genshp.c			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genshp.h"
+#include "genzon.h"
+
+extern struct index_data *mob_index;
+extern struct index_data *obj_index;
+extern struct shop_data *shop_index;
+extern struct zone_data *zone_table;
+extern int top_shop;
+extern zone_rnum top_of_zone_table;
+
+/*
+ * NOTE (gg): Didn't modify sedit much. Don't consider it as 'recent'
+ * 	as the other editors with regard to updates or style.
+ */
+
+/*-------------------------------------------------------------------*/
+
+void copy_shop(struct shop_data *tshop, struct shop_data *fshop)
+{
+  /*
+   * Copy basic information over.
+   */
+  S_NUM(tshop) = S_NUM(fshop);
+  S_KEEPER(tshop) = S_KEEPER(fshop);
+  S_OPEN1(tshop) = S_OPEN1(fshop);
+  S_CLOSE1(tshop) = S_CLOSE1(fshop);
+  S_OPEN2(tshop) = S_OPEN2(fshop);
+  S_CLOSE2(tshop) = S_CLOSE2(fshop);
+  S_BANK(tshop) = S_BANK(fshop);
+  S_BROKE_TEMPER(tshop) = S_BROKE_TEMPER(fshop);
+  S_BITVECTOR(tshop) = S_BITVECTOR(fshop);
+  S_NOTRADE(tshop) = S_NOTRADE(fshop);
+  S_SORT(tshop) = S_SORT(fshop);
+  S_BUYPROFIT(tshop) = S_BUYPROFIT(fshop);
+  S_SELLPROFIT(tshop) = S_SELLPROFIT(fshop);
+  S_FUNC(tshop) = S_FUNC(fshop);
+
+  /*
+   * Copy lists over.
+   */
+  copy_list(&(S_ROOMS(tshop)), S_ROOMS(fshop));
+  copy_list(&(S_PRODUCTS(tshop)), S_PRODUCTS(fshop));
+  copy_type_list(&(tshop->type), fshop->type);
+
+  /*
+   * Copy notification strings over.
+   */
+  free_shop_strings(tshop);
+  S_NOITEM1(tshop) = str_udup(S_NOITEM1(fshop));
+  S_NOITEM2(tshop) = str_udup(S_NOITEM2(fshop));
+  S_NOCASH1(tshop) = str_udup(S_NOCASH1(fshop));
+  S_NOCASH2(tshop) = str_udup(S_NOCASH2(fshop));
+  S_NOBUY(tshop) = str_udup(S_NOBUY(fshop));
+  S_BUY(tshop) = str_udup(S_BUY(fshop));
+  S_SELL(tshop) = str_udup(S_SELL(fshop));
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Copy a 'NOTHING' terminated integer array list.
+ */
+void copy_list(IDXTYPE **tlist, IDXTYPE *flist)
+{
+  int num_items, i;
+
+  if (*tlist)
+    free(*tlist);
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; flist[i] != NOTHING; i++);
+  num_items = i + 1;
+
+  /*
+   * Make space for entries.
+   */
+  CREATE(*tlist, IDXTYPE, num_items);
+
+  /*
+   * Copy entries over.
+   */
+  for (i = 0; i < num_items; i++)
+    (*tlist)[i] = flist[i];
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Copy a -1 terminated (in the type field) shop_buy_data 
+ * array list.
+ */
+void copy_type_list(struct shop_buy_data **tlist, struct shop_buy_data *flist)
+{
+  int num_items, i;
+
+  if (*tlist)
+    free_type_list(tlist);
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; BUY_TYPE(flist[i]) != NOTHING; i++);
+  num_items = i + 1;
+
+  /*
+   * Make space for entries.
+   */
+  CREATE(*tlist, struct shop_buy_data, num_items);
+
+  /*
+   * Copy entries over.
+   */
+  for (i = 0; i < num_items; i++) {
+    (*tlist)[i].type = flist[i].type;
+    if (BUY_WORD(flist[i]))
+      BUY_WORD((*tlist)[i]) = strdup(BUY_WORD(flist[i]));
+  }
+}
+
+/*-------------------------------------------------------------------*/
+
+void remove_from_type_list(struct shop_buy_data **list, int num)
+{
+  int i, num_items;
+  struct shop_buy_data *nlist;
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; (*list)[i].type != NOTHING; i++);
+
+  if (num < 0 || num >= i)
+    return;
+  num_items = i;
+
+  CREATE(nlist, struct shop_buy_data, num_items);
+
+  for (i = 0; i < num_items; i++)
+    nlist[i] = (i < num) ? (*list)[i] : (*list)[i + 1];
+
+  free(BUY_WORD((*list)[num]));
+  free(*list);
+  *list = nlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+void add_to_type_list(struct shop_buy_data **list, struct shop_buy_data *newl)
+{
+  int i, num_items;
+  struct shop_buy_data *nlist;
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; (*list)[i].type != NOTHING; i++);
+  num_items = i;
+
+  /*
+   * Make a new list and slot in the new entry.
+   */
+  CREATE(nlist, struct shop_buy_data, num_items + 2);
+
+  for (i = 0; i < num_items; i++)
+    nlist[i] = (*list)[i];
+  nlist[num_items] = *newl;
+  nlist[num_items + 1].type = NOTHING;
+
+  /*
+   * Out with the old, in with the new.
+   */
+  free(*list);
+  *list = nlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+void add_to_int_list(IDXTYPE **list, IDXTYPE newi)
+{
+  IDXTYPE i, num_items, *nlist;
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; (*list)[i] != NOTHING; i++);
+  num_items = i;
+
+  /*
+   * Make a new list and slot in the new entry.
+   */
+  CREATE(nlist, IDXTYPE, num_items + 2);
+
+  for (i = 0; i < num_items; i++)
+    nlist[i] = (*list)[i];
+  nlist[num_items] = newi;
+  nlist[num_items + 1] = NOTHING;
+
+  /*
+   * Out with the old, in with the new.
+   */
+  free(*list);
+  *list = nlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+void remove_from_int_list(IDXTYPE **list, IDXTYPE num)
+{
+  IDXTYPE i, num_items, *nlist;
+
+  /*
+   * Count number of entries.
+   */
+  for (i = 0; (*list)[i] != NOTHING; i++);
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (num >= i)
+#else
+  if (num < 0 || num >= i)
+#endif
+    return;
+  num_items = i;
+
+  CREATE(nlist, IDXTYPE, num_items);
+
+  for (i = 0; i < num_items; i++)
+    nlist[i] = (i < num) ? (*list)[i] : (*list)[i + 1];
+
+  free(*list);
+  *list = nlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Free all the notice character strings in a shop structure.
+ */
+void free_shop_strings(struct shop_data *shop)
+{
+  if (S_NOITEM1(shop)) {
+    free(S_NOITEM1(shop));
+    S_NOITEM1(shop) = NULL;
+  }
+  if (S_NOITEM2(shop)) {
+    free(S_NOITEM2(shop));
+    S_NOITEM2(shop) = NULL;
+  }
+  if (S_NOCASH1(shop)) {
+    free(S_NOCASH1(shop));
+    S_NOCASH1(shop) = NULL;
+  }
+  if (S_NOCASH2(shop)) {
+    free(S_NOCASH2(shop));
+    S_NOCASH2(shop) = NULL;
+  }
+  if (S_NOBUY(shop)) {
+    free(S_NOBUY(shop));
+    S_NOBUY(shop) = NULL;
+  }
+  if (S_BUY(shop)) {
+    free(S_BUY(shop));
+    S_BUY(shop) = NULL;
+  }
+  if (S_SELL(shop)) {
+    free(S_SELL(shop));
+    S_SELL(shop) = NULL;
+  }
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Free a type list and all the strings it contains.
+ */
+void free_type_list(struct shop_buy_data **list)
+{
+  int i;
+
+  for (i = 0; (*list)[i].type != NOTHING; i++)
+    if (BUY_WORD((*list)[i]))
+      free(BUY_WORD((*list)[i]));
+
+  free(*list);
+  *list = NULL;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Free up the whole shop structure and it's content.
+ */
+void free_shop(struct shop_data *shop)
+{
+  free_shop_strings(shop);
+  free_type_list(&(S_NAMELISTS(shop)));
+  free(S_ROOMS(shop));
+  free(S_PRODUCTS(shop));
+  free(shop);
+}
+
+/*-------------------------------------------------------------------*/
+
+/* returns the real number of the shop with given virtual number 
+ *
+ * We take so good care to keep it sorted - let's use it :) - Welcor
+ */
+shop_rnum real_shop(shop_vnum vnum)
+{
+  shop_rnum bot, top, mid;
+
+  bot = 0;
+  top = top_shop - top_shop_offset;
+
+  /* perform binary search on shop_table */
+  for (;;) {
+    mid = (bot + top) / 2;
+
+    if (SHOP_NUM(mid) == vnum)
+      return (mid);
+    if (bot >= top)
+      return (NOWHERE);
+    if (SHOP_NUM(mid) > vnum)
+      top = mid - 1;
+    else
+      bot = mid + 1;
+  }
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Generic string modifier for shop keeper messages.
+ */
+void modify_string(char **str, char *new_s)
+{
+
+  char buf[MAX_STRING_LENGTH];
+  char *pointer;
+
+  /*
+   * Check the '%s' is present, if not, add it.
+   */
+  if (*new_s != '%') {
+    snprintf(buf, sizeof(buf), "%%s %s", new_s);
+    pointer = buf;
+  } else
+    pointer = new_s;
+
+  if (*str)
+    free(*str);
+  *str = strdup(pointer);
+}
+
+/*-------------------------------------------------------------------*/
+
+int add_shop(struct shop_data *nshp)
+{
+  shop_rnum rshop;
+  int found = 0;
+  zone_rnum rznum = real_zone_by_thing(S_NUM(nshp));
+
+  /*
+   * The shop already exists, just update it.
+   */
+  if ((rshop = real_shop(S_NUM(nshp))) != NOWHERE) {
+    copy_shop(&shop_index[rshop], nshp);
+    if (rznum != NOWHERE)
+      add_to_save_list(zone_table[rznum].number, SL_SHP);
+    else
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: GenOLC: Cannot determine shop zone.");
+    return rshop;
+  }
+
+  top_shop++;
+  RECREATE(shop_index, struct shop_data, top_shop - top_shop_offset + 1);
+
+  for (rshop = top_shop - top_shop_offset; rshop > 0; rshop--) {
+    if (nshp->vnum > SHOP_NUM(rshop - 1)) {
+      found = rshop;
+
+      /* Make a "nofree" variant and remove these later. */
+      shop_index[rshop].in_room = NULL;
+      shop_index[rshop].producing = NULL;
+      shop_index[rshop].type = NULL;
+
+      copy_shop(&shop_index[rshop], nshp);
+      break;
+    }
+    shop_index[rshop] = shop_index[rshop - 1];
+  }
+
+  if (!found) {
+    /* Make a "nofree" variant and remove these later. */
+    shop_index[rshop].in_room = NULL;
+    shop_index[rshop].producing = NULL;
+    shop_index[rshop].type = NULL;
+
+    copy_shop(&shop_index[0], nshp);
+  }
+
+  if (rznum != NOWHERE)
+    add_to_save_list(zone_table[rznum].number, SL_SHP);
+  else
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: GenOLC: Cannot determine shop zone.");
+
+  return rshop;
+}
+
+/*-------------------------------------------------------------------*/
+
+int save_shops(zone_rnum zone_num)
+{
+  int i, j, rshop;
+  FILE *shop_file;
+  char fname[128], oldname[128];
+  struct shop_data *shop;
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (zone_num == NOWHERE || zone_num > top_of_zone_table) {
+#else
+  if (zone_num < 0 || zone_num > top_of_zone_table) {
+#endif
+    log("SYSERR: GenOLC: save_shops: Invalid real zone number %d. (0-%d)", zone_num, top_of_zone_table);
+    return FALSE;
+  }
+
+  snprintf(fname, sizeof(fname), "%s/%d.new", SHP_PREFIX, zone_table[zone_num].number);
+  if (!(shop_file = fopen(fname, "w"))) {
+    mudlog(BRF, LVL_GOD, TRUE, "SYSERR: OLC: Cannot open shop file!");
+    return FALSE;
+  } else if (fprintf(shop_file, "CircleMUD v3.0 Shop File~\n") < 0) {
+    mudlog(BRF, LVL_GOD, TRUE, "SYSERR: OLC: Cannot write to shop file!");
+    fclose(shop_file);
+    return FALSE;
+  }
+  /*
+   * Search database for shops in this zone.
+   */
+  for (i = genolc_zone_bottom(zone_num); i <= zone_table[zone_num].top; i++) {
+    if ((rshop = real_shop(i)) != NOWHERE) {
+      fprintf(shop_file, "#%d~\n", i);
+      shop = shop_index + rshop;
+
+      /*
+       * Save the products.
+       */
+      for (j = 0; S_PRODUCT(shop, j) != NOTHING; j++)
+	fprintf(shop_file, "%d\n", obj_index[S_PRODUCT(shop, j)].vnum);
+      fprintf(shop_file, "-1\n");
+
+      /*
+       * Save the rates.
+       */
+      fprintf(shop_file, "%1.2f\n"
+                         "%1.2f\n",
+                         S_BUYPROFIT(shop),
+                         S_SELLPROFIT(shop));
+
+      /*
+       * Save the buy types and namelists.
+       */
+      for (j = 0;S_BUYTYPE(shop, j) != NOTHING; j++) 
+        fprintf(shop_file, "%d%s\n", 
+                S_BUYTYPE(shop, j),
+		S_BUYWORD(shop, j) ? S_BUYWORD(shop, j) : "");
+      fprintf(shop_file, "-1\n");
+#if 0
+      j = -1;
+      do {
+	j++;
+	fprintf(shop_file, "%d%s\n", 
+	        S_BUYTYPE(shop, j) != NOTHING ? S_BUYTYPE(shop, j) : -1,
+		S_BUYWORD(shop, j) ? S_BUYWORD(shop, j) : "");
+      } while (S_BUYTYPE(shop, j) != NOTHING);
+#endif
+/* Not allowed to use Ascii in shopfile anymore (bpl21)
+      sprintascii(buf1, S_BITVECTOR(shop));
+      sprintascii(buf2, S_NOTRADE(shop));
+*/
+
+      /*
+       * Save messages'n'stuff.
+       * Added some small'n'silly defaults as sanity checks.
+       */
+      fprintf(shop_file,
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%s~\n"
+	      "%d\n"
+	      "%ld\n"
+	      "%d\n"
+	      "%d\n",
+	      S_NOITEM1(shop) ? S_NOITEM1(shop) : "%s Ke?!",
+	      S_NOITEM2(shop) ? S_NOITEM2(shop) : "%s Ke?!",
+	      S_NOBUY(shop) ? S_NOBUY(shop) : "%s Ke?!",
+	      S_NOCASH1(shop) ? S_NOCASH1(shop) : "%s Ke?!",
+	      S_NOCASH2(shop) ? S_NOCASH2(shop) : "%s Ke?!",
+	      S_BUY(shop) ? S_BUY(shop) : "%s Ke?! %d?",
+	      S_SELL(shop) ? S_SELL(shop) : "%s Ke?! %d?",
+	      S_BROKE_TEMPER(shop),
+	      S_BITVECTOR(shop),
+	      S_KEEPER(shop) == NOBODY ? -1 : mob_index[S_KEEPER(shop)].vnum,
+	      S_NOTRADE(shop)
+	      );
+
+      /*
+       * Save the rooms.
+       */
+      for (j = 0;S_ROOM(shop, j) != NOWHERE; j++) 
+        fprintf(shop_file, "%d\n", S_ROOM(shop, j));
+      fprintf(shop_file, "-1\n");
+
+      /*
+       * Save open/closing times 
+       */
+      fprintf(shop_file, "%d\n%d\n%d\n%d\n", S_OPEN1(shop), S_CLOSE1(shop),
+		S_OPEN2(shop), S_CLOSE2(shop));
+    }
+  }
+  fprintf(shop_file, "$~\n");
+  fclose(shop_file);
+  snprintf(oldname, sizeof(oldname), "%s/%d.shp", SHP_PREFIX, zone_table[zone_num].number);
+  remove(oldname);
+  rename(fname, oldname);
+
+  if (in_save_list(zone_table[zone_num].number, SL_SHP))
+    remove_from_save_list(zone_table[zone_num].number, SL_SHP);
+  return TRUE;
+}
diff -BENbdpru circle-3.1/src/genshp.h circle3.1_oasis206/src/genshp.h
--- circle-3.1/src/genshp.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genshp.h	2003-10-07 09:26:28.000000000 +0200
@@ -0,0 +1,55 @@
+/************************************************************************
+ * Generic OLC Library - Shops / genshp.h			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+void copy_shop(struct shop_data *tshop, struct shop_data *fshop);
+void copy_list(IDXTYPE **tlist, IDXTYPE *flist);
+void copy_type_list(struct shop_buy_data **tlist, struct shop_buy_data *flist);
+void remove_from_type_list(struct shop_buy_data **list, int num);
+void remove_from_int_list(IDXTYPE **list, IDXTYPE num);
+void add_to_type_list(struct shop_buy_data **list, struct shop_buy_data *newl);
+void add_to_int_list(IDXTYPE **tlist, IDXTYPE newi);
+void free_shop_string(struct shop_data *shop);
+void free_type_list(struct shop_buy_data **list);
+void free_shop(struct shop_data *shop);
+void free_shop_strings(struct shop_data *shop);
+void modify_string(char **str, char *newstr);
+int add_shop(struct shop_data *shop);
+int save_shops(zone_rnum zone_num);
+shop_rnum real_shop(shop_vnum vnum);
+
+/*
+ * Handy macros.
+ */
+#define S_NUM(i)		((i)->vnum)
+#define S_KEEPER(i)		((i)->keeper)
+#define S_OPEN1(i)		((i)->open1)
+#define S_CLOSE1(i)		((i)->close1)
+#define S_OPEN2(i)		((i)->open2)
+#define S_CLOSE2(i)		((i)->close2)
+#define S_BANK(i)		((i)->bankAccount)
+#define S_BROKE_TEMPER(i)	((i)->temper1)
+#define S_BITVECTOR(i)		((i)->bitvector)
+#define S_NOTRADE(i)		((i)->with_who)
+#define S_SORT(i)		((i)->lastsort)
+#define S_BUYPROFIT(i)		((i)->profit_buy)
+#define S_SELLPROFIT(i)		((i)->profit_sell)
+#define S_FUNC(i)		((i)->func)
+
+#define S_ROOMS(i)		((i)->in_room)
+#define S_PRODUCTS(i)		((i)->producing)
+#define S_NAMELISTS(i)		((i)->type)
+#define S_ROOM(i, num)		((i)->in_room[(num)])
+#define S_PRODUCT(i, num)	((i)->producing[(num)])
+#define S_BUYTYPE(i, num)	(BUY_TYPE((i)->type[(num)]))
+#define S_BUYWORD(i, num)	(BUY_WORD((i)->type[(num)]))
+
+#define S_NOITEM1(i)		((i)->no_such_item1)
+#define S_NOITEM2(i)		((i)->no_such_item2)
+#define S_NOCASH1(i)		((i)->missing_cash1)
+#define S_NOCASH2(i)		((i)->missing_cash2)
+#define S_NOBUY(i)		((i)->do_not_buy)
+#define S_BUY(i)		((i)->message_buy)
+#define S_SELL(i)		((i)->message_sell)
diff -BENbdpru circle-3.1/src/genwld.c circle3.1_oasis206/src/genwld.c
--- circle-3.1/src/genwld.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genwld.c	2003-10-07 09:55:16.000000000 +0200
@@ -0,0 +1,502 @@
+/************************************************************************
+ * Generic OLC Library - Rooms / genwld.c			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "handler.h"
+#include "comm.h"
+#include "genolc.h"
+#include "genwld.h"
+#include "genzon.h"
+
+extern struct room_data *world;
+extern struct zone_data *zone_table;
+extern struct index_data *mob_index;
+extern zone_rnum top_of_zone_table;
+extern room_rnum r_mortal_start_room;
+extern room_rnum r_immort_start_room;
+extern room_rnum r_frozen_start_room;
+
+/*
+ * This function will copy the strings so be sure you free your own
+ * copies of the description, title, and such.
+ */
+room_rnum add_room(struct room_data *room)
+{
+  struct char_data *tch;
+  struct obj_data *tobj;
+  int j, found = FALSE;
+  room_rnum i;
+
+  if (room == NULL)
+    return NOWHERE;
+
+  if ((i = real_room(room->number)) != NOWHERE) {
+    copy_room(&world[i], room);
+    add_to_save_list(zone_table[room->zone].number, SL_WLD);
+    log("GenOLC: add_room: Updated existing room #%d.", room->number);
+    return i;
+  }
+
+  RECREATE(world, struct room_data, top_of_world + 2);
+  top_of_world++;
+
+  for (i = top_of_world; i > 0; i--) {
+    if (room->number > world[i - 1].number) {
+      world[i] = *room;
+      copy_room_strings(&world[i], room);
+      found = i;
+      break;
+    } else {
+      /* Copy the room over now. */
+      world[i] = world[i - 1];
+
+      /* People in this room must have their in_rooms moved up one. */
+      for (tch = world[i].people; tch; tch = tch->next_in_room)
+	IN_ROOM(tch) += (IN_ROOM(tch) != NOWHERE);
+
+      /* Move objects too. */
+      for (tobj = world[i].contents; tobj; tobj = tobj->next_content)
+	IN_ROOM(tobj) += (IN_ROOM(tobj) != NOWHERE);
+    }
+  }
+  if (!found) {
+    world[0] = *room;	/* Last place, in front. */
+    copy_room_strings(&world[0], room);
+  }
+
+  log("GenOLC: add_room: Added room %d at index #%d.", room->number, found);
+
+  /* found is equal to the array index where we added the room. */
+
+  /*
+   * Find what zone that room was in so we can update the loading table.
+   */
+  for (i = room->zone; i <= top_of_zone_table; i++)
+    for (j = 0; ZCMD(i, j).command != 'S'; j++)
+      switch (ZCMD(i, j).command) {
+      case 'M':
+      case 'O':
+	ZCMD(i, j).arg3 += (ZCMD(i, j).arg3 != NOWHERE && ZCMD(i, j).arg3 >= found);
+	break;
+      case 'D':
+      case 'R':
+	ZCMD(i, j).arg1 += (ZCMD(i, j).arg1 != NOWHERE && ZCMD(i, j).arg1 >= found);
+      case 'G':
+      case 'P':
+      case 'E':
+      case '*':
+	/* Known zone entries we don't care about. */
+        break;
+      default:
+        mudlog(BRF, LVL_GOD, TRUE, "SYSERR: GenOLC: add_room: Unknown zone entry found!");
+      }
+      
+  /*
+   * Update the loadroom table. Adds 1 or 0.
+   */
+  r_mortal_start_room += (r_mortal_start_room >= found);
+  r_immort_start_room += (r_immort_start_room >= found);
+  r_frozen_start_room += (r_frozen_start_room >= found);
+
+  /*
+   * Update world exits.
+   */
+  /* changed to do-while to work with unsigned index w/o warnings */
+  i = top_of_world + 1;
+  do {
+    i--;
+    for (j = 0; j < NUM_OF_DIRS; j++)
+      if (W_EXIT(i, j) && W_EXIT(i, j)->to_room != NOWHERE)
+	W_EXIT(i, j)->to_room += (W_EXIT(i, j)->to_room >= found);
+  } while (i > 0);
+
+  add_to_save_list(zone_table[room->zone].number, SL_WLD);
+
+  /*
+   * Return what array entry we placed the new room in.
+   */
+  return found;
+}
+
+/* -------------------------------------------------------------------------- */
+
+int delete_room(room_rnum rnum)
+{
+  room_rnum i;
+  int j;
+  struct char_data *ppl, *next_ppl;
+  struct obj_data *obj, *next_obj;
+  struct room_data *room;
+
+  if (rnum <= 0 || rnum > top_of_world)	/* Can't delete void yet. */
+    return FALSE;
+
+  room = &world[rnum];
+
+  add_to_save_list(zone_table[room->zone].number, SL_WLD);
+
+  /* This is something you might want to read about in the logs. */
+  log("GenOLC: delete_room: Deleting room #%d (%s).", room->number, room->name);
+
+  if (r_mortal_start_room == rnum) {
+    log("WARNING: GenOLC: delete_room: Deleting mortal start room!");
+    r_mortal_start_room = 0;	/* The Void */
+  }
+  if (r_immort_start_room == rnum) {
+    log("WARNING: GenOLC: delete_room: Deleting immortal start room!");
+    r_immort_start_room = 0;	/* The Void */
+  }
+  if (r_frozen_start_room == rnum) {
+    log("WARNING: GenOLC: delete_room: Deleting frozen start room!");
+    r_frozen_start_room = 0;	/* The Void */
+  }
+
+  /*
+   * Dump the contents of this room into the Void.  We could also just
+   * extract the people, mobs, and objects here.
+   */
+  for (obj = world[rnum].contents; obj; obj = next_obj) {
+    next_obj = obj->next_content;
+    obj_from_room(obj);
+    obj_to_room(obj, 0);
+  }
+  for (ppl = world[rnum].people; ppl; ppl = next_ppl) {
+    next_ppl = ppl->next_in_room;
+    char_from_room(ppl);
+    char_to_room(ppl, 0);
+  }
+
+  free_room_strings(room);
+
+  /*
+   * Change any exit going to this room to go the void.
+   * Also fix all the exits pointing to rooms above this.
+   */
+  i = top_of_world + 1;
+  do {
+    i--;
+    for (j = 0; j < NUM_OF_DIRS; j++)
+      if (W_EXIT(i, j) == NULL)
+        continue;
+      else if (W_EXIT(i, j)->to_room > rnum)
+        W_EXIT(i, j)->to_room -= (W_EXIT(i, j)->to_room != NOWHERE); /* with unsigned NOWHERE > any rnum */
+      else if (W_EXIT(i, j)->to_room == rnum) {
+      	if ((!W_EXIT(i, j)->keyword || !*W_EXIT(i, j)->keyword) &&
+      	    (!W_EXIT(i, j)->general_description || !*W_EXIT(i, j)->general_description)) {
+          /* no description, remove exit completely */
+          if (W_EXIT(i, j)->keyword)
+            free(W_EXIT(i, j)->keyword);
+          if (W_EXIT(i, j)->general_description)
+            free(W_EXIT(i, j)->general_description);
+          free(W_EXIT(i, j));
+          W_EXIT(i, j) = NULL;
+        } else { 
+          /* description is set, just point to nowhere */
+          W_EXIT(i, j)->to_room = NOWHERE;
+        }
+      }
+  } while (i > 0);
+
+  /*
+   * Find what zone that room was in so we can update the loading table.
+   */
+  for (i = 0; i <= top_of_zone_table; i++)
+    for (j = 0; ZCMD(i , j).command != 'S'; j++)
+      switch (ZCMD(i, j).command) {
+      case 'M':
+      case 'O':
+	if (ZCMD(i, j).arg3 == rnum)
+	  ZCMD(i, j).command = '*';	/* Cancel command. */
+	else if (ZCMD(i, j).arg3 > rnum)
+	  ZCMD(i, j).arg3 -= (ZCMD(i, j).arg3 != NOWHERE); /* with unsigned NOWHERE > any rnum */
+	break;
+      case 'D':
+      case 'R':
+	if (ZCMD(i, j).arg1 == rnum)
+	  ZCMD(i, j).command = '*';	/* Cancel command. */
+	else if (ZCMD(i, j).arg1 > rnum)
+	  ZCMD(i, j).arg1 -= (ZCMD(i, j).arg1 != NOWHERE); /* with unsigned NOWHERE > any rnum */
+      case 'G':
+      case 'P':
+      case 'E':
+      case '*':
+        /* Known zone entries we don't care about. */
+        break;
+      default:
+        mudlog(BRF, LVL_GOD, TRUE, "SYSERR: GenOLC: delete_room: Unknown zone entry found!");
+      }
+
+  /*
+   * Now we actually move the rooms down.
+   */
+  for (i = rnum; i < top_of_world; i++) {
+    world[i] = world[i + 1];
+
+    for (ppl = world[i].people; ppl; ppl = ppl->next_in_room)
+      IN_ROOM(ppl) -= (IN_ROOM(ppl) != NOWHERE);	/* Redundant check? */
+
+    for (obj = world[i].contents; obj; obj = obj->next_content)
+      IN_ROOM(obj) -= (IN_ROOM(obj) != NOWHERE);	/* Redundant check? */
+  }
+
+  top_of_world--;
+  RECREATE(world, struct room_data, top_of_world + 1);
+
+  return TRUE;
+}
+
+
+int save_rooms(zone_rnum rzone)
+{
+  int i;
+  struct room_data *room;
+  FILE *sf;
+  char filename[128];
+  char buf[MAX_STRING_LENGTH];
+  char buf1[MAX_STRING_LENGTH];
+  char bit[64];
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (rzone == NOWHERE || rzone > top_of_zone_table) {
+#else
+  if (rzone < 0 || rzone > top_of_zone_table) {
+#endif
+    log("SYSERR: GenOLC: save_rooms: Invalid zone number %d passed! (0-%d)", rzone, top_of_zone_table);
+    return FALSE;
+  }
+
+  log("GenOLC: save_rooms: Saving rooms in zone #%d (%d-%d).",
+	zone_table[rzone].number, genolc_zone_bottom(rzone), zone_table[rzone].top);
+
+  snprintf(filename, sizeof(filename), "%s/%d.new", WLD_PREFIX, zone_table[rzone].number);
+  if (!(sf = fopen(filename, "w"))) {
+    perror("SYSERR: save_rooms");
+    return FALSE;
+  }
+
+  for (i = genolc_zone_bottom(rzone); i <= zone_table[rzone].top; i++) {
+    room_rnum rnum;
+
+    if ((rnum = real_room(i)) != NOWHERE) {
+      int j;
+
+      room = (world + rnum);
+
+      /*
+       * Copy the description and strip off trailing newlines.
+       */
+      strncpy(buf, room->description ? room->description : "Empty room.", sizeof(buf)-1 );
+      strip_cr(buf);
+
+      /*
+       * Save the numeric and string section of the file.
+       */
+      sprintascii(bit, room->room_flags);
+      fprintf(sf, 	"#%d\n"
+			"%s%c\n"
+			"%s%c\n"
+			"%d %s %d\n",
+		room->number,
+		room->name ? room->name : "Untitled", STRING_TERMINATOR,
+		buf, STRING_TERMINATOR,
+		zone_table[room->zone].number, bit, room->sector_type
+      );
+
+      /*
+       * Now you write out the exits for the room.
+       */
+      for (j = 0; j < NUM_OF_DIRS; j++) {
+	if (R_EXIT(room, j)) {
+	  int dflag;
+	  if (R_EXIT(room, j)->general_description) {
+	    strncpy(buf, R_EXIT(room, j)->general_description, sizeof(buf)-1);
+	    strip_cr(buf);
+	  } else
+	    *buf = '\0';
+
+	  /*
+	   * Figure out door flag.
+	   */
+	  if (IS_SET(R_EXIT(room, j)->exit_info, EX_ISDOOR)) {
+	    if (IS_SET(R_EXIT(room, j)->exit_info, EX_PICKPROOF))
+	      dflag = 2;
+	    else
+	      dflag = 1;
+	  } else
+	    dflag = 0;
+
+	  if (R_EXIT(room, j)->keyword)
+	    strncpy(buf1, R_EXIT(room, j)->keyword, sizeof(buf1)-1 );
+	  else
+	    *buf1 = '\0';
+
+	  /*
+	   * Now write the exit to the file.
+	   */
+	  fprintf(sf,	"D%d\n"
+			"%s~\n"
+			"%s~\n"
+			"%d %d %d\n", j, buf, buf1, dflag,
+		R_EXIT(room, j)->key != NOTHING ? R_EXIT(room, j)->key : -1,
+		R_EXIT(room, j)->to_room != NOWHERE ? world[R_EXIT(room, j)->to_room].number : -1);
+
+	}
+      }
+
+      if (room->ex_description) {
+        struct extra_descr_data *xdesc;
+
+	for (xdesc = room->ex_description; xdesc; xdesc = xdesc->next) {
+	  strncpy(buf, xdesc->description, sizeof(buf));
+	  strip_cr(buf);
+	  fprintf(sf,	"E\n"
+			"%s~\n"
+			"%s~\n", xdesc->keyword, buf);
+	}
+      }
+      fprintf(sf, "S\n");
+    }
+  }
+
+  /*
+   * Write the final line and close it.
+   */
+  fprintf(sf, "$~\n");
+  fclose(sf);
+
+  /* Old file we're replacing. */
+  snprintf(buf, sizeof(buf), "%s/%d.wld", WLD_PREFIX, zone_table[rzone].number);
+
+  remove(buf);
+  rename(filename, buf);
+
+  if (in_save_list(zone_table[rzone].number, SL_WLD))
+    remove_from_save_list(zone_table[rzone].number, SL_WLD);
+  return TRUE;
+}
+
+int copy_room(struct room_data *to, struct room_data *from)
+{
+  free_room_strings(to);
+  *to = *from;
+  copy_room_strings(to, from);
+
+  /* Don't put people and objects in two locations.
+     Am thinking this shouldn't be done here... */
+  from->people = NULL;
+  from->contents = NULL;
+
+  return TRUE;
+}
+
+/*
+ * Idea by: Cris Jacobin <jacobin@bellatlantic.net>
+ */
+room_rnum duplicate_room(room_vnum dest_vnum, room_rnum orig)
+{
+  int new_rnum, znum;
+  struct room_data nroom;
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (orig == NOWHERE || orig > top_of_world) {
+#else
+  if (orig < 0 || orig > top_of_world) {
+#endif
+    log("SYSERR: GenOLC: copy_room: Given bad original real room.");
+    return NOWHERE;
+  } else if ((znum = real_zone_by_thing(dest_vnum)) == NOWHERE) {
+    log("SYSERR: GenOLC: copy_room: No such destination zone.");
+    return NOWHERE;
+  }
+
+  /*
+   * add_room will make its own copies of strings.
+   */
+  if ((new_rnum = add_room(&nroom)) == NOWHERE) {
+    log("SYSERR: GenOLC: copy_room: Problem adding room.");
+    return NOWHERE;
+  }
+
+  nroom = world[new_rnum]; 
+  nroom.number = dest_vnum;
+  nroom.zone = znum;
+
+  /* So the people and objects aren't in two places at once... */
+  nroom.contents = NULL;
+  nroom.people = NULL;
+
+  return new_rnum;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Copy strings over so bad things don't happen.  We do not free the
+ * existing strings here because copy_room() did a shallow copy previously
+ * and we'd be freeing the very strings we're copying.  If this function
+ * is used elsewhere, be sure to free_room_strings() the 'dest' room first.
+ */
+int copy_room_strings(struct room_data *dest, struct room_data *source)
+{
+  int i;
+
+  if (dest == NULL || source == NULL) {
+    log("SYSERR: GenOLC: copy_room_strings: NULL values passed.");
+    return FALSE;
+  }
+
+  dest->description = str_udup(source->description);
+  dest->name = str_udup(source->name);
+
+  for (i = 0; i < NUM_OF_DIRS; i++) {
+    if (!R_EXIT(source, i))
+      continue;
+
+    CREATE(R_EXIT(dest, i), struct room_direction_data, 1);
+    *R_EXIT(dest, i) = *R_EXIT(source, i);
+    if (R_EXIT(source, i)->general_description)
+      R_EXIT(dest, i)->general_description = strdup(R_EXIT(source, i)->general_description);
+    if (R_EXIT(source, i)->keyword)
+      R_EXIT(dest, i)->keyword = strdup(R_EXIT(source, i)->keyword);
+  }
+
+  if (source->ex_description)
+    copy_ex_descriptions(&dest->ex_description, source->ex_description);
+
+  return TRUE;
+}
+
+int free_room_strings(struct room_data *room)
+{
+  int i;
+
+  /* Free descriptions. */
+  if (room->name)
+    free(room->name);
+  if (room->description)
+    free(room->description);
+  if (room->ex_description)
+    free_ex_descriptions(room->ex_description);
+
+  /* Free exits. */
+  for (i = 0; i < NUM_OF_DIRS; i++) {
+    if (room->dir_option[i]) {
+      if (room->dir_option[i]->general_description)
+        free(room->dir_option[i]->general_description);
+      if (room->dir_option[i]->keyword)
+        free(room->dir_option[i]->keyword);
+      free(room->dir_option[i]);
+    }
+  }
+
+  return TRUE;
+}
diff -BENbdpru circle-3.1/src/genwld.h circle3.1_oasis206/src/genwld.h
--- circle-3.1/src/genwld.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genwld.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,14 @@
+/************************************************************************
+ * Generic OLC Library - Rooms / genwld.h			v1.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+room_rnum add_room(struct room_data *);
+int delete_room(room_rnum);
+int save_rooms(zone_rnum);
+int copy_room(struct room_data *to, struct room_data *from);
+room_rnum duplicate_room(room_vnum to, room_rnum from);
+int copy_room_strings(struct room_data *dest, struct room_data *source);
+int free_room_strings(struct room_data *);
diff -BENbdpru circle-3.1/src/genzon.c circle3.1_oasis206/src/genzon.c
--- circle-3.1/src/genzon.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genzon.c	2003-10-07 09:55:16.000000000 +0200
@@ -0,0 +1,599 @@
+/************************************************************************
+ * Generic OLC Library - Zones / genzon.c			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "genolc.h"
+#include "genzon.h"
+
+extern zone_rnum top_of_zone_table;
+extern struct room_data *world;
+extern struct zone_data *zone_table;
+extern struct char_data *mob_proto;
+extern struct obj_data *obj_proto;
+extern struct index_data *mob_index;
+extern struct index_data *obj_index;
+
+/* real zone of room/mobile/object/shop given */
+zone_rnum real_zone_by_thing(room_vnum vznum)
+{
+  zone_rnum bot, top, mid;
+  int low, high;
+
+  bot = 0;
+  top = top_of_zone_table;
+
+  /* perform binary search on zone-table */
+  for (;;) {
+    mid = (bot + top) / 2;
+
+    /* Upper/lower bounds of the zone. */
+    low = genolc_zone_bottom(mid);
+    high = zone_table[mid].top;
+
+    if (low <= vznum && vznum <= high)
+      return mid;
+    if (bot >= top)
+      return NOWHERE;
+    if (low > vznum)
+      top = mid - 1;
+    else
+      bot = mid + 1;
+  }
+}
+
+zone_rnum create_new_zone(zone_vnum vzone_num, room_vnum bottom, room_vnum top, const char **error)
+{
+  FILE *fp;
+  struct zone_data *zone;
+  int i;
+  zone_rnum rznum;
+  char buf[MAX_STRING_LENGTH];
+
+#if CIRCLE_UNSIGNED_INDEX
+  if (vzone_num == NOWHERE) {
+#else
+  if (vzone_num < 0) {
+#endif
+    *error = "You can't make negative zones.\r\n";
+    return NOWHERE;
+  } else if (bottom > top) {
+    *error = "Bottom room cannot be greater than top room.\r\n";
+    return NOWHERE;
+  }
+
+#if _CIRCLEMUD < CIRCLEMUD_VERSION(3,0,21)
+  /*
+   * New with bpl19, the OLC interface should decide whether
+   * to allow overlap before calling this function. There
+   * are more complicated rules for that but it's not covered
+   * here.
+   */
+  if (vzone_num > 326) {
+    *error = "326 is the highest zone allowed.\r\n";
+    return NOWHERE;
+  }
+
+  /*
+   * Make sure the zone does not exist.
+   */
+  room = vzone_num * 100; /* Old CircleMUD 100-zones. */
+  for (i = 0; i <= top_of_zone_table; i++)
+    if (genolc_zone_bottom(i) <= room && zone_table[i].top >= room) {
+      *error = "A zone already covers that area.\r\n";
+      return NOWHERE;
+    }
+#else
+  for (i = 0; i < top_of_zone_table; i++)
+    if (zone_table[i].number == vzone_num) {
+      *error = "That virtual zone already exists.\r\n";
+      return NOWHERE;
+     }
+#endif
+
+  /*
+   * Create the zone file.
+   */
+  snprintf(buf, sizeof(buf), "%s/%d.zon", ZON_PREFIX, vzone_num);
+  if (!(fp = fopen(buf, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Can't write new zone file.");
+    *error = "Could not write zone file.\r\n";
+    return NOWHERE;
+  }
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+  /* File format changed. */
+  fprintf(fp, "#%d\nNone~\nNew Zone~\n%d %d 30 2\nS\n$\n", vzone_num, bottom, top);
+#else
+  fprintf(fp, "#%d\nNew Zone~\n%d 30 2\nS\n$\n", vzone_num, (vzone_num * 100) + 99);
+#endif
+  fclose(fp);
+
+  /*
+   * Create the room file.
+   */
+  snprintf(buf, sizeof(buf), "%s/%d.wld", WLD_PREFIX, vzone_num);
+  if (!(fp = fopen(buf, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Can't write new world file.");
+    *error = "Could not write world file.\r\n";
+    return NOWHERE;
+  }
+  fprintf(fp, "#%d\nThe Beginning~\nNot much here.\n~\n%d 0 0\nS\n$\n", bottom, vzone_num);
+  fclose(fp);
+
+  /*
+   * Create the mobile file.
+   */
+  snprintf(buf, sizeof(buf), "%s/%d.mob", MOB_PREFIX, vzone_num);
+  if (!(fp = fopen(buf, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Can't write new mob file.");
+    *error = "Could not write mobile file.\r\n";
+    return NOWHERE;
+  }
+  fprintf(fp, "$\n");
+  fclose(fp);
+
+  /*
+   * Create the object file.
+   */
+  snprintf(buf, sizeof(buf), "%s/%d.obj", OBJ_PREFIX, vzone_num);
+  if (!(fp = fopen(buf, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Can't write new obj file.");
+    *error = "Could not write object file.\r\n";
+    return NOWHERE;
+  }
+  fprintf(fp, "$\n");
+  fclose(fp);
+
+  /*
+   * Create the shop file.
+   */
+  snprintf(buf, sizeof(buf), "%s/%d.shp", SHP_PREFIX, vzone_num);
+  if (!(fp = fopen(buf, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Can't write new shop file.");
+    *error = "Could not write shop file.\r\n";
+    return NOWHERE;
+  }
+  fprintf(fp, "$~\n");
+  fclose(fp);
+
+  /*
+   * Update index files.
+   */
+  create_world_index(vzone_num, "zon");
+  create_world_index(vzone_num, "wld");
+  create_world_index(vzone_num, "mob");
+  create_world_index(vzone_num, "obj");
+  create_world_index(vzone_num, "shp");
+
+  /*
+   * Make a new zone in memory. This was the source of all the zedit new
+   * crashes reported to the CircleMUD list. It was happily overwriting
+   * the stack.  This new loop by Andrew Helm fixes that problem and is
+   * more understandable at the same time.
+   *
+   * The variable is 'top_of_zone_table_table + 2' because we need record 0
+   * through top_of_zone (top_of_zone_table + 1 items) and a new one which
+   * makes it top_of_zone_table + 2 elements large.
+   */
+  RECREATE(zone_table, struct zone_data, top_of_zone_table + 2);
+  zone_table[top_of_zone_table + 1].number = 32000;
+
+  if (vzone_num > zone_table[top_of_zone_table].number)
+    rznum = top_of_zone_table + 1;
+  else {
+    for (i = top_of_zone_table + 1; i > 0 && vzone_num < zone_table[i - 1].number; i--)
+      zone_table[i] = zone_table[i - 1];
+    rznum = i;
+  }
+  zone = &zone_table[rznum];
+
+  /*
+   * Ok, insert the new zone here.
+   */  
+  zone->name = strdup("New Zone");
+  zone->number = vzone_num;
+  zone->builders = strdup("None");
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+  zone->bot = bottom;
+  zone->top = top;
+#else
+  zone->top = (vzone_num * 100) + 99;
+#endif
+  zone->lifespan = 30;
+  zone->age = 0;
+  zone->reset_mode = 2;
+  /*
+   * No zone commands, just terminate it with an 'S'
+   */
+  CREATE(zone->cmd, struct reset_com, 1);
+  zone->cmd[0].command = 'S';
+
+  top_of_zone_table++;
+
+  add_to_save_list(zone->number, SL_ZON);
+  return rznum;
+}
+
+/*-------------------------------------------------------------------*/
+
+void create_world_index(int znum, const char *type)
+{
+  FILE *newfile, *oldfile;
+  char new_name[32], old_name[32], *prefix;
+  int num, found = FALSE;
+  char buf[MAX_STRING_LENGTH];
+  char buf1[MAX_STRING_LENGTH];
+
+  switch (*type) {
+  case 'z':
+    prefix = ZON_PREFIX;
+    break;
+  case 'w':
+    prefix = WLD_PREFIX;
+    break;
+  case 'o':
+    prefix = OBJ_PREFIX;
+    break;
+  case 'm':
+    prefix = MOB_PREFIX;
+    break;
+  case 's':
+    prefix = SHP_PREFIX;
+    break;
+  default:
+    /*
+     * Caller messed up  
+     */
+    return;
+  }
+
+  snprintf(old_name, sizeof(old_name), "%s/index", prefix);
+  snprintf(new_name, sizeof(new_name), "%s/newindex", prefix);
+
+  if (!(oldfile = fopen(old_name, "r"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Failed to open %s.", old_name);
+    return;
+  } else if (!(newfile = fopen(new_name, "w"))) {
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: OLC: Failed to open %s.", new_name);
+    fclose(oldfile);
+    return;
+  }
+
+  /*
+   * Index contents must be in order: search through the old file for the
+   * right place, insert the new file, then copy the rest over. 
+   */
+  snprintf(buf1, sizeof(buf1), "%d.%s", znum, type);
+  while (get_line(oldfile, buf)) {
+    if (*buf == '$') {
+      /*
+       * The following used to add a blank line, thanks to Brian Taylor for the fix... (Mythran)
+       */
+      fprintf(newfile, "%s", (!found ? strncat(buf1, "\n$\n", sizeof(buf1)-1) : "$\n"));
+      break;
+    } else if (!found) {
+      sscanf(buf, "%d", &num);
+      if (num > znum) {
+	found = TRUE;
+	fprintf(newfile, "%s\n", buf1);
+      }
+    }
+    fprintf(newfile, "%s\n", buf);
+  }
+
+  fclose(newfile);
+  fclose(oldfile);
+  /*
+   * Out with the old, in with the new.
+   */
+  remove(old_name);
+  rename(new_name, old_name);
+}
+
+/*-------------------------------------------------------------------*/
+
+void remove_room_zone_commands(zone_rnum zone, room_rnum room_num)
+{
+  int subcmd = 0, cmd_room = -2;
+
+  /*
+   * Delete all entries in zone_table that relate to this room so we
+   * can add all the ones we have in their place.
+   */
+  while (zone_table[zone].cmd[subcmd].command != 'S') {
+    switch (zone_table[zone].cmd[subcmd].command) {
+    case 'M':
+    case 'O':
+      cmd_room = zone_table[zone].cmd[subcmd].arg3;
+      break;
+    case 'D':
+    case 'R':
+      cmd_room = zone_table[zone].cmd[subcmd].arg1;
+      break;
+    default:
+      break;
+    }
+    if (cmd_room == room_num)
+      remove_cmd_from_list(&zone_table[zone].cmd, subcmd);
+    else
+      subcmd++;
+  }
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Save all the zone_table for this zone to disk.  This function now
+ * writes simple comments in the form of (<name>) to each record.  A
+ * header for each field is also there.
+ */
+int save_zone(zone_rnum zone_num)
+{
+  int subcmd, arg1 = -1, arg2 = -1, arg3 = -1;
+  char fname[128], oldname[128];
+  const char *comment = NULL;
+  FILE *zfile;
+  
+#if CIRCLE_UNSIGNED_INDEX
+  if (zone_num == NOWHERE || zone_num > top_of_zone_table) {
+#else
+  if (zone_num < 0 || zone_num > top_of_zone_table) {
+#endif
+    log("SYSERR: GenOLC: save_zone: Invalid real zone number %d. (0-%d)", zone_num, top_of_zone_table);
+    return FALSE;
+  }
+
+  snprintf(fname, sizeof(fname), "%s/%d.new", ZON_PREFIX, zone_table[zone_num].number);
+  if (!(zfile = fopen(fname, "w"))) {
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: save_zones:  Can't write zone %d.", zone_table[zone_num].number);
+    return FALSE;
+  }
+
+  /*
+   * Print zone header to file	
+   */
+  fprintf(zfile, "#%d\n"
+                 "%s~\n"
+                 "%s~\n"
+                 "%d %d %d %d\n",
+	  zone_table[zone_num].number,
+	  (zone_table[zone_num].builders && *zone_table[zone_num].builders)
+		? zone_table[zone_num].builders : "None.",
+	  (zone_table[zone_num].name && *zone_table[zone_num].name)
+		? zone_table[zone_num].name : "undefined",
+          genolc_zone_bottom(zone_num),
+	  zone_table[zone_num].top,
+	  zone_table[zone_num].lifespan,
+	  zone_table[zone_num].reset_mode
+	  );
+
+	/*
+	 * Handy Quick Reference Chart for Zone Values.
+	 *
+	 * Field #1    Field #3   Field #4  Field #5
+	 * -------------------------------------------------
+	 * M (Mobile)  Mob-Vnum   Wld-Max   Room-Vnum
+	 * O (Object)  Obj-Vnum   Wld-Max   Room-Vnum
+	 * G (Give)    Obj-Vnum   Wld-Max   Unused
+	 * E (Equip)   Obj-Vnum   Wld-Max   EQ-Position
+	 * P (Put)     Obj-Vnum   Wld-Max   Target-Obj-Vnum
+	 * D (Door)    Room-Vnum  Door-Dir  Door-State
+	 * R (Remove)  Room-Vnum  Obj-Vnum  Unused
+	 * -------------------------------------------------
+	 */
+
+  for (subcmd = 0; ZCMD(zone_num, subcmd).command != 'S'; subcmd++) {
+    switch (ZCMD(zone_num, subcmd).command) {
+    case 'M':
+      arg1 = mob_index[ZCMD(zone_num, subcmd).arg1].vnum;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = world[ZCMD(zone_num, subcmd).arg3].number;
+      comment = mob_proto[ZCMD(zone_num, subcmd).arg1].player.short_descr;
+      break;
+    case 'O':
+      arg1 = obj_index[ZCMD(zone_num, subcmd).arg1].vnum;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = world[ZCMD(zone_num, subcmd).arg3].number;
+      comment = obj_proto[ZCMD(zone_num, subcmd).arg1].short_description;
+      break;
+    case 'G':
+      arg1 = obj_index[ZCMD(zone_num, subcmd).arg1].vnum;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = -1;
+      comment = obj_proto[ZCMD(zone_num, subcmd).arg1].short_description;
+      break;
+    case 'E':
+      arg1 = obj_index[ZCMD(zone_num, subcmd).arg1].vnum;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = ZCMD(zone_num, subcmd).arg3;
+      comment = obj_proto[ZCMD(zone_num, subcmd).arg1].short_description;
+      break;
+    case 'P':
+      arg1 = obj_index[ZCMD(zone_num, subcmd).arg1].vnum;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = obj_index[ZCMD(zone_num, subcmd).arg3].vnum;
+      comment = obj_proto[ZCMD(zone_num, subcmd).arg1].short_description;
+      break;
+    case 'D':
+      arg1 = world[ZCMD(zone_num, subcmd).arg1].number;
+      arg2 = ZCMD(zone_num, subcmd).arg2;
+      arg3 = ZCMD(zone_num, subcmd).arg3;
+      comment = world[ZCMD(zone_num, subcmd).arg1].name;
+      break;
+    case 'R':
+      arg1 = world[ZCMD(zone_num, subcmd).arg1].number;
+      arg2 = obj_index[ZCMD(zone_num, subcmd).arg2].vnum;
+      comment = obj_proto[ZCMD(zone_num, subcmd).arg2].short_description;
+      arg3 = -1;
+      break;
+    case '*':
+      /*
+       * Invalid commands are replaced with '*' - Ignore them.
+       */
+      continue;
+    default:
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: z_save_to_disk(): Unknown cmd '%c' - NOT saving", ZCMD(zone_num, subcmd).command);
+      continue;
+    }
+    fprintf(zfile, "%c %d %d %d %d \t(%s)\n",
+		ZCMD(zone_num, subcmd).command, ZCMD(zone_num, subcmd).if_flag, arg1, arg2, arg3, comment);
+  }
+  fputs("S\n$\n", zfile);
+  fclose(zfile);
+  snprintf(oldname, sizeof(oldname), "%s/%d.zon", ZON_PREFIX, zone_table[zone_num].number);
+  remove(oldname);
+  rename(fname, oldname);
+  
+  if (in_save_list(zone_table[zone_num].number, SL_ZON))
+    remove_from_save_list(zone_table[zone_num].number, SL_ZON);
+  return TRUE;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Some common code to count the number of comands in the list.
+ */
+int count_commands(struct reset_com *list)
+{
+  int count = 0;
+
+  while (list[count].command != 'S')
+    count++;
+
+  return count;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Adds a new reset command into a list.  Takes a pointer to the list
+ * so that it may play with the memory locations.
+ */
+void add_cmd_to_list(struct reset_com **list, struct reset_com *newcmd, int pos)
+{
+  int count, i, l;
+  struct reset_com *newlist;
+
+  /*
+   * Count number of commands (not including terminator).
+   */
+  count = count_commands(*list);
+
+  /*
+   * Value is +2 for the terminator and new field to add.
+   */
+  CREATE(newlist, struct reset_com, count + 2);
+
+  /*
+   * Even tighter loop to copy the old list and insert a new command.
+   */
+  for (i = 0, l = 0; i <= count; i++) {
+    newlist[i] = ((i == pos) ? *newcmd : (*list)[l++]);
+  }
+
+  /*
+   * Add terminator, then insert new list.
+   */
+  newlist[count + 1].command = 'S';
+  free(*list);
+  *list = newlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Remove a reset command from a list.	Takes a pointer to the list
+ * so that it may play with the memory locations.
+ */
+void remove_cmd_from_list(struct reset_com **list, int pos)
+{
+  int count, i, l;
+  struct reset_com *newlist;
+
+  /*
+   * Count number of commands (not including terminator)  
+   */
+  count = count_commands(*list);
+
+  /*
+   * Value is 'count' because we didn't include the terminator above
+   * but since we're deleting one thing anyway we want one less.
+   */
+  CREATE(newlist, struct reset_com, count);
+
+  /*
+   * Even tighter loop to copy old list and skip unwanted command.
+   */
+  for (i = 0, l = 0; i < count; i++) {
+    if (i != pos) {
+      newlist[l++] = (*list)[i];
+    }
+  }
+  /*
+   * Add the terminator, then insert the new list.
+   */
+  newlist[count - 1].command = 'S';
+  free(*list);
+  *list = newlist;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Error check user input and then add new (blank) command  
+ */
+int new_command(struct zone_data *zone, int pos)
+{
+  int subcmd = 0;
+  struct reset_com *new_com;
+
+  /*
+   * Error check to ensure users hasn't given too large an index  
+   */
+  while (zone->cmd[subcmd].command != 'S')
+    subcmd++;
+
+  if (pos < 0 || pos > subcmd)
+    return 0;
+
+  /*
+   * Ok, let's add a new (blank) command 
+   */
+  CREATE(new_com, struct reset_com, 1);
+  new_com->command = 'N';
+  add_cmd_to_list(&zone->cmd, new_com, pos);
+  return 1;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Error check user input and then remove command  
+ */
+void delete_command(struct zone_data *zone, int pos)
+{
+  int subcmd = 0;
+
+  /*
+   * Error check to ensure users hasn't given too large an index  
+   */
+  while (zone->cmd[subcmd].command != 'S')
+    subcmd++;
+
+  if (pos < 0 || pos >= subcmd)
+    return;
+
+  /*
+   * Ok, let's zap it  
+   */
+  remove_cmd_from_list(&zone->cmd, pos);
+}
+
+/*-------------------------------------------------------------------*/
diff -BENbdpru circle-3.1/src/genzon.h circle3.1_oasis206/src/genzon.h
--- circle-3.1/src/genzon.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/genzon.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,19 @@
+/************************************************************************
+ * Generic OLC Library - Zones / genzon.h			v1.0	*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+zone_rnum create_new_zone(zone_vnum vzone_num, room_vnum bottom, room_vnum top, const char **error);
+void create_world_index(int znum, const char *type);
+void remove_room_zone_commands(zone_rnum zone, room_rnum room_num);
+int save_zone(zone_rnum zone_num);
+int count_commands(struct reset_com *list);
+void add_cmd_to_list(struct reset_com **list, struct reset_com *newcmd, int pos);
+void remove_cmd_from_list(struct reset_com **list, int pos);
+int new_command(struct zone_data *zone, int pos);
+void delete_command(struct zone_data *zone, int pos);
+zone_rnum real_zone(zone_vnum vznum);
+zone_rnum real_zone_by_thing(room_vnum vznum);
+
+/* Make delete_zone() */
diff -BENbdpru circle-3.1/src/graph.c circle3.1_oasis206/src/graph.c
--- circle-3.1/src/graph.c	2002-02-01 03:04:18.000000000 +0100
+++ circle3.1_oasis206/src/graph.c	2003-07-26 10:19:22.000000000 +0200
@@ -26,7 +26,6 @@ ACMD(do_say);
 
 /* external variables */
 extern const char *dirs[];
-extern int track_through_doors;
 
 /* local functions */
 int VALID_EDGE(room_rnum x, int y);
@@ -56,7 +55,7 @@ int VALID_EDGE(room_rnum x, int y)
 {
   if (world[x].dir_option[y] == NULL || TOROOM(x, y) == NOWHERE)
     return 0;
-  if (track_through_doors == FALSE && IS_CLOSED(x, y))
+  if (CONFIG_TRACK_T_DOORS == FALSE && IS_CLOSED(x, y))
     return 0;
   if (ROOM_FLAGGED(TOROOM(x, y), ROOM_NOTRACK) || IS_MARKED(TOROOM(x, y)))
     return 0;
diff -BENbdpru circle-3.1/src/handler.c circle3.1_oasis206/src/handler.c
--- circle-3.1/src/handler.c	2002-05-02 22:44:44.000000000 +0200
+++ circle3.1_oasis206/src/handler.c	2003-10-07 09:55:16.000000000 +0200
@@ -25,7 +25,6 @@ int extractions_pending = 0;
 
 /* external vars */
 extern struct char_data *combat_list;
-extern const char *MENU;
 
 /* local functions */
 int apply_ac(struct char_data *ch, int eq_pos);
@@ -40,7 +39,7 @@ ACMD(do_return);
 
 char *fname(const char *namelist)
 {
-  static char holder[30];
+  static char holder[READ_SIZE];
   char *point;
 
   for (point = holder; isalpha(*namelist); namelist++, point++)
@@ -51,11 +50,15 @@ char *fname(const char *namelist)
   return (holder);
 }
 
-
-int isname(const char *str, const char *namelist)
+/* Stock isname().  Leave this here even if you put in a newer  *
+ * isname().  Used for OasisOLC.                                */
+int is_name(const char *str, const char *namelist)
 {
   const char *curname, *curstr;
 
+  if (!*str || !*namelist || !str || !namelist)
+    return (0);
+
   curname = namelist;
   for (;;) {
     for (curstr = str;; curstr++, curname++) {
@@ -81,6 +83,26 @@ int isname(const char *str, const char *
   }
 }
 
+/* allow abbreviations */
+#define WHITESPACE " \t"
+int isname(const char *str, const char *namelist)
+{
+  char *newlist;
+  char *curtok;
+
+  if (!str || !*str || !namelist || !*namelist)
+    return 0;
+
+  newlist = strdup(namelist); /* make a copy since strtok 'modifies' strings */
+  for(curtok = strtok(newlist, WHITESPACE); curtok; curtok = strtok(NULL, WHITESPACE))
+    if (curtok && is_abbrev(str, curtok)) {
+      free(newlist);
+      return 1;
+    }
+  free(newlist);
+  return 0;
+}
+
 
 
 void affect_modify(struct char_data *ch, byte loc, sbyte mod, 
@@ -894,7 +916,7 @@ void extract_char_final(struct char_data
           STATE(d) = CON_CLOSE;
       }
       STATE(ch->desc) = CON_MENU;
-      write_to_output(ch->desc, "%s", MENU);
+      write_to_output(ch->desc, "%s", CONFIG_MENU);
     }
   }
 
diff -BENbdpru circle-3.1/src/handler.h circle3.1_oasis206/src/handler.h
--- circle-3.1/src/handler.h	2002-06-22 01:23:52.000000000 +0200
+++ circle3.1_oasis206/src/handler.h	2003-07-26 10:19:22.000000000 +0200
@@ -23,6 +23,7 @@ bool add_dur, bool avg_dur, bool add_mod
 const char *money_desc(int amount);
 struct obj_data *create_money(int amount);
 int	isname(const char *str, const char *namelist);
+int	is_name(const char *str, const char *namelist);
 char	*fname(const char *namelist);
 int	get_number(char **name);
 
diff -BENbdpru circle-3.1/src/improved-edit.c circle3.1_oasis206/src/improved-edit.c
--- circle-3.1/src/improved-edit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/improved-edit.c	2003-10-07 09:55:14.000000000 +0200
@@ -0,0 +1,627 @@
+/*
+
+improved-edit.c		Routines specific to the improved editor.
+
+*/
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "db.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "improved-edit.h"
+
+void send_editor_help(struct descriptor_data *d)
+{
+  if (using_improved_editor)
+    write_to_output(d, "Instructions: /s or @ to save, /h for more options.\r\n");
+  else
+    write_to_output(d, "Instructions: Type @ on a line by itself to end.\r\n");
+}
+
+#if CONFIG_IMPROVED_EDITOR
+
+int improved_editor_execute(struct descriptor_data *d, char *str)
+{
+  char actions[MAX_INPUT_LENGTH];
+
+  if (*str != '/')
+    return STRINGADD_OK;
+
+  strncpy(actions, str + 2, sizeof(actions) - 1);
+  actions[sizeof(actions) - 1] = '\0';
+  *str = '\0';
+
+  switch (str[1]) {
+  case 'a':
+    return STRINGADD_ABORT;
+  case 'c':
+    if (*(d->str)) {
+      free(*d->str);
+      *(d->str) = NULL;
+      write_to_output(d, "Current buffer cleared.\r\n");
+    } else
+      write_to_output(d, "Current buffer empty.\r\n");
+    break;
+  case 'd':
+    parse_action(PARSE_DELETE, actions, d);
+    break;
+  case 'e':
+    parse_action(PARSE_EDIT, actions, d);
+    break;
+  case 'f':
+    if (*(d->str))
+      parse_action(PARSE_FORMAT, actions, d);
+    else
+      write_to_output(d, "Current buffer empty.\r\n");
+    break;
+  case 'i':
+    if (*(d->str))
+      parse_action(PARSE_INSERT, actions, d);
+    else
+      write_to_output(d, "Current buffer empty.\r\n");
+    break;
+  case 'h':
+    parse_action(PARSE_HELP, actions, d);
+    break;
+  case 'l':
+    if (*d->str)
+      parse_action(PARSE_LIST_NORM, actions, d);
+    else
+      write_to_output(d, "Current buffer empty.\r\n");
+    break;
+  case 'n':
+    if (*d->str)
+      parse_action(PARSE_LIST_NUM, actions, d);
+    else
+      write_to_output(d, "Current buffer empty.\r\n");
+    break;
+  case 'r':
+    parse_action(PARSE_REPLACE, actions, d);
+    break;
+  case 's':
+    return STRINGADD_SAVE;
+  default:
+    write_to_output(d, "Invalid option.\r\n");
+    break;
+  }
+  return STRINGADD_ACTION;
+}
+
+/*
+ * Handle some editor commands.
+ */
+void parse_action(int command, char *string, struct descriptor_data *d)
+{
+  int indent = 0, rep_all = 0, flags = 0, replaced, i, line_low, line_high, j = 0;
+  unsigned int total_len;
+  char *s, *t, temp;
+  char buf[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+
+  switch (command) {
+  case PARSE_HELP:
+    write_to_output(d,
+	    "Editor command formats: /<letter>\r\n\r\n"
+	    "/a         -  aborts editor\r\n"
+	    "/c         -  clears buffer\r\n"
+	    "/d#        -  deletes a line #\r\n"
+	    "/e# <text> -  changes the line at # with <text>\r\n"
+	    "/f         -  formats text\r\n"
+	    "/fi        -  indented formatting of text\r\n"
+	    "/h         -  list text editor commands\r\n"
+	    "/i# <text> -  inserts <text> before line #\r\n"
+	    "/l         -  lists buffer\r\n"
+	    "/n         -  lists buffer with line numbers\r\n"
+	    "/r 'a' 'b' -  replace 1st occurance of text <a> in buffer with text <b>\r\n"
+	    "/ra 'a' 'b'-  replace all occurances of text <a> within buffer with text <b>\r\n"
+	    "              usage: /r[a] 'pattern' 'replacement'\r\n"
+	    "/s         -  saves text\r\n");
+    break;
+  case PARSE_FORMAT:
+    while (isalpha(string[j]) && j < 2)
+      if (string[j++] == 'i' && !indent) {
+	indent = TRUE;
+	flags += FORMAT_INDENT;
+      }
+    format_text(d->str, flags, d, d->max_str);
+    write_to_output(d, "Text formatted with%s indent.\r\n",
+      (indent ? "" : "out"));
+    break;
+  case PARSE_REPLACE:
+    while (isalpha(string[j]) && j < 2)
+      if (string[j++] == 'a' && !indent)
+	rep_all = 1;
+
+    if ((s = strtok(string, "'")) == NULL) {
+      write_to_output(d, "Invalid format.\r\n");
+      return;
+    } else if ((s = strtok(NULL, "'")) == NULL) {
+      write_to_output(d, "Target string must be enclosed in single quotes.\r\n");
+      return;
+    } else if ((t = strtok(NULL, "'")) == NULL) {
+      write_to_output(d, "No replacement string.\r\n");
+      return;
+    } else if ((t = strtok(NULL, "'")) == NULL) {
+      write_to_output(d, "Replacement string must be enclosed in single quotes.\r\n");
+      return;
+      /*wb's fix for empty buffer replacement crashing */
+    } else if ((!*d->str)) {
+      return;
+    } else if ((total_len = ((strlen(t) - strlen(s)) + strlen(*d->str))) <= d->max_str) {
+      if ((replaced = replace_str(d->str, s, t, rep_all, d->max_str)) > 0) {
+	write_to_output(d, "Replaced %d occurance%sof '%s' with '%s'.\r\n",
+	  replaced, ((replaced != 1) ? "s " : " "), s, t);
+      } else if (replaced == 0) {
+	write_to_output(d, "String '%s' not found.\r\n", s);
+      } else
+	write_to_output(d, "ERROR: Replacement string causes buffer overflow, aborted replace.\r\n");
+    } else
+      write_to_output(d, "Not enough space left in buffer.\r\n");
+    break;
+  case PARSE_DELETE:
+    switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
+    case 0:
+      write_to_output(d, "You must specify a line number or range to delete.\r\n");
+      return;
+    case 1:
+      line_high = line_low;
+      break;
+    case 2:
+      if (line_high < line_low) {
+	write_to_output(d, "That range is invalid.\r\n");
+	return;
+      }
+      break;
+    }
+
+    i = 1;
+    total_len = 1;
+    if ((s = *d->str) == NULL) {
+      write_to_output(d, "Buffer is empty.\r\n");
+      return;
+    } else if (line_low > 0) {
+      while (s && i < line_low)
+	if ((s = strchr(s, '\n')) != NULL) {
+	  i++;
+	  s++;
+	}
+      if (s == NULL || i < line_low) {
+	write_to_output(d, "Line(s) out of range; not deleting.\r\n");
+	return;
+      }
+      t = s;
+      while (s && i < line_high)
+	if ((s = strchr(s, '\n')) != NULL) {
+	  i++;
+	  total_len++;
+	  s++;
+	}
+      if (s && (s = strchr(s, '\n')) != NULL) {
+	while (*(++s))
+	  *(t++) = *s;
+      } else
+	total_len--;
+      *t = '\0';
+      RECREATE(*d->str, char, strlen(*d->str) + 3);
+      write_to_output(d, "%d line%sdeleted.\r\n", total_len,
+	(total_len != 1 ? "s " : " "));
+    } else {
+      write_to_output(d, "Invalid, line numbers to delete must be higher than 0.\r\n");
+      return;
+    }
+    break;
+  case PARSE_LIST_NORM:
+    /*
+     * Note: Rv's buf, buf1, buf2, and arg variables are defined to 32k so
+     * they are probly ok for what to do here. 
+     */
+    *buf = '\0';
+    if (*string)
+      switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
+      case 0:
+	line_low = 1;
+	line_high = 999999;
+	break;
+      case 1:
+	line_high = line_low;
+	break;
+    } else {
+      line_low = 1;
+      line_high = 999999;
+    }
+
+    if (line_low < 1) {
+      write_to_output(d, "Line numbers must be greater than 0.\r\n");
+      return;
+    } else if (line_high < line_low) {
+      write_to_output(d, "That range is invalid.\r\n");
+      return;
+    }
+    *buf = '\0';
+    if (line_high < 999999 || line_low > 1)
+      sprintf(buf, "Current buffer range [%d - %d]:\r\n", line_low, line_high);
+    i = 1;
+    total_len = 0;
+    s = *d->str;
+    while (s && (i < line_low))
+      if ((s = strchr(s, '\n')) != NULL) {
+	i++;
+	s++;
+      }
+    if (i < line_low || s == NULL) {
+      write_to_output(d, "Line(s) out of range; no buffer listing.\r\n");
+      return;
+    }
+    t = s;
+    while (s && i <= line_high)
+      if ((s = strchr(s, '\n')) != NULL) {
+	i++;
+	total_len++;
+	s++;
+      }
+    if (s) {
+      temp = *s;
+      *s = '\0';
+      strcat(buf, t);
+      *s = temp;
+    } else
+      strcat(buf, t);
+    /*
+     * This is kind of annoying...but some people like it.
+     */
+    sprintf(buf + strlen(buf), "\r\n%d line%sshown.\r\n", total_len, (total_len != 1) ? "s " : " "); 
+    page_string(d, buf, TRUE);
+    break;
+  case PARSE_LIST_NUM:
+    /*
+     * Note: Rv's buf, buf1, buf2, and arg variables are defined to 32k so
+     * they are probly ok for what to do here. 
+     */
+    *buf = '\0';
+    if (*string)
+      switch (sscanf(string, " %d - %d ", &line_low, &line_high)) {
+      case 0:
+	line_low = 1;
+	line_high = 999999;
+	break;
+      case 1:
+	line_high = line_low;
+	break;
+    } else {
+      line_low = 1;
+      line_high = 999999;
+    }
+
+    if (line_low < 1) {
+      write_to_output(d, "Line numbers must be greater than 0.\r\n");
+      return;
+    }
+    if (line_high < line_low) {
+      write_to_output(d, "That range is invalid.\r\n");
+      return;
+    }
+    *buf = '\0';
+    i = 1;
+    total_len = 0;
+    s = *d->str;
+    while (s && i < line_low)
+      if ((s = strchr(s, '\n')) != NULL) {
+	i++;
+	s++;
+      }
+    if (i < line_low || s == NULL) {
+      write_to_output(d, "Line(s) out of range; no buffer listing.\r\n");
+      return;
+    }
+    t = s;
+    while (s && i <= line_high)
+      if ((s = strchr(s, '\n')) != NULL) {
+	i++;
+	total_len++;
+	s++;
+	temp = *s;
+	*s = '\0';
+	sprintf(buf, "%s%4d:\r\n", buf, (i - 1));
+	strcat(buf, t);
+	*s = temp;
+	t = s;
+      }
+    if (s && t) {
+      temp = *s;
+      *s = '\0';
+      strcat(buf, t);
+      *s = temp;
+    } else if (t)
+      strcat(buf, t);
+
+    page_string(d, buf, TRUE);
+    break;
+
+  case PARSE_INSERT:
+    half_chop(string, buf, buf2);
+    if (*buf == '\0') {
+      write_to_output(d, "You must specify a line number before which to insert text.\r\n");
+      return;
+    }
+    line_low = atoi(buf);
+    strcat(buf2, "\r\n");
+
+    i = 1;
+    *buf = '\0';
+    if ((s = *d->str) == NULL) {
+      write_to_output(d, "Buffer is empty, nowhere to insert.\r\n");
+      return;
+    }
+    if (line_low > 0) {
+      while (s && (i < line_low))
+	if ((s = strchr(s, '\n')) != NULL) {
+	  i++;
+	  s++;
+	}
+      if (i < line_low || s == NULL) {
+	write_to_output(d, "Line number out of range; insert aborted.\r\n");
+	return;
+      }
+      temp = *s;
+      *s = '\0';
+      if ((strlen(*d->str) + strlen(buf2) + strlen(s + 1) + 3) > d->max_str) {
+	*s = temp;
+	write_to_output(d, "Insert text pushes buffer over maximum size, insert aborted.\r\n");
+	return;
+      }
+      if (*d->str && **d->str)
+	strcat(buf, *d->str);
+      *s = temp;
+      strcat(buf, buf2);
+      if (s && *s)
+	strcat(buf, s);
+      RECREATE(*d->str, char, strlen(buf) + 3);
+
+      strcpy(*d->str, buf);
+      write_to_output(d, "Line inserted.\r\n");
+    } else {
+      write_to_output(d, "Line number must be higher than 0.\r\n");
+      return;
+    }
+    break;
+
+  case PARSE_EDIT:
+    half_chop(string, buf, buf2);
+    if (*buf == '\0') {
+      write_to_output(d, "You must specify a line number at which to change text.\r\n");
+      return;
+    }
+    line_low = atoi(buf);
+    strcat(buf2, "\r\n");
+
+    i = 1;
+    *buf = '\0';
+    if ((s = *d->str) == NULL) {
+      write_to_output(d, "Buffer is empty, nothing to change.\r\n");
+      return;
+    }
+    if (line_low > 0) {
+      /*
+       * Loop through the text counting \n characters until we get to the line.
+       */
+      while (s && i < line_low)
+	if ((s = strchr(s, '\n')) != NULL) {
+	  i++;
+	  s++;
+	}
+      /*
+       * Make sure that there was a THAT line in the text.
+       */
+      if (s == NULL || i < line_low) {
+	write_to_output(d, "Line number out of range; change aborted.\r\n");
+	return;
+      }
+      /*
+       * If s is the same as *d->str that means I'm at the beginning of the
+       * message text and I don't need to put that into the changed buffer.
+       */
+      if (s != *d->str) {
+	/*
+	 * First things first .. we get this part into the buffer.
+	 */
+	temp = *s;
+	*s = '\0';
+	/*
+	 * Put the first 'good' half of the text into storage.
+	 */
+	strcat(buf, *d->str);
+	*s = temp;
+      }
+      /*
+       * Put the new 'good' line into place.
+       */
+      strcat(buf, buf2);
+      if ((s = strchr(s, '\n')) != NULL) {
+	/*
+	 * This means that we are at the END of the line, we want out of
+	 * there, but we want s to point to the beginning of the line
+	 * AFTER the line we want edited 
+	 */
+	s++;
+	/*
+	 * Now put the last 'good' half of buffer into storage.
+	 */
+	strcat(buf, s);
+      }
+      /*
+       * Check for buffer overflow.
+       */
+      if (strlen(buf) > d->max_str) {
+	write_to_output(d, "Change causes new length to exceed buffer maximum size, aborted.\r\n");
+	return;
+      }
+      /*
+       * Change the size of the REAL buffer to fit the new text.
+       */
+      RECREATE(*d->str, char, strlen(buf) + 3);
+      strcpy(*d->str, buf);
+      write_to_output(d, "Line changed.\r\n");
+    } else {
+      write_to_output(d, "Line number must be higher than 0.\r\n");
+      return;
+    }
+    break;
+  default:
+    write_to_output(d, "Invalid option.\r\n");
+    mudlog(BRF, LVL_IMPL, TRUE, "SYSERR: invalid command passed to parse_action");
+    return;
+  }
+}
+
+
+/*
+ * Re-formats message type formatted char *.
+ * (for strings edited with d->str) (mostly olc and mail)
+ */
+void format_text(char **ptr_string, int mode, struct descriptor_data *d, unsigned int maxlen)
+{
+  int line_chars, cap_next = TRUE, cap_next_next = FALSE;
+  char *flow, *start = NULL, temp;
+  char formatted[MAX_STRING_LENGTH];
+   
+  /* Fix memory overrun. */
+  if (d->max_str > MAX_STRING_LENGTH) {
+    log("SYSERR: format_text: max_str is greater than buffer size.");
+    return;
+  }
+
+  /* XXX: Want to make sure the string doesn't grow either... */
+
+  if ((flow = *ptr_string) == NULL)
+    return;
+
+  if (IS_SET(mode, FORMAT_INDENT)) {
+    strcpy(formatted, "   ");
+    line_chars = 3;
+  } else {
+    *formatted = '\0';
+    line_chars = 0;
+  } 
+
+  while (*flow) {
+    while (*flow && strchr("\n\r\f\t\v ", *flow))
+      flow++;
+
+    if (*flow) {
+      start = flow++;
+      while (*flow && !strchr("\n\r\f\t\v .?!", *flow))
+	flow++;
+
+      if (cap_next_next) {
+        cap_next_next = FALSE;
+        cap_next = TRUE;
+      }
+
+      /*
+       * This is so that if we stopped on a sentence .. we move off the
+       * sentence delimiter.
+       */
+      while (strchr(".!?", *flow)) {
+	cap_next_next = TRUE;
+	flow++;
+      }
+	 
+      temp = *flow;
+      *flow = '\0';
+
+      if (line_chars + strlen(start) + 1 > PAGE_WIDTH) {
+	strcat(formatted, "\r\n");
+	line_chars = 0;
+      }
+
+      if (!cap_next) {
+	if (line_chars > 0) {
+	  strcat(formatted, " ");
+	  line_chars++;
+	}
+      } else {
+	cap_next = FALSE;
+	*start = UPPER(*start);
+      }
+
+      line_chars += strlen(start);
+      strcat(formatted, start);
+
+      *flow = temp;
+    }
+
+    if (cap_next_next && *flow) {
+      if (line_chars + 3 > PAGE_WIDTH) {
+	strcat(formatted, "\r\n");
+	line_chars = 0;
+      } else {
+	strcat(formatted, "  ");
+	line_chars += 2;
+      }
+    }
+  }
+  strcat(formatted, "\r\n");
+
+  if (strlen(formatted) + 1 > maxlen)
+    formatted[maxlen - 1] = '\0';
+  RECREATE(*ptr_string, char, MIN(maxlen, strlen(formatted) + 1));
+  strcpy(*ptr_string, formatted);
+}
+
+int replace_str(char **string, char *pattern, char *replacement, int rep_all, unsigned int max_size)
+{
+  char *replace_buffer = NULL;
+  char *flow, *jetsam, temp;
+  int len, i;
+
+  if ((strlen(*string) - strlen(pattern)) + strlen(replacement) > max_size)
+    return -1;
+
+  CREATE(replace_buffer, char, max_size);
+  i = 0;
+  jetsam = *string;
+  flow = *string;
+  *replace_buffer = '\0';
+
+  if (rep_all) {
+    while ((flow = (char *)strstr(flow, pattern)) != NULL) {
+      i++;
+      temp = *flow;
+      *flow = '\0';
+      if ((strlen(replace_buffer) + strlen(jetsam) + strlen(replacement)) > max_size) {
+        i = -1;
+        break;
+      }
+      strcat(replace_buffer, jetsam);
+      strcat(replace_buffer, replacement);
+      *flow = temp;
+      flow += strlen(pattern);
+      jetsam = flow;
+    }
+    strcat(replace_buffer, jetsam);
+  } else {
+    if ((flow = (char *)strstr(*string, pattern)) != NULL) {
+      i++;
+      flow += strlen(pattern);
+      len = ((char *)flow - (char *)*string) - strlen(pattern);
+      strncpy(replace_buffer, *string, len);
+      strcat(replace_buffer, replacement);
+      strcat(replace_buffer, flow);
+    }
+  }
+
+  if (i <= 0)
+    return 0;
+  else {
+    RECREATE(*string, char, strlen(replace_buffer) + 3);
+    strcpy(*string, replace_buffer);
+  }
+  free(replace_buffer);
+  return i;
+}
+
+#endif
diff -BENbdpru circle-3.1/src/improved-edit.h circle3.1_oasis206/src/improved-edit.h
--- circle-3.1/src/improved-edit.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/improved-edit.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ * This is here to allow different code for the basic and improved editor.
+ * If do not wish to use the improved editor, put #if 0 below, otherwise
+ * you should leave the setting at #if 1.
+ */
+#define CONFIG_IMPROVED_EDITOR	1
+
+#define using_improved_editor	CONFIG_IMPROVED_EDITOR
+
+void parse_action(int command, char *string, struct descriptor_data *d);
+int improved_editor_execute(struct descriptor_data *d, char *string);
+void format_text(char **ptr_string, int mode, struct descriptor_data *d, unsigned int maxlen);
+int replace_str(char **string, char *pattern, char *replacement, int rep_all, unsigned int max_size);
+void send_editor_help(struct descriptor_data *d);
+
+/*
+ * Action modes for parse_action().
+ */
+#define PARSE_FORMAT		0
+#define PARSE_REPLACE		1
+#define PARSE_HELP		2
+#define PARSE_DELETE		3
+#define PARSE_INSERT		4
+#define PARSE_LIST_NORM		5
+#define PARSE_LIST_NUM		6
+#define PARSE_EDIT		7
+
+/*
+ * Defines for the action variable.
+ */
+#define STRINGADD_OK		0	/* Just keep adding text.		*/
+#define STRINGADD_SAVE		1	/* Save current text.			*/
+#define STRINGADD_ABORT		2	/* Abort edit, restore old text.	*/
+#define STRINGADD_ACTION	4	/* Editor action, don't append \r\n.	*/
+
+/* Settings for formatter. */
+#define FORMAT_INDENT	(1 << 0)
diff -BENbdpru circle-3.1/src/interpreter.c circle3.1_oasis206/src/interpreter.c
--- circle-3.1/src/interpreter.c	2002-10-04 06:24:48.000000000 +0200
+++ circle3.1_oasis206/src/interpreter.c	2003-10-07 11:30:48.000000000 +0200
@@ -22,7 +22,10 @@
 #include "handler.h"
 #include "mail.h"
 #include "screen.h"
-
+#include "genolc.h"
+#include "oasis.h"
+#include "tedit.h"
+#include "improved-edit.h"
 
 /* external variables */
 extern room_rnum r_mortal_start_room;
@@ -32,14 +35,10 @@ extern const char *class_menu;
 extern char *motd;
 extern char *imotd;
 extern char *background;
-extern char *MENU;
-extern char *WELC_MESSG;
-extern char *START_MESSG;
 extern struct player_index_element *player_table;
 extern int top_of_p_table;
 extern int circle_restrict;
 extern int no_specials;
-extern int max_bad_pws;
 
 /* external functions */
 void echo_on(struct descriptor_data *d);
@@ -64,8 +63,10 @@ int _parse_name(char *arg, char *name);
 /* prototypes for all do_x functions. */
 ACMD(do_action);
 ACMD(do_advance);
+ACMD(do_aedit);
 ACMD(do_alias);
 ACMD(do_assist);
+ACMD(do_astat);
 ACMD(do_at);
 ACMD(do_backstab);
 ACMD(do_ban);
@@ -78,11 +79,13 @@ ACMD(do_credits);
 ACMD(do_date);
 ACMD(do_dc);
 ACMD(do_diagnose);
+ACMD(do_dig);
 ACMD(do_display);
 ACMD(do_drink);
 ACMD(do_drop);
 ACMD(do_eat);
 ACMD(do_echo);
+ACMD(do_edit);		/* Mainly intended as a test function. */
 ACMD(do_enter);
 ACMD(do_equipment);
 ACMD(do_examine);
@@ -121,6 +124,7 @@ ACMD(do_load);
 ACMD(do_look);
 /* ACMD(do_move); -- interpreter.h */
 ACMD(do_not_here);
+ACMD(do_oasis);
 ACMD(do_olc);
 ACMD(do_order);
 ACMD(do_page);
@@ -139,7 +143,9 @@ ACMD(do_rescue);
 ACMD(do_rest);
 ACMD(do_restore);
 ACMD(do_return);
+ACMD(do_room_copy);
 ACMD(do_save);
+ACMD(do_saveall);
 ACMD(do_say);
 ACMD(do_score);
 ACMD(do_send);
@@ -185,6 +191,7 @@ ACMD(do_wizutil);
 ACMD(do_write);
 ACMD(do_zreset);
 
+struct command_info *complete_cmd_info;
 
 /* This is the Master Command List(tm).
 
@@ -200,346 +207,260 @@ ACMD(do_zreset);
  */
 
 cpp_extern const struct command_info cmd_info[] = {
-  { "RESERVED", 0, 0, 0, 0 },	/* this must be first -- for specprocs */
+  { "RESERVED", "", 0, 0, 0, 0 },	/* this must be first -- for specprocs */
 
   /* directions must come before other commands but after RESERVED */
-  { "north"    , POS_STANDING, do_move     , 0, SCMD_NORTH },
-  { "east"     , POS_STANDING, do_move     , 0, SCMD_EAST },
-  { "south"    , POS_STANDING, do_move     , 0, SCMD_SOUTH },
-  { "west"     , POS_STANDING, do_move     , 0, SCMD_WEST },
-  { "up"       , POS_STANDING, do_move     , 0, SCMD_UP },
-  { "down"     , POS_STANDING, do_move     , 0, SCMD_DOWN },
+  { "north"    , "n"       , POS_STANDING, do_move     , 0, SCMD_NORTH },
+  { "east"     , "e"       , POS_STANDING, do_move     , 0, SCMD_EAST },
+  { "south"    , "s"       , POS_STANDING, do_move     , 0, SCMD_SOUTH },
+  { "west"     , "w"       , POS_STANDING, do_move     , 0, SCMD_WEST },
+  { "up"       , "u"       , POS_STANDING, do_move     , 0, SCMD_UP },
+  { "down"     , "d"       , POS_STANDING, do_move     , 0, SCMD_DOWN },
 
   /* now, the main list */
-  { "at"       , POS_DEAD    , do_at       , LVL_IMMORT, 0 },
-  { "advance"  , POS_DEAD    , do_advance  , LVL_IMPL, 0 },
-  { "alias"    , POS_DEAD    , do_alias    , 0, 0 },
-  { "accuse"   , POS_SITTING , do_action   , 0, 0 },
-  { "applaud"  , POS_RESTING , do_action   , 0, 0 },
-  { "assist"   , POS_FIGHTING, do_assist   , 1, 0 },
-  { "ask"      , POS_RESTING , do_spec_comm, 0, SCMD_ASK },
-  { "auction"  , POS_SLEEPING, do_gen_comm , 0, SCMD_AUCTION },
-  { "autoexit" , POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOEXIT },
-
-  { "bounce"   , POS_STANDING, do_action   , 0, 0 },
-  { "backstab" , POS_STANDING, do_backstab , 1, 0 },
-  { "ban"      , POS_DEAD    , do_ban      , LVL_GRGOD, 0 },
-  { "balance"  , POS_STANDING, do_not_here , 1, 0 },
-  { "bash"     , POS_FIGHTING, do_bash     , 1, 0 },
-  { "beg"      , POS_RESTING , do_action   , 0, 0 },
-  { "bleed"    , POS_RESTING , do_action   , 0, 0 },
-  { "blush"    , POS_RESTING , do_action   , 0, 0 },
-  { "bow"      , POS_STANDING, do_action   , 0, 0 },
-  { "brb"      , POS_RESTING , do_action   , 0, 0 },
-  { "brief"    , POS_DEAD    , do_gen_tog  , 0, SCMD_BRIEF },
-  { "burp"     , POS_RESTING , do_action   , 0, 0 },
-  { "buy"      , POS_STANDING, do_not_here , 0, 0 },
-  { "bug"      , POS_DEAD    , do_gen_write, 0, SCMD_BUG },
+  { "at"       , "at"      , POS_DEAD    , do_at       , LVL_IMMORT, 0 },
+  { "advance"  , "adv"     , POS_DEAD    , do_advance  , LVL_IMPL, 0 },
+  { "aedit"    , "aed"     , POS_DEAD    , do_oasis    , LVL_GOD, SCMD_OASIS_AEDIT },
+  { "alias"    , "ali"     , POS_DEAD    , do_alias    , 0, 0 },
+  { "assist"   , "as"      , POS_FIGHTING, do_assist   , 1, 0 },
+  { "ask"      , "ask"     , POS_RESTING , do_spec_comm, 0, SCMD_ASK },
+  { "astat"    , "ast"     , POS_DEAD    , do_astat    , LVL_BUILDER, 0 },
+  { "auction"  , "auc"     , POS_SLEEPING, do_gen_comm , 0, SCMD_AUCTION },
+  { "autoexits" , "autoex"  , POS_DEAD    , do_gen_tog  , 0, SCMD_AUTOEXIT },
 
-  { "cast"     , POS_SITTING , do_cast     , 1, 0 },
-  { "cackle"   , POS_RESTING , do_action   , 0, 0 },
-  { "check"    , POS_STANDING, do_not_here , 1, 0 },
-  { "chuckle"  , POS_RESTING , do_action   , 0, 0 },
-  { "clap"     , POS_RESTING , do_action   , 0, 0 },
-  { "clear"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
-  { "close"    , POS_SITTING , do_gen_door , 0, SCMD_CLOSE },
-  { "cls"      , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
-  { "consider" , POS_RESTING , do_consider , 0, 0 },
-  { "color"    , POS_DEAD    , do_color    , 0, 0 },
-  { "comfort"  , POS_RESTING , do_action   , 0, 0 },
-  { "comb"     , POS_RESTING , do_action   , 0, 0 },
-  { "commands" , POS_DEAD    , do_commands , 0, SCMD_COMMANDS },
-  { "compact"  , POS_DEAD    , do_gen_tog  , 0, SCMD_COMPACT },
-  { "cough"    , POS_RESTING , do_action   , 0, 0 },
-  { "credits"  , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS },
-  { "cringe"   , POS_RESTING , do_action   , 0, 0 },
-  { "cry"      , POS_RESTING , do_action   , 0, 0 },
-  { "cuddle"   , POS_RESTING , do_action   , 0, 0 },
-  { "curse"    , POS_RESTING , do_action   , 0, 0 },
-  { "curtsey"  , POS_STANDING, do_action   , 0, 0 },
+  { "backstab" , "ba"      , POS_STANDING, do_backstab , 1, 0 },
+  { "ban"      , "ban"     , POS_DEAD    , do_ban      , LVL_GRGOD, 0 },
+  { "balance"  , "bal"     , POS_STANDING, do_not_here , 1, 0 },
+  { "bash"     , "bas"     , POS_FIGHTING, do_bash     , 1, 0 },
+  { "brief"    , "br"      , POS_DEAD    , do_gen_tog  , 0, SCMD_BRIEF },
+  { "buildwalk", "buildwalk", POS_STANDING, do_gen_tog,   LVL_BUILDER, SCMD_BUILDWALK },
+  { "buy"      , "bu"      , POS_STANDING, do_not_here , 0, 0 },
+  { "bug"      , "bug"     , POS_DEAD    , do_gen_write, 0, SCMD_BUG },
 
-  { "dance"    , POS_STANDING, do_action   , 0, 0 },
-  { "date"     , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_DATE },
-  { "daydream" , POS_SLEEPING, do_action   , 0, 0 },
-  { "dc"       , POS_DEAD    , do_dc       , LVL_GOD, 0 },
-  { "deposit"  , POS_STANDING, do_not_here , 1, 0 },
-  { "diagnose" , POS_RESTING , do_diagnose , 0, 0 },
-  { "display"  , POS_DEAD    , do_display  , 0, 0 },
-  { "donate"   , POS_RESTING , do_drop     , 0, SCMD_DONATE },
-  { "drink"    , POS_RESTING , do_drink    , 0, SCMD_DRINK },
-  { "drop"     , POS_RESTING , do_drop     , 0, SCMD_DROP },
-  { "drool"    , POS_RESTING , do_action   , 0, 0 },
+  { "cast"     , "c"       , POS_SITTING , do_cast     , 1, 0 },
+  { "cedit"    , "cedit"   , POS_DEAD    , do_oasis    , LVL_IMPL, SCMD_OASIS_CEDIT },
+  { "check"    , "ch"      , POS_STANDING, do_not_here , 1, 0 },
+  { "clear"    , "cle"     , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
+  { "close"    , "cl"      , POS_SITTING , do_gen_door , 0, SCMD_CLOSE },
+  { "cls"      , "cls"     , POS_DEAD    , do_gen_ps   , 0, SCMD_CLEAR },
+  { "clsolc"   , "clsolc"  , POS_DEAD    , do_gen_tog  , 0, SCMD_CLS },
+  { "consider" , "con"     , POS_RESTING , do_consider , 0, 0 },
+  { "color"    , "col"     , POS_DEAD    , do_color    , 0, 0 },
+  { "commands" , "com"     , POS_DEAD    , do_commands , 0, SCMD_COMMANDS },
+  { "compact"  , "comp"    , POS_DEAD    , do_gen_tog  , 0, SCMD_COMPACT },
+  { "credits"  , "cred"    , POS_DEAD    , do_gen_ps   , 0, SCMD_CREDITS },
 
-  { "eat"      , POS_RESTING , do_eat      , 0, SCMD_EAT },
-  { "echo"     , POS_SLEEPING, do_echo     , LVL_IMMORT, SCMD_ECHO },
-  { "emote"    , POS_RESTING , do_echo     , 1, SCMD_EMOTE },
-  { ":"        , POS_RESTING, do_echo      , 1, SCMD_EMOTE },
-  { "embrace"  , POS_STANDING, do_action   , 0, 0 },
-  { "enter"    , POS_STANDING, do_enter    , 0, 0 },
-  { "equipment", POS_SLEEPING, do_equipment, 0, 0 },
-  { "exits"    , POS_RESTING , do_exits    , 0, 0 },
-  { "examine"  , POS_SITTING , do_examine  , 0, 0 },
+  { "date"     , "da"      , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_DATE },
+  { "dc"       , "dc"      , POS_DEAD    , do_dc       , LVL_GOD, 0 },
+  { "deposit"  , "depo"    , POS_STANDING, do_not_here , 1, 0 },
+  { "diagnose" , "diag"    , POS_RESTING , do_diagnose , 0, 0 },
+  { "dig"      , "dig"     , POS_DEAD    , do_dig      , LVL_BUILDER, 0 },
+  { "display"  , "disp"    , POS_DEAD    , do_display  , 0, 0 },
+  { "donate"   , "don"     , POS_RESTING , do_drop     , 0, SCMD_DONATE },
+  { "drink"    , "dri"     , POS_RESTING , do_drink    , 0, SCMD_DRINK },
+  { "drop"     , "dro"     , POS_RESTING , do_drop     , 0, SCMD_DROP },
 
-  { "force"    , POS_SLEEPING, do_force    , LVL_GOD, 0 },
-  { "fart"     , POS_RESTING , do_action   , 0, 0 },
-  { "fill"     , POS_STANDING, do_pour     , 0, SCMD_FILL },
-  { "flee"     , POS_FIGHTING, do_flee     , 1, 0 },
-  { "flip"     , POS_STANDING, do_action   , 0, 0 },
-  { "flirt"    , POS_RESTING , do_action   , 0, 0 },
-  { "follow"   , POS_RESTING , do_follow   , 0, 0 },
-  { "fondle"   , POS_RESTING , do_action   , 0, 0 },
-  { "freeze"   , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE },
-  { "french"   , POS_RESTING , do_action   , 0, 0 },
-  { "frown"    , POS_RESTING , do_action   , 0, 0 },
-  { "fume"     , POS_RESTING , do_action   , 0, 0 },
+  { "eat"      , "ea"      , POS_RESTING , do_eat      , 0, SCMD_EAT },
+  { "echo"     , "ec"      , POS_SLEEPING, do_echo     , LVL_IMMORT, SCMD_ECHO },
+  { "edit"     , "ed"      , POS_DEAD    , do_edit	   , LVL_IMPL, 0 },	/* Testing! */
+  { "emote"    , "em"      , POS_RESTING , do_echo     , 1, SCMD_EMOTE },
+  { ":"        , ":"       , POS_RESTING, do_echo      , 1, SCMD_EMOTE },
+  { "enter"    , "ent"     , POS_STANDING, do_enter    , 0, 0 },
+  { "equipment", "eq"      , POS_SLEEPING, do_equipment, 0, 0 },
+  { "exits"    , "ex"      , POS_RESTING , do_exits    , 0, 0 },
+  { "examine"  , "exa"     , POS_SITTING , do_examine  , 0, 0 },
 
-  { "get"      , POS_RESTING , do_get      , 0, 0 },
-  { "gasp"     , POS_RESTING , do_action   , 0, 0 },
-  { "gecho"    , POS_DEAD    , do_gecho    , LVL_GOD, 0 },
-  { "give"     , POS_RESTING , do_give     , 0, 0 },
-  { "giggle"   , POS_RESTING , do_action   , 0, 0 },
-  { "glare"    , POS_RESTING , do_action   , 0, 0 },
-  { "goto"     , POS_SLEEPING, do_goto     , LVL_IMMORT, 0 },
-  { "gold"     , POS_RESTING , do_gold     , 0, 0 },
-  { "gossip"   , POS_SLEEPING, do_gen_comm , 0, SCMD_GOSSIP },
-  { "group"    , POS_RESTING , do_group    , 1, 0 },
-  { "grab"     , POS_RESTING , do_grab     , 0, 0 },
-  { "grats"    , POS_SLEEPING, do_gen_comm , 0, SCMD_GRATZ },
-  { "greet"    , POS_RESTING , do_action   , 0, 0 },
-  { "grin"     , POS_RESTING , do_action   , 0, 0 },
-  { "groan"    , POS_RESTING , do_action   , 0, 0 },
-  { "grope"    , POS_RESTING , do_action   , 0, 0 },
-  { "grovel"   , POS_RESTING , do_action   , 0, 0 },
-  { "growl"    , POS_RESTING , do_action   , 0, 0 },
-  { "gsay"     , POS_SLEEPING, do_gsay     , 0, 0 },
-  { "gtell"    , POS_SLEEPING, do_gsay     , 0, 0 },
+  { "force"    , "force"   , POS_SLEEPING, do_force    , LVL_GOD, 0 },
+  { "fill"     , "fil"     , POS_STANDING, do_pour     , 0, SCMD_FILL },
+  { "flee"     , "fl"      , POS_FIGHTING, do_flee     , 1, 0 },
+  { "follow"   , "fol"     , POS_RESTING , do_follow   , 0, 0 },
+  { "freeze"   , "freeze"  , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_FREEZE },
 
-  { "help"     , POS_DEAD    , do_help     , 0, 0 },
-  { "handbook" , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK },
-  { "hcontrol" , POS_DEAD    , do_hcontrol , LVL_GRGOD, 0 },
-  { "hiccup"   , POS_RESTING , do_action   , 0, 0 },
-  { "hide"     , POS_RESTING , do_hide     , 1, 0 },
-  { "hit"      , POS_FIGHTING, do_hit      , 0, SCMD_HIT },
-  { "hold"     , POS_RESTING , do_grab     , 1, 0 },
-  { "holler"   , POS_RESTING , do_gen_comm , 1, SCMD_HOLLER },
-  { "holylight", POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_HOLYLIGHT },
-  { "hop"      , POS_RESTING , do_action   , 0, 0 },
-  { "house"    , POS_RESTING , do_house    , 0, 0 },
-  { "hug"      , POS_RESTING , do_action   , 0, 0 },
+  { "get"      , "get"     , POS_RESTING , do_get      , 0, 0 },
+  { "gecho"    , "gecho"   , POS_DEAD    , do_gecho    , LVL_GOD, 0 },
+  { "give"     , "giv"     , POS_RESTING , do_give     , 0, 0 },
+  { "goto"     , "go"      , POS_SLEEPING, do_goto     , LVL_IMMORT, 0 },
+  { "gold"     , "gol"     , POS_RESTING , do_gold     , 0, 0 },
+  { "gossip"   , "gos"     , POS_SLEEPING, do_gen_comm , 0, SCMD_GOSSIP },
+  { "group"    , "gro"     , POS_RESTING , do_group    , 1, 0 },
+  { "grab"     , "grab"    , POS_RESTING , do_grab     , 0, 0 },
+  { "grats"    , "grat"    , POS_SLEEPING, do_gen_comm , 0, SCMD_GRATZ },
+  { "gsay"     , "gsay"    , POS_SLEEPING, do_gsay     , 0, 0 },
+  { "gtell"    , "gt"      , POS_SLEEPING, do_gsay     , 0, 0 },
 
-  { "inventory", POS_DEAD    , do_inventory, 0, 0 },
-  { "idea"     , POS_DEAD    , do_gen_write, 0, SCMD_IDEA },
-  { "imotd"    , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD },
-  { "immlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST },
-  { "info"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO },
-  { "insult"   , POS_RESTING , do_insult   , 0, 0 },
-  { "invis"    , POS_DEAD    , do_invis    , LVL_IMMORT, 0 },
+  { "help"     , "he"      , POS_DEAD    , do_help     , 0, 0 },
+  { "handbook" , "handb"   , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_HANDBOOK },
+  { "hcontrol" , "hcontrol", POS_DEAD    , do_hcontrol , LVL_GRGOD, 0 },
+  { "hide"     , "hide"    , POS_RESTING , do_hide     , 1, 0 },
+  { "hit"      , "hi"      , POS_FIGHTING, do_hit      , 0, SCMD_HIT },
+  { "hold"     , "hold"    , POS_RESTING , do_grab     , 1, 0 },
+  { "holler"   , "holler"  , POS_RESTING , do_gen_comm , 1, SCMD_HOLLER },
+  { "holylight", "holy"    , POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_HOLYLIGHT },
+  { "house"    , "house"   , POS_RESTING , do_house    , 0, 0 },
 
-  { "junk"     , POS_RESTING , do_drop     , 0, SCMD_JUNK },
+  { "inventory", "i"       , POS_DEAD    , do_inventory, 0, 0 },
+  { "idea"     , "id"      , POS_DEAD    , do_gen_write, 0, SCMD_IDEA },
+  { "imotd"    , "imo"     , POS_DEAD    , do_gen_ps   , LVL_IMMORT, SCMD_IMOTD },
+  { "immlist"  , "imm"     , POS_DEAD    , do_gen_ps   , 0, SCMD_IMMLIST },
+  { "info"     , "info"    , POS_SLEEPING, do_gen_ps   , 0, SCMD_INFO },
+  { "insult"   , "insult"  , POS_RESTING , do_insult   , 0, 0 },
+  { "invis"    , "invi"    , POS_DEAD    , do_invis    , LVL_IMMORT, 0 },
 
-  { "kill"     , POS_FIGHTING, do_kill     , 0, 0 },
-  { "kick"     , POS_FIGHTING, do_kick     , 1, 0 },
-  { "kiss"     , POS_RESTING , do_action   , 0, 0 },
+  { "junk"     , "junk"    , POS_RESTING , do_drop     , 0, SCMD_JUNK },
 
-  { "look"     , POS_RESTING , do_look     , 0, SCMD_LOOK },
-  { "laugh"    , POS_RESTING , do_action   , 0, 0 },
-  { "last"     , POS_DEAD    , do_last     , LVL_GOD, 0 },
-  { "leave"    , POS_STANDING, do_leave    , 0, 0 },
-  { "levels"   , POS_DEAD    , do_levels   , 0, 0 },
-  { "list"     , POS_STANDING, do_not_here , 0, 0 },
-  { "lick"     , POS_RESTING , do_action   , 0, 0 },
-  { "lock"     , POS_SITTING , do_gen_door , 0, SCMD_LOCK },
-  { "load"     , POS_DEAD    , do_load     , LVL_GOD, 0 },
-  { "love"     , POS_RESTING , do_action   , 0, 0 },
+  { "kill"     , "k"       , POS_FIGHTING, do_kill     , 0, 0 },
+  { "kick"     , "ki"      , POS_FIGHTING, do_kick     , 1, 0 },
 
-  { "moan"     , POS_RESTING , do_action   , 0, 0 },
-  { "motd"     , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD },
-  { "mail"     , POS_STANDING, do_not_here , 1, 0 },
-  { "massage"  , POS_RESTING , do_action   , 0, 0 },
-  { "mute"     , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH },
-  { "murder"   , POS_FIGHTING, do_hit      , 0, SCMD_MURDER },
+  { "look"     , "l"       , POS_RESTING , do_look     , 0, SCMD_LOOK },
+  { "last"     , "last"    , POS_DEAD    , do_last     , LVL_GOD, 0 },
+  { "leave"    , "lea"     , POS_STANDING, do_leave    , 0, 0 },
+  { "levels"   , "lev"     , POS_DEAD    , do_levels   , 0, 0 },
+  { "list"     , "lis"     , POS_STANDING, do_not_here , 0, 0 },
+  { "links"    , "lin"     , POS_STANDING, do_oasis    , LVL_BUILDER, SCMD_OASIS_LINKS },
+  { "lock"     , "loc"     , POS_SITTING , do_gen_door , 0, SCMD_LOCK },
+  { "load"     , "load"     , POS_DEAD    , do_load     , LVL_GOD, 0 },
 
-  { "news"     , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS },
-  { "nibble"   , POS_RESTING , do_action   , 0, 0 },
-  { "nod"      , POS_RESTING , do_action   , 0, 0 },
-  { "noauction", POS_DEAD    , do_gen_tog  , 0, SCMD_NOAUCTION },
-  { "nogossip" , POS_DEAD    , do_gen_tog  , 0, SCMD_NOGOSSIP },
-  { "nograts"  , POS_DEAD    , do_gen_tog  , 0, SCMD_NOGRATZ },
-  { "nohassle" , POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_NOHASSLE },
-  { "norepeat" , POS_DEAD    , do_gen_tog  , 0, SCMD_NOREPEAT },
-  { "noshout"  , POS_SLEEPING, do_gen_tog  , 1, SCMD_DEAF },
-  { "nosummon" , POS_DEAD    , do_gen_tog  , 1, SCMD_NOSUMMON },
-  { "notell"   , POS_DEAD    , do_gen_tog  , 1, SCMD_NOTELL },
-  { "notitle"  , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_NOTITLE },
-  { "nowiz"    , POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_NOWIZ },
-  { "nudge"    , POS_RESTING , do_action   , 0, 0 },
-  { "nuzzle"   , POS_RESTING , do_action   , 0, 0 },
+  { "motd"     , "motd"    , POS_DEAD    , do_gen_ps   , 0, SCMD_MOTD },
+  { "mail"     , "mail"    , POS_STANDING, do_not_here , 1, 0 },
+  { "medit"    , "medit"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_MEDIT },
+  { "mlist"    , "mlist"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_MLIST },
+  { "mute"     , "mute"    , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_SQUELCH },
 
-  { "olc"      , POS_DEAD    , do_olc      , LVL_IMPL, 0 },
-  { "order"    , POS_RESTING , do_order    , 1, 0 },
-  { "offer"    , POS_STANDING, do_not_here , 1, 0 },
-  { "open"     , POS_SITTING , do_gen_door , 0, SCMD_OPEN },
+  { "news"     , "news"    , POS_SLEEPING, do_gen_ps   , 0, SCMD_NEWS },
+  { "noauction", "noauction",POS_DEAD    , do_gen_tog  , 0, SCMD_NOAUCTION },
+  { "nogossip" , "nogossip", POS_DEAD    , do_gen_tog  , 0, SCMD_NOGOSSIP },
+  { "nograts"  , "nograts" , POS_DEAD    , do_gen_tog  , 0, SCMD_NOGRATZ },
+  { "nohassle" , "nohassle", POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_NOHASSLE },
+  { "norepeat" , "norepeat", POS_DEAD    , do_gen_tog  , 0, SCMD_NOREPEAT },
+  { "noshout"  , "noshout" , POS_SLEEPING, do_gen_tog  , 1, SCMD_DEAF },
+  { "nosummon" , "nosummon", POS_DEAD    , do_gen_tog  , 1, SCMD_NOSUMMON },
+  { "notell"   , "notell"  , POS_DEAD    , do_gen_tog  , 1, SCMD_NOTELL },
+  { "notitle"  , "notitle" , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_NOTITLE },
+  { "nowiz"    , "nowiz"   , POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_NOWIZ },
 
-  { "put"      , POS_RESTING , do_put      , 0, 0 },
-  { "pat"      , POS_RESTING , do_action   , 0, 0 },
-  { "page"     , POS_DEAD    , do_page     , LVL_GOD, 0 },
-  { "pardon"   , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_PARDON },
-  { "peer"     , POS_RESTING , do_action   , 0, 0 },
-  { "pick"     , POS_STANDING, do_gen_door , 1, SCMD_PICK },
-  { "point"    , POS_RESTING , do_action   , 0, 0 },
-  { "poke"     , POS_RESTING , do_action   , 0, 0 },
-  { "policy"   , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES },
-  { "ponder"   , POS_RESTING , do_action   , 0, 0 },
-  { "poofin"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN },
-  { "poofout"  , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT },
-  { "pour"     , POS_STANDING, do_pour     , 0, SCMD_POUR },
-  { "pout"     , POS_RESTING , do_action   , 0, 0 },
-  { "prompt"   , POS_DEAD    , do_display  , 0, 0 },
-  { "practice" , POS_RESTING , do_practice , 1, 0 },
-  { "pray"     , POS_SITTING , do_action   , 0, 0 },
-  { "puke"     , POS_RESTING , do_action   , 0, 0 },
-  { "punch"    , POS_RESTING , do_action   , 0, 0 },
-  { "purr"     , POS_RESTING , do_action   , 0, 0 },
-  { "purge"    , POS_DEAD    , do_purge    , LVL_GOD, 0 },
+  { "order"    , "ord"     , POS_RESTING , do_order    , 1, 0 },
+  { "offer"    , "off"     , POS_STANDING, do_not_here , 1, 0 },
+  { "open"     , "ope"     , POS_SITTING , do_gen_door , 0, SCMD_OPEN },
+  { "olc"      , "olc"     , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OLC_SAVEINFO },
+  { "olist"    , "olist"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_OLIST },
+  { "oedit"    , "oedit"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_OEDIT },
 
-  { "quaff"    , POS_RESTING , do_use      , 0, SCMD_QUAFF },
-  { "qecho"    , POS_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO },
-  { "quest"    , POS_DEAD    , do_gen_tog  , 0, SCMD_QUEST },
-  { "qui"      , POS_DEAD    , do_quit     , 0, 0 },
-  { "quit"     , POS_DEAD    , do_quit     , 0, SCMD_QUIT },
-  { "qsay"     , POS_RESTING , do_qcomm    , 0, SCMD_QSAY },
+  { "pick"     , "pi"      , POS_STANDING, do_gen_door , 1, SCMD_PICK },
+  { "put"      , "put"     , POS_RESTING , do_put      , 0, 0 },
+  { "page"     , "pag"     , POS_DEAD    , do_page     , LVL_GOD, 0 },
+  { "pardon"   , "pardon"  , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_PARDON },
+  { "policy"   , "pol"     , POS_DEAD    , do_gen_ps   , 0, SCMD_POLICIES },
+  { "poofin"   , "poofi"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFIN },
+  { "poofout"  , "poofo"   , POS_DEAD    , do_poofset  , LVL_IMMORT, SCMD_POOFOUT },
+  { "pour"     , "pour"    , POS_STANDING, do_pour     , 0, SCMD_POUR },
+  { "prompt"   , "pro"     , POS_DEAD    , do_display  , 0, 0 },
+  { "practice" , "pra"     , POS_RESTING , do_practice , 1, 0 },
+  { "purge"    , "purge"   , POS_DEAD    , do_purge    , LVL_GOD, 0 },
 
-  { "reply"    , POS_SLEEPING, do_reply    , 0, 0 },
-  { "rest"     , POS_RESTING , do_rest     , 0, 0 },
-  { "read"     , POS_RESTING , do_look     , 0, SCMD_READ },
-  { "reload"   , POS_DEAD    , do_reboot   , LVL_IMPL, 0 },
-  { "recite"   , POS_RESTING , do_use      , 0, SCMD_RECITE },
-  { "receive"  , POS_STANDING, do_not_here , 1, 0 },
-  { "remove"   , POS_RESTING , do_remove   , 0, 0 },
-  { "rent"     , POS_STANDING, do_not_here , 1, 0 },
-  { "report"   , POS_RESTING , do_report   , 0, 0 },
-  { "reroll"   , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL },
-  { "rescue"   , POS_FIGHTING, do_rescue   , 1, 0 },
-  { "restore"  , POS_DEAD    , do_restore  , LVL_GOD, 0 },
-  { "return"   , POS_DEAD    , do_return   , 0, 0 },
-  { "roll"     , POS_RESTING , do_action   , 0, 0 },
-  { "roomflags", POS_DEAD    , do_gen_tog  , LVL_IMMORT, SCMD_ROOMFLAGS },
-  { "ruffle"   , POS_STANDING, do_action   , 0, 0 },
+  { "quaff"    , "qua"     , POS_RESTING , do_use      , 0, SCMD_QUAFF },
+  { "qecho"    , "qec"     , POS_DEAD    , do_qcomm    , LVL_IMMORT, SCMD_QECHO },
+  { "quest"    , "que"     , POS_DEAD    , do_gen_tog  , 0, SCMD_QUEST },
+  { "qui"      , "qui"     , POS_DEAD    , do_quit     , 0, 0 },
+  { "quit"     , "quit"    , POS_DEAD    , do_quit     , 0, SCMD_QUIT },
+  { "qsay"     , "qsay"    , POS_RESTING , do_qcomm    , 0, SCMD_QSAY },
 
-  { "say"      , POS_RESTING , do_say      , 0, 0 },
-  { "'"        , POS_RESTING , do_say      , 0, 0 },
-  { "save"     , POS_SLEEPING, do_save     , 0, 0 },
-  { "score"    , POS_DEAD    , do_score    , 0, 0 },
-  { "scream"   , POS_RESTING , do_action   , 0, 0 },
-  { "sell"     , POS_STANDING, do_not_here , 0, 0 },
-  { "send"     , POS_SLEEPING, do_send     , LVL_GOD, 0 },
-  { "set"      , POS_DEAD    , do_set      , LVL_GOD, 0 },
-  { "shout"    , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT },
-  { "shake"    , POS_RESTING , do_action   , 0, 0 },
-  { "shiver"   , POS_RESTING , do_action   , 0, 0 },
-  { "show"     , POS_DEAD    , do_show     , LVL_IMMORT, 0 },
-  { "shrug"    , POS_RESTING , do_action   , 0, 0 },
-  { "shutdow"  , POS_DEAD    , do_shutdown , LVL_IMPL, 0 },
-  { "shutdown" , POS_DEAD    , do_shutdown , LVL_IMPL, SCMD_SHUTDOWN },
-  { "sigh"     , POS_RESTING , do_action   , 0, 0 },
-  { "sing"     , POS_RESTING , do_action   , 0, 0 },
-  { "sip"      , POS_RESTING , do_drink    , 0, SCMD_SIP },
-  { "sit"      , POS_RESTING , do_sit      , 0, 0 },
-  { "skillset" , POS_SLEEPING, do_skillset , LVL_GRGOD, 0 },
-  { "sleep"    , POS_SLEEPING, do_sleep    , 0, 0 },
-  { "slap"     , POS_RESTING , do_action   , 0, 0 },
-  { "slowns"   , POS_DEAD    , do_gen_tog  , LVL_IMPL, SCMD_SLOWNS },
-  { "smile"    , POS_RESTING , do_action   , 0, 0 },
-  { "smirk"    , POS_RESTING , do_action   , 0, 0 },
-  { "snicker"  , POS_RESTING , do_action   , 0, 0 },
-  { "snap"     , POS_RESTING , do_action   , 0, 0 },
-  { "snarl"    , POS_RESTING , do_action   , 0, 0 },
-  { "sneeze"   , POS_RESTING , do_action   , 0, 0 },
-  { "sneak"    , POS_STANDING, do_sneak    , 1, 0 },
-  { "sniff"    , POS_RESTING , do_action   , 0, 0 },
-  { "snore"    , POS_SLEEPING, do_action   , 0, 0 },
-  { "snowball" , POS_STANDING, do_action   , LVL_IMMORT, 0 },
-  { "snoop"    , POS_DEAD    , do_snoop    , LVL_GOD, 0 },
-  { "snuggle"  , POS_RESTING , do_action   , 0, 0 },
-  { "socials"  , POS_DEAD    , do_commands , 0, SCMD_SOCIALS },
-  { "split"    , POS_SITTING , do_split    , 1, 0 },
-  { "spank"    , POS_RESTING , do_action   , 0, 0 },
-  { "spit"     , POS_STANDING, do_action   , 0, 0 },
-  { "squeeze"  , POS_RESTING , do_action   , 0, 0 },
-  { "stand"    , POS_RESTING , do_stand    , 0, 0 },
-  { "stare"    , POS_RESTING , do_action   , 0, 0 },
-  { "stat"     , POS_DEAD    , do_stat     , LVL_IMMORT, 0 },
-  { "steal"    , POS_STANDING, do_steal    , 1, 0 },
-  { "steam"    , POS_RESTING , do_action   , 0, 0 },
-  { "stroke"   , POS_RESTING , do_action   , 0, 0 },
-  { "strut"    , POS_STANDING, do_action   , 0, 0 },
-  { "sulk"     , POS_RESTING , do_action   , 0, 0 },
-  { "switch"   , POS_DEAD    , do_switch   , LVL_GRGOD, 0 },
-  { "syslog"   , POS_DEAD    , do_syslog   , LVL_IMMORT, 0 },
+  { "reply"    , "rep"     , POS_SLEEPING, do_reply    , 0, 0 },
+  { "rest"     , "res"     , POS_RESTING , do_rest     , 0, 0 },
+  { "read"     , "rea"     , POS_RESTING , do_look     , 0, SCMD_READ },
+  { "reload"   , "reload"  , POS_DEAD    , do_reboot   , LVL_IMPL, 0 },
+  { "recite"   , "reci"    , POS_RESTING , do_use      , 0, SCMD_RECITE },
+  { "receive"  , "rece"    , POS_STANDING, do_not_here , 1, 0 },
+  { "remove"   , "rem"     , POS_RESTING , do_remove   , 0, 0 },
+  { "rent"     , "rent"    , POS_STANDING, do_not_here , 1, 0 },
+  { "report"   , "repo"    , POS_RESTING , do_report   , 0, 0 },
+  { "reroll"   , "rero"    , POS_DEAD    , do_wizutil  , LVL_GRGOD, SCMD_REROLL },
+  { "rescue"   , "resc"    , POS_FIGHTING, do_rescue   , 1, 0 },
+  { "restore"  , "resto"   , POS_DEAD    , do_restore  , LVL_GOD, 0 },
+  { "return"   , "retu"    , POS_DEAD    , do_return   , 0, 0 },
+  { "redit"    , "redit"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_REDIT },
+  { "rlist"    , "rlist"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_RLIST },
+  { "rclone"   , "rclone"  , POS_DEAD    , do_room_copy, LVL_BUILDER, 0 },
+  { "roomflags", "roomflags", POS_DEAD   , do_gen_tog  , LVL_IMMORT, SCMD_ROOMFLAGS },
 
-  { "tell"     , POS_DEAD    , do_tell     , 0, 0 },
-  { "tackle"   , POS_RESTING , do_action   , 0, 0 },
-  { "take"     , POS_RESTING , do_get      , 0, 0 },
-  { "tango"    , POS_STANDING, do_action   , 0, 0 },
-  { "taunt"    , POS_RESTING , do_action   , 0, 0 },
-  { "taste"    , POS_RESTING , do_eat      , 0, SCMD_TASTE },
-  { "teleport" , POS_DEAD    , do_teleport , LVL_GOD, 0 },
-  { "thank"    , POS_RESTING , do_action   , 0, 0 },
-  { "think"    , POS_RESTING , do_action   , 0, 0 },
-  { "thaw"     , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW },
-  { "title"    , POS_DEAD    , do_title    , 0, 0 },
-  { "tickle"   , POS_RESTING , do_action   , 0, 0 },
-  { "time"     , POS_DEAD    , do_time     , 0, 0 },
-  { "toggle"   , POS_DEAD    , do_toggle   , 0, 0 },
-  { "track"    , POS_STANDING, do_track    , 0, 0 },
-  { "trackthru", POS_DEAD    , do_gen_tog  , LVL_IMPL, SCMD_TRACK },
-  { "transfer" , POS_SLEEPING, do_trans    , LVL_GOD, 0 },
-  { "twiddle"  , POS_RESTING , do_action   , 0, 0 },
-  { "typo"     , POS_DEAD    , do_gen_write, 0, SCMD_TYPO },
+  { "score"    , "sc"      , POS_DEAD    , do_score    , 0, 0 },
+  { "say"      , "say"     , POS_RESTING , do_say      , 0, 0 },
+  { "'"        , "'"       , POS_RESTING , do_say      , 0, 0 },
+  { "save"     , "sav"     , POS_SLEEPING, do_save     , 0, 0 },
+  { "saveall"  , "saveall" , POS_DEAD    , do_saveall  , LVL_BUILDER, 0},
+  { "sell"     , "sell"    , POS_STANDING, do_not_here , 0, 0 },
+  { "sedit"    , "sedit"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_SEDIT },
+  { "send"     , "send"    , POS_SLEEPING, do_send     , LVL_GOD, 0 },
+  { "set"      , "set"     , POS_DEAD    , do_set      , LVL_GOD, 0 },
+  { "shout"    , "sho"     , POS_RESTING , do_gen_comm , 0, SCMD_SHOUT },
+  { "show"     , "show"    , POS_DEAD    , do_show     , LVL_IMMORT, 0 },
+  { "shutdow"  , "shutdow" , POS_DEAD    , do_shutdown , LVL_IMPL, 0 },
+  { "shutdown" , "shutdown", POS_DEAD    , do_shutdown , LVL_IMPL, SCMD_SHUTDOWN },
+  { "sip"      , "sip"     , POS_RESTING , do_drink    , 0, SCMD_SIP },
+  { "sit"      , "sit"     , POS_RESTING , do_sit      , 0, 0 },
+  { "skillset" , "skillset", POS_SLEEPING, do_skillset , LVL_GRGOD, 0 },
+  { "sleep"    , "sl"      , POS_SLEEPING, do_sleep    , 0, 0 },
+  { "slist"    , "slist"   , POS_SLEEPING, do_oasis    , LVL_BUILDER, SCMD_OASIS_SLIST },
+  { "slowns"   , "slowns"  , POS_DEAD    , do_gen_tog  , LVL_IMPL, SCMD_SLOWNS },
+  { "sneak"    , "sneak"   , POS_STANDING, do_sneak    , 1, 0 },
+  { "snoop"    , "snoop"   , POS_DEAD    , do_snoop    , LVL_GOD, 0 },
+  { "socials"  , "socials" , POS_DEAD    , do_commands , 0, SCMD_SOCIALS },
+  { "split"    , "split"   , POS_SITTING , do_split    , 1, 0 },
+  { "stand"    , "st"      , POS_RESTING , do_stand    , 0, 0 },
+  { "stat"     , "stat"    , POS_DEAD    , do_stat     , LVL_IMMORT, 0 },
+  { "steal"    , "ste"     , POS_STANDING, do_steal    , 1, 0 },
+  { "switch"   , "switch"  , POS_DEAD    , do_switch   , LVL_GRGOD, 0 },
+  { "syslog"   , "syslog"  , POS_DEAD    , do_syslog   , LVL_IMMORT, 0 },
 
-  { "unlock"   , POS_SITTING , do_gen_door , 0, SCMD_UNLOCK },
-  { "ungroup"  , POS_DEAD    , do_ungroup  , 0, 0 },
-  { "unban"    , POS_DEAD    , do_unban    , LVL_GRGOD, 0 },
-  { "unaffect" , POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_UNAFFECT },
-  { "uptime"   , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_UPTIME },
-  { "use"      , POS_SITTING , do_use      , 1, SCMD_USE },
-  { "users"    , POS_DEAD    , do_users    , LVL_IMMORT, 0 },
+  { "tell"     , "t"       , POS_DEAD    , do_tell     , 0, 0 },
+  { "take"     , "ta"      , POS_RESTING , do_get      , 0, 0 },
+  { "taste"    , "tas"     , POS_RESTING , do_eat      , 0, SCMD_TASTE },
+  { "teleport" , "tele"    , POS_DEAD    , do_teleport , LVL_GOD, 0 },
+  { "tedit"    , "tedit"   , POS_DEAD    , do_tedit    , LVL_GRGOD, 0 },  /* XXX: Oasisify */
+  { "thaw"     , "thaw"    , POS_DEAD    , do_wizutil  , LVL_FREEZE, SCMD_THAW },
+  { "title"    , "title"   , POS_DEAD    , do_title    , 0, 0 },
+  { "time"     , "time"    , POS_DEAD    , do_time     , 0, 0 },
+  { "toggle"   , "toggle"  , POS_DEAD    , do_toggle   , 0, 0 },
+  { "track"    , "track"   , POS_STANDING, do_track    , 0, 0 },
+  { "trackthru", "trackthru",POS_DEAD    , do_gen_tog  , LVL_IMPL, SCMD_TRACK },
+  { "transfer" , "transfer", POS_SLEEPING, do_trans    , LVL_GOD, 0 },
+  { "typo"     , "typo"    , POS_DEAD    , do_gen_write, 0, SCMD_TYPO },
 
-  { "value"    , POS_STANDING, do_not_here , 0, 0 },
-  { "version"  , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION },
-  { "visible"  , POS_RESTING , do_visible  , 1, 0 },
-  { "vnum"     , POS_DEAD    , do_vnum     , LVL_IMMORT, 0 },
-  { "vstat"    , POS_DEAD    , do_vstat    , LVL_IMMORT, 0 },
+  { "unlock"   , "unlock"  , POS_SITTING , do_gen_door , 0, SCMD_UNLOCK },
+  { "ungroup"  , "ungroup" , POS_DEAD    , do_ungroup  , 0, 0 },
+  { "unban"    , "unban"   , POS_DEAD    , do_unban    , LVL_GRGOD, 0 },
+  { "unaffect" , "unaffect", POS_DEAD    , do_wizutil  , LVL_GOD, SCMD_UNAFFECT },
+  { "uptime"   , "uptime"  , POS_DEAD    , do_date     , LVL_IMMORT, SCMD_UPTIME },
+  { "use"      , "use"     , POS_SITTING , do_use      , 1, SCMD_USE },
+  { "users"    , "users"   , POS_DEAD    , do_users    , LVL_IMMORT, 0 },
 
-  { "wake"     , POS_SLEEPING, do_wake     , 0, 0 },
-  { "wave"     , POS_RESTING , do_action   , 0, 0 },
-  { "wear"     , POS_RESTING , do_wear     , 0, 0 },
-  { "weather"  , POS_RESTING , do_weather  , 0, 0 },
-  { "who"      , POS_DEAD    , do_who      , 0, 0 },
-  { "whoami"   , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI },
-  { "where"    , POS_RESTING , do_where    , 1, 0 },
-  { "whisper"  , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER },
-  { "whine"    , POS_RESTING , do_action   , 0, 0 },
-  { "whistle"  , POS_RESTING , do_action   , 0, 0 },
-  { "wield"    , POS_RESTING , do_wield    , 0, 0 },
-  { "wiggle"   , POS_STANDING, do_action   , 0, 0 },
-  { "wimpy"    , POS_DEAD    , do_wimpy    , 0, 0 },
-  { "wink"     , POS_RESTING , do_action   , 0, 0 },
-  { "withdraw" , POS_STANDING, do_not_here , 1, 0 },
-  { "wiznet"   , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 },
-  { ";"        , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 },
-  { "wizhelp"  , POS_SLEEPING, do_commands , LVL_IMMORT, SCMD_WIZHELP },
-  { "wizlist"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST },
-  { "wizlock"  , POS_DEAD    , do_wizlock  , LVL_IMPL, 0 },
-  { "worship"  , POS_RESTING , do_action   , 0, 0 },
-  { "write"    , POS_STANDING, do_write    , 1, 0 },
+  { "value"    , "val"     , POS_STANDING, do_not_here , 0, 0 },
+  { "version"  , "ver"     , POS_DEAD    , do_gen_ps   , 0, SCMD_VERSION },
+  { "visible"  , "vis"     , POS_RESTING , do_visible  , 1, 0 },
+  { "vnum"     , "vnum"    , POS_DEAD    , do_vnum     , LVL_IMMORT, 0 },
+  { "vstat"    , "vstat"   , POS_DEAD    , do_vstat    , LVL_IMMORT, 0 },
 
-  { "yawn"     , POS_RESTING , do_action   , 0, 0 },
-  { "yodel"    , POS_RESTING , do_action   , 0, 0 },
+  { "wake"     , "wake"    , POS_SLEEPING, do_wake     , 0, 0 },
+  { "wear"     , "wea"     , POS_RESTING , do_wear     , 0, 0 },
+  { "weather"  , "weather" , POS_RESTING , do_weather  , 0, 0 },
+  { "who"      , "who"     , POS_DEAD    , do_who      , 0, 0 },
+  { "whoami"   , "whoami"  , POS_DEAD    , do_gen_ps   , 0, SCMD_WHOAMI },
+  { "where"    , "where"   , POS_RESTING , do_where    , 1, 0 },
+  { "whisper"  , "whisper" , POS_RESTING , do_spec_comm, 0, SCMD_WHISPER },
+  { "wield"    , "wie"     , POS_RESTING , do_wield    , 0, 0 },
+  { "wimpy"    , "wimpy"   , POS_DEAD    , do_wimpy    , 0, 0 },
+  { "withdraw" , "withdraw", POS_STANDING, do_not_here , 1, 0 },
+  { "wiznet"   , "wiz"     , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 },
+  { ";"        , ";"       , POS_DEAD    , do_wiznet   , LVL_IMMORT, 0 },
+  { "wizhelp"  , "wizhelp" , POS_SLEEPING, do_commands , LVL_IMMORT, SCMD_WIZHELP },
+  { "wizlist"  , "wizlist" , POS_DEAD    , do_gen_ps   , 0, SCMD_WIZLIST },
+  { "wizlock"  , "wizlock" , POS_DEAD    , do_wizlock  , LVL_IMPL, 0 },
+  { "write"    , "write"   , POS_STANDING, do_write    , 1, 0 },
 
-  { "zreset"   , POS_DEAD    , do_zreset   , LVL_GRGOD, 0 },
+  { "zreset"   , "zreset"  , POS_DEAD    , do_zreset   , LVL_GRGOD, 0 },
+  { "zedit"    , "zedit"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_ZEDIT },
+  { "zlist"    , "zlist"   , POS_DEAD    , do_oasis    , LVL_BUILDER, SCMD_OASIS_ZLIST },
 
-  { "\n", 0, 0, 0, 0 } };	/* this must be last */
+  { "\n", "zzzzzzz", 0, 0, 0, 0 } };	/* this must be last */
 
 
 const char *fill[] =
@@ -598,20 +519,20 @@ void command_interpreter(struct char_dat
     line = any_one_arg(argument, arg);
 
   /* otherwise, find the command */
-  for (length = strlen(arg), cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
-    if (!strncmp(cmd_info[cmd].command, arg, length))
-      if (GET_LEVEL(ch) >= cmd_info[cmd].minimum_level)
+  for (length = strlen(arg), cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++)
+    if (!strncmp(complete_cmd_info[cmd].command, arg, length))
+      if (GET_LEVEL(ch) >= complete_cmd_info[cmd].minimum_level)
 	break;
 
-  if (*cmd_info[cmd].command == '\n')
+  if (*complete_cmd_info[cmd].command == '\n')
     send_to_char(ch, "Huh?!?\r\n");
   else if (!IS_NPC(ch) && PLR_FLAGGED(ch, PLR_FROZEN) && GET_LEVEL(ch) < LVL_IMPL)
     send_to_char(ch, "You try, but the mind-numbing cold prevents you...\r\n");
-  else if (cmd_info[cmd].command_pointer == NULL)
+  else if (complete_cmd_info[cmd].command_pointer == NULL)
     send_to_char(ch, "Sorry, that command hasn't been implemented yet.\r\n");
-  else if (IS_NPC(ch) && cmd_info[cmd].minimum_level >= LVL_IMMORT)
+  else if (IS_NPC(ch) && complete_cmd_info[cmd].minimum_level >= LVL_IMMORT)
     send_to_char(ch, "You can't use immortal commands while switched.\r\n");
-  else if (GET_POS(ch) < cmd_info[cmd].minimum_position)
+  else if (GET_POS(ch) < complete_cmd_info[cmd].minimum_position)
     switch (GET_POS(ch)) {
     case POS_DEAD:
       send_to_char(ch, "Lie still; you are DEAD!!! :-(\r\n");
@@ -636,7 +557,7 @@ void command_interpreter(struct char_dat
       send_to_char(ch, "No way!  You're fighting for your life!\r\n");
       break;
   } else if (no_specials || !special(ch, cmd, line))
-    ((*cmd_info[cmd].command_pointer) (ch, line, cmd, cmd_info[cmd].subcmd));
+    ((*complete_cmd_info[cmd].command_pointer) (ch, line, cmd, complete_cmd_info[cmd].subcmd));
 }
 
 /**************************************************************************
@@ -1072,8 +993,8 @@ int find_command(const char *command)
 {
   int cmd;
 
-  for (cmd = 0; *cmd_info[cmd].command != '\n'; cmd++)
-    if (!strcmp(cmd_info[cmd].command, command))
+  for (cmd = 0; *complete_cmd_info[cmd].command != '\n'; cmd++)
+    if (!strcmp(complete_cmd_info[cmd].command, command))
       return (cmd);
 
   return (-1);
@@ -1281,9 +1202,35 @@ int perform_dupe_check(struct descriptor
 void nanny(struct descriptor_data *d, char *arg)
 {
   int load_result;	/* Overloaded variable */
+  int player_i;
+
+  /* OasisOLC states */
+  struct {
+    int state;
+    void (*func)(struct descriptor_data *, char *);
+  } olc_functions[] = {
+    { CON_OEDIT, oedit_parse },
+    { CON_ZEDIT, zedit_parse },
+    { CON_SEDIT, sedit_parse },
+    { CON_MEDIT, medit_parse },
+    { CON_REDIT, redit_parse },
+    { CON_CEDIT, cedit_parse },
+    { CON_AEDIT, aedit_parse },
+    { -1, NULL }
+  };
 
   skip_spaces(&arg);
 
+  /*
+   * Quick check for the OLC states.
+   */
+  for (player_i = 0; olc_functions[player_i].state >= 0; player_i++)
+    if (STATE(d) == olc_functions[player_i].state) {
+      (*olc_functions[player_i].func)(d, arg);
+      return;
+    }
+
+  /* Not in OLC. */
   switch (STATE(d)) {
   case CON_GET_NAME:		/* wait for input of name */
     if (d->character == NULL) {
@@ -1372,7 +1319,8 @@ void nanny(struct descriptor_data *d, ch
       STATE(d) = CON_NEWPASSWD;
     } else if (*arg == 'n' || *arg == 'N') {
       write_to_output(d, "Okay, what IS it, then? ");
-      free_char(d->character);
+      free(d->character->player.name);
+      d->character->player.name = NULL;
       STATE(d) = CON_GET_NAME;
     } else
       write_to_output(d, "Please type Yes or No: ");
@@ -1401,7 +1349,7 @@ void nanny(struct descriptor_data *d, ch
 	mudlog(BRF, LVL_GOD, TRUE, "Bad PW: %s [%s]", GET_NAME(d->character), d->host);
 	GET_BAD_PWS(d->character)++;
 	save_char(d->character);
-	if (++(d->bad_pws) >= max_bad_pws) {	/* 3 strikes and you're out. */
+	if (++(d->bad_pws) >= CONFIG_MAX_BAD_PWS) {	/* 3 strikes and you're out. */
 	  write_to_output(d, "Wrong password... disconnecting.\r\n");
 	  STATE(d) = CON_CLOSE;
 	} else {
@@ -1438,7 +1386,13 @@ void nanny(struct descriptor_data *d, ch
       else
 	write_to_output(d, "%s", motd);
 
-      mudlog(BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE, "%s [%s] has connected.", GET_NAME(d->character), d->host);
+      if (GET_INVIS_LEV(d->character)) 
+        mudlog(BRF, MAX(LVL_IMMORT, GET_INVIS_LEV(d->character)), TRUE, 
+        "%s [%s] has connected. (invis %d)", GET_NAME(d->character), d->host, 
+        GET_INVIS_LEV(d->character));
+      else
+        mudlog(BRF, LVL_IMMORT, TRUE, 
+               "%s [%s] has connected.", GET_NAME(d->character), d->host);
 
       if (load_result) {
         write_to_output(d, "\r\n\r\n\007\007\007"
@@ -1487,7 +1441,7 @@ void nanny(struct descriptor_data *d, ch
       STATE(d) = CON_QSEX;
     } else {
       save_char(d->character);
-      write_to_output(d, "\r\nDone.\r\n%s", MENU);
+      write_to_output(d, "\r\nDone.\r\n%s", CONFIG_MENU);
       STATE(d) = CON_MENU;
     }
     break;
@@ -1532,7 +1486,7 @@ void nanny(struct descriptor_data *d, ch
     break;
 
   case CON_RMOTD:		/* read CR after printing motd   */
-    write_to_output(d, "%s", MENU);
+    write_to_output(d, "%s", CONFIG_MENU);
     STATE(d) = CON_MENU;
     break;
 
@@ -1570,7 +1524,7 @@ void nanny(struct descriptor_data *d, ch
       if (PLR_FLAGGED(d->character, PLR_FROZEN))
 	load_room = r_frozen_start_room;
 
-      send_to_char(d->character, "%s", WELC_MESSG);
+      send_to_char(d->character, "%s", CONFIG_WELC_MESSG);
       d->character->next = character_list;
       character_list = d->character;
       char_to_room(d->character, load_room);
@@ -1586,7 +1540,7 @@ void nanny(struct descriptor_data *d, ch
       STATE(d) = CON_PLAYING;
       if (GET_LEVEL(d->character) == 0) {
 	do_start(d->character);
-	send_to_char(d->character, "%s", START_MESSG);
+	send_to_char(d->character, "%s", CONFIG_START_MESSG);
       }
       look_at_room(d->character, 0);
       if (has_mail(GET_IDNUM(d->character)))
@@ -1600,12 +1554,19 @@ void nanny(struct descriptor_data *d, ch
 
     case '2':
       if (d->character->player.description) {
-	write_to_output(d, "Old description:\r\n%s", d->character->player.description);
-	free(d->character->player.description);
-	d->character->player.description = NULL;
+	write_to_output(d, "Current description:\r\n%s", d->character->player.description);
+	/*
+	 * Don't free this now... so that the old description gets loaded
+	 * as the current buffer in the editor.  Do setup the ABORT buffer
+	 * here, however.
+	 *
+	 * free(d->character->player.description);
+	 * d->character->player.description = NULL;
+	 */
+	d->backstr = strdup(d->character->player.description);
       }
-      write_to_output(d, "Enter the new text you'd like others to see when they look at you.\r\n"
-		"Terminate with a '@' on a new line.\r\n");
+      write_to_output(d, "Enter the new text you'd like others to see when they look at you.\r\n");
+      send_editor_help(d);
       d->str = &d->character->player.description;
       d->max_str = EXDSCR_LENGTH;
       STATE(d) = CON_EXDESC;
@@ -1629,7 +1590,7 @@ void nanny(struct descriptor_data *d, ch
       break;
 
     default:
-      write_to_output(d, "\r\nThat's not a menu choice!\r\n%s", MENU);
+      write_to_output(d, "\r\nThat's not a menu choice!\r\n%s", CONFIG_MENU);
       break;
     }
     break;
@@ -1638,7 +1599,7 @@ void nanny(struct descriptor_data *d, ch
   case CON_CHPWD_GETOLD:
     if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
       echo_on(d);
-      write_to_output(d, "\r\nIncorrect password.\r\n%s", MENU);
+      write_to_output(d, "\r\nIncorrect password.\r\n%s", CONFIG_MENU);
       STATE(d) = CON_MENU;
     } else {
       write_to_output(d, "\r\nEnter a new password: ");
@@ -1649,7 +1610,7 @@ void nanny(struct descriptor_data *d, ch
   case CON_DELCNF1:
     echo_on(d);
     if (strncmp(CRYPT(arg, GET_PASSWD(d->character)), GET_PASSWD(d->character), MAX_PWD_LENGTH)) {
-      write_to_output(d, "\r\nIncorrect password.\r\n%s", MENU);
+      write_to_output(d, "\r\nIncorrect password.\r\n%s", CONFIG_MENU);
       STATE(d) = CON_MENU;
     } else {
       write_to_output(d, "\r\nYOU ARE ABOUT TO DELETE THIS CHARACTER PERMANENTLY.\r\n"
@@ -1678,7 +1639,7 @@ void nanny(struct descriptor_data *d, ch
       STATE(d) = CON_CLOSE;
       return;
     } else {
-      write_to_output(d, "\r\nCharacter not deleted.\r\n%s", MENU);
+      write_to_output(d, "\r\nCharacter not deleted.\r\n%s", CONFIG_MENU);
       STATE(d) = CON_MENU;
     }
     break;
diff -BENbdpru circle-3.1/src/interpreter.h circle3.1_oasis206/src/interpreter.h
--- circle-3.1/src/interpreter.h	2001-06-28 17:03:54.000000000 +0200
+++ circle3.1_oasis206/src/interpreter.h	2003-10-07 10:21:00.000000000 +0200
@@ -13,9 +13,9 @@
 
 ACMD(do_move);
 
-#define CMD_NAME (cmd_info[cmd].command)
-#define CMD_IS(cmd_name) (!strcmp(cmd_name, cmd_info[cmd].command))
-#define IS_MOVE(cmdnum) (cmd_info[cmdnum].command_pointer == do_move)
+#define CMD_NAME (complete_cmd_info[cmd].command)
+#define CMD_IS(cmd_name) (!strcmp(cmd_name, complete_cmd_info[cmd].command))
+#define IS_MOVE(cmdnum) (complete_cmd_info[cmdnum].command_pointer == do_move)
 
 void	command_interpreter(struct char_data *ch, char *argument);
 int	search_block(char *arg, const char **list, int exact);
@@ -33,12 +33,19 @@ int	find_command(const char *command);
 void	skip_spaces(char **string);
 char	*delete_doubledollar(char *string);
 
+/* WARNING: if you have added diagonal directions and have them at the
+ * beginning of the command list.. change this value to 11 or 15 (depending) */
+/* reserve these commands to come straight from the cmd list then start
+ * sorting */
+#define RESERVE_CMDS                7
+
 /* for compatibility with 2.20: */
 #define argument_interpreter(a, b, c) two_arguments(a, b, c)
 
 
 struct command_info {
    const char *command;
+   const char *sort_as;
    byte minimum_position;
    void	(*command_pointer)
 	   (struct char_data *ch, char *argument, int cmd, int subcmd);
@@ -51,7 +58,7 @@ struct command_info {
  * so it has been moved down here.
  */
 #ifndef __INTERPRETER_C__
-extern const struct command_info cmd_info[];
+extern struct command_info *complete_cmd_info;
 #endif
 
 /*
@@ -119,6 +126,8 @@ struct alias_data {
 #define SCMD_SLOWNS	14
 #define SCMD_AUTOEXIT	15
 #define SCMD_TRACK	16
+#define SCMD_CLS        17
+#define SCMD_BUILDWALK  18
 
 /* do_wizutil */
 #define SCMD_REROLL	0
@@ -208,3 +217,19 @@ struct alias_data {
 #define SCMD_UNLOCK     2
 #define SCMD_LOCK       3
 #define SCMD_PICK       4
+
+/* do_olc */
+#define SCMD_OASIS_REDIT	0
+#define SCMD_OASIS_OEDIT	1
+#define SCMD_OASIS_ZEDIT	2
+#define SCMD_OASIS_MEDIT	3
+#define SCMD_OASIS_SEDIT	4
+#define SCMD_OASIS_CEDIT	5
+#define SCMD_OLC_SAVEINFO	7
+#define SCMD_OASIS_RLIST 	8
+#define SCMD_OASIS_MLIST	9
+#define SCMD_OASIS_OLIST	10
+#define SCMD_OASIS_SLIST	11
+#define SCMD_OASIS_ZLIST        12
+#define SCMD_OASIS_LINKS        13
+#define SCMD_OASIS_AEDIT        14
diff -BENbdpru circle-3.1/src/limits.c circle3.1_oasis206/src/limits.c
--- circle-3.1/src/limits.c	2002-11-13 20:30:52.000000000 +0100
+++ circle3.1_oasis206/src/limits.c	2003-07-26 10:19:22.000000000 +0200
@@ -20,17 +20,6 @@
 #include "interpreter.h"
 
 
-/* external variables */
-extern int max_exp_gain;
-extern int max_exp_loss;
-extern int idle_rent_time;
-extern int idle_max_level;
-extern int idle_void;
-extern int immort_level_ok;
-extern int use_autowiz;
-extern int min_wizlist_lev;
-extern int free_rent;
-
 /* local functions */
 int graf(int grafage, int p0, int p1, int p2, int p3, int p4, int p5, int p6);
 void run_autowiz(void);
@@ -225,16 +214,16 @@ void set_title(struct char_data *ch, cha
 void run_autowiz(void)
 {
 #if defined(CIRCLE_UNIX) || defined(CIRCLE_WINDOWS)
-  if (use_autowiz) {
+  if (CONFIG_USE_AUTOWIZ) {
     size_t res;
     char buf[256];
 
 #if defined(CIRCLE_UNIX)
     res = snprintf(buf, sizeof(buf), "nice ../bin/autowiz %d %s %d %s %d &",
-	min_wizlist_lev, WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
+	CONFIG_MIN_WIZLIST_LEV, WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE, (int) getpid());
 #elif defined(CIRCLE_WINDOWS)
     res = snprintf(buf, sizeof(buf), "autowiz %d %s %d %s",
-	min_wizlist_lev, WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE);
+	CONFIG_MIN_WIZLIST_LEV, WIZLIST_FILE, LVL_IMMORT, IMMLIST_FILE);
 #endif /* CIRCLE_WINDOWS */
 
     /* Abusing signed -> unsigned conversion to avoid '-1' check. */
@@ -263,9 +252,9 @@ void gain_exp(struct char_data *ch, int 
     return;
   }
   if (gain > 0) {
-    gain = MIN(max_exp_gain, gain);	/* put a cap on the max gain per kill */
+    gain = MIN(CONFIG_MAX_EXP_GAIN, gain);	/* put a cap on the max gain per kill */
     GET_EXP(ch) += gain;
-    while (GET_LEVEL(ch) < LVL_IMMORT - immort_level_ok &&
+    while (GET_LEVEL(ch) < LVL_IMMORT - CONFIG_IMMORT_LEVEL_OK &&
 	GET_EXP(ch) >= level_exp(GET_CLASS(ch), GET_LEVEL(ch) + 1)) {
       GET_LEVEL(ch) += 1;
       num_levels++;
@@ -285,7 +274,7 @@ void gain_exp(struct char_data *ch, int 
         run_autowiz();
     }
   } else if (gain < 0) {
-    gain = MAX(-max_exp_loss, gain);	/* Cap max exp lost per death */
+    gain = MAX(-CONFIG_MAX_EXP_LOSS, gain);	/* Cap max exp lost per death */
     GET_EXP(ch) += gain;
     if (GET_EXP(ch) < 0)
       GET_EXP(ch) = 0;
@@ -363,7 +352,7 @@ void gain_condition(struct char_data *ch
 
 void check_idling(struct char_data *ch)
 {
-  if (++(ch->char_specials.timer) > idle_void) {
+  if (++(ch->char_specials.timer) > CONFIG_IDLE_VOID) {
     if (GET_WAS_IN(ch) == NOWHERE && IN_ROOM(ch) != NOWHERE) {
       GET_WAS_IN(ch) = IN_ROOM(ch);
       if (FIGHTING(ch)) {
@@ -376,7 +365,7 @@ void check_idling(struct char_data *ch)
       Crash_crashsave(ch);
       char_from_room(ch);
       char_to_room(ch, 1);
-    } else if (ch->char_specials.timer > idle_rent_time) {
+    } else if (ch->char_specials.timer > CONFIG_IDLE_RENT_TIME) {
       if (IN_ROOM(ch) != NOWHERE)
 	char_from_room(ch);
       char_to_room(ch, 3);
@@ -389,7 +378,7 @@ void check_idling(struct char_data *ch)
 	ch->desc->character = NULL;
 	ch->desc = NULL;
       }
-      if (free_rent)
+      if (CONFIG_FREE_RENT)
 	Crash_rentsave(ch, 0);
       else
 	Crash_idlesave(ch);
@@ -433,7 +422,7 @@ void point_update(void)
     }
     if (!IS_NPC(i)) {
       update_char_objects(i);
-      if (GET_LEVEL(i) < idle_max_level)
+      if (GET_LEVEL(i) < CONFIG_IDLE_MAX_LEVEL)
 	check_idling(i);
     }
   }
diff -BENbdpru circle-3.1/src/magic.c circle3.1_oasis206/src/magic.c
--- circle-3.1/src/magic.c	2002-11-18 22:23:38.000000000 +0100
+++ circle3.1_oasis206/src/magic.c	2003-07-26 10:19:22.000000000 +0200
@@ -24,7 +24,6 @@
 
 /* external variables */
 extern int mini_mud;
-extern int pk_allowed;
 extern struct spell_info_type spell_info[];
 
 /* external functions */
@@ -352,7 +351,7 @@ void mag_affects(int level, struct char_
 
   case SPELL_CURSE:
     if (mag_savingthrow(victim, savetype, 0)) {
-      send_to_char(ch, "%s", NOEFFECT);
+      send_to_char(ch, "%s", CONFIG_NOEFFECT);
       return;
     }
 
@@ -416,7 +415,7 @@ void mag_affects(int level, struct char_
 
   case SPELL_POISON:
     if (mag_savingthrow(victim, savetype, 0)) {
-      send_to_char(ch, "%s", NOEFFECT);
+      send_to_char(ch, "%s", CONFIG_NOEFFECT);
       return;
     }
 
@@ -445,7 +444,7 @@ void mag_affects(int level, struct char_
     break;
 
   case SPELL_SLEEP:
-    if (!pk_allowed && !IS_NPC(ch) && !IS_NPC(victim))
+    if (!CONFIG_PK_ALLOWED && !IS_NPC(ch) && !IS_NPC(victim))
       return;
     if (MOB_FLAGGED(victim, MOB_NOSLEEP))
       return;
@@ -497,7 +496,7 @@ void mag_affects(int level, struct char_
   if (IS_NPC(victim) && !affected_by_spell(victim, spellnum))
     for (i = 0; i < MAX_SPELL_AFFECTS; i++)
       if (AFF_FLAGGED(victim, af[i].bitvector)) {
-	send_to_char(ch, "%s", NOEFFECT);
+	send_to_char(ch, "%s", CONFIG_NOEFFECT);
 	return;
       }
 
@@ -506,7 +505,7 @@ void mag_affects(int level, struct char_
    * not have an accumulative effect, then fail the spell.
    */
   if (affected_by_spell(victim,spellnum) && !(accum_duration||accum_affect)) {
-    send_to_char(ch, "%s", NOEFFECT);
+    send_to_char(ch, "%s", CONFIG_NOEFFECT);
     return;
   }
 
@@ -652,7 +651,7 @@ void mag_areas(int level, struct char_da
       continue;
     if (!IS_NPC(tch) && GET_LEVEL(tch) >= LVL_IMMORT)
       continue;
-    if (!pk_allowed && !IS_NPC(ch) && !IS_NPC(tch))
+    if (!CONFIG_PK_ALLOWED && !IS_NPC(ch) && !IS_NPC(tch))
       continue;
     if (!IS_NPC(ch) && IS_NPC(tch) && AFF_FLAGGED(tch, AFF_CHARM))
       continue;
@@ -858,7 +857,7 @@ void mag_unaffects(int level, struct cha
 
   if (!affected_by_spell(victim, spell)) {
     if (msg_not_affected)
-      send_to_char(ch, "%s", NOEFFECT);
+      send_to_char(ch, "%s", CONFIG_NOEFFECT);
     return;
   }
 
@@ -928,7 +927,7 @@ void mag_alter_objs(int level, struct ch
   }
 
   if (to_char == NULL)
-    send_to_char(ch, "%s", NOEFFECT);
+    send_to_char(ch, "%s", CONFIG_NOEFFECT);
   else
     act(to_char, TRUE, ch, obj, 0, TO_CHAR);
 
diff -BENbdpru circle-3.1/src/mail.c circle3.1_oasis206/src/mail.c
--- circle-3.1/src/mail.c	2002-04-09 16:12:16.000000000 +0200
+++ circle3.1_oasis206/src/mail.c	2003-10-07 10:22:02.000000000 +0200
@@ -52,6 +52,26 @@ int mail_recip_ok(const char *name);
 
 /* -------------------------------------------------------------------------- */
 
+void free_mail_index(void)
+{
+  mail_index_type *tmp;
+
+  while (mail_index) {
+    tmp = mail_index->next;
+    if (mail_index->list_start) {
+      position_list_type *i, *j;
+      i = mail_index->list_start;
+      while (i) {
+        j = i->next;
+        free(i);
+        i = j;
+      }
+    }
+    free(mail_index);
+    mail_index = tmp;
+  }
+}
+
 int mail_recip_ok(const char *name)
 {
   struct char_file_u tmp_store;
diff -BENbdpru circle-3.1/src/medit.c circle3.1_oasis206/src/medit.c
--- circle-3.1/src/medit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/medit.c	2003-10-07 10:37:02.000000000 +0200
@@ -0,0 +1,1073 @@
+/************************************************************************
+ * OasisOLC - Mobiles / medit.c					v2.0	*
+ * Copyright 1996 Harvey Gilpin						*
+ * Copyright 1997-2001 George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "interpreter.h"
+#include "comm.h"
+#include "spells.h"
+#include "utils.h"
+#include "db.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genmob.h"
+#include "genzon.h"
+#include "genshp.h"
+#include "oasis.h"
+#include "handler.h"
+#include "constants.h"
+#include "improved-edit.h"
+#include "screen.h"
+#include "constants.h"
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * External variable declarations.
+ */
+extern struct index_data *mob_index;
+extern struct char_data *mob_proto;
+extern struct char_data *character_list;
+extern mob_rnum top_of_mobt;
+extern struct zone_data *zone_table;
+extern struct attack_hit_type attack_hit_text[];
+extern struct shop_data *shop_index;
+extern struct descriptor_data *descriptor_list;
+#if CONFIG_OASIS_MPROG
+extern const char *mobprog_types[];
+#endif
+
+/*
+ * External function prototypes/
+ */
+extern void smash_tilde(char *str);
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Handy internal macros.
+ */
+#if CONFIG_OASIS_MPROG
+#define GET_MPROG(mob)		(mob_index[(mob)->nr].mobprogs)
+#define GET_MPROG_TYPE(mob)	(mob_index[(mob)->nr].progtypes)
+#endif
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Function prototypes.
+ */
+#if CONFIG_OASIS_MPROG
+void medit_disp_mprog(struct descriptor_data *d);
+void medit_change_mprog(struct descriptor_data *d);
+const char *medit_get_mprog_type(struct mob_prog_data *mprog);
+#endif
+
+/*-------------------------------------------------------------------*\
+  utility functions 
+\*-------------------------------------------------------------------*/
+
+ACMD(do_oasis_medit)
+{
+  int number = NOBODY, save = 0, real_num;
+  struct descriptor_data *d;
+  char *buf3;
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  
+  /****************************************************************************/
+  /** Parse any arguments.                                                   **/
+  /****************************************************************************/
+  buf3 = two_arguments(argument, buf1, buf2);
+  
+  if (!*buf1) {
+    send_to_char(ch, "Specify a mobile VNUM to edit.\r\n");
+    return;
+  } else if (!isdigit(*buf1)) {
+    if (str_cmp("save", buf1) != 0) {
+      send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+      return;
+    }
+    
+    save = TRUE;
+    
+    if (is_number(buf2))
+      number = atoi(buf2);
+    else if (GET_OLC_ZONE(ch) > 0) {
+      zone_rnum zlok;
+      
+      if ((zlok = real_zone(GET_OLC_ZONE(ch))) == NOWHERE)
+        number = NOWHERE;
+      else
+        number = genolc_zone_bottom(zlok);
+    }
+    
+    if (number == NOWHERE) {
+      send_to_char(ch, "Save which zone?\r\n");
+      return;
+    }
+  }
+  
+  /****************************************************************************/
+  /** If a numeric argument was given (like a room number), get it.          **/
+  /****************************************************************************/
+  if (number == NOBODY)
+    number = atoi(buf1);
+  
+  /****************************************************************************/
+  /** Check that whatever it is isn't already being edited.                  **/
+  /****************************************************************************/
+  for (d = descriptor_list; d; d = d->next) {
+    if (STATE(d) == CON_MEDIT) {
+      if (d->olc && OLC_NUM(d) == number) {
+        send_to_char(ch, "That mobile is currently being edited by %s.\r\n",
+          GET_NAME(d->character));
+        return;
+      }
+    }
+  }
+  
+  d = ch->desc;
+  
+  /****************************************************************************/
+  /** Give descriptor an OLC structure.                                      **/
+  /****************************************************************************/
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE,
+      "SYSERR: do_oasis_medit: Player already had olc structure.");
+    free(d->olc);
+  }
+  
+  CREATE(d->olc, struct oasis_olc_data, 1);
+  
+  /****************************************************************************/
+  /** Find the zone.                                                         **/
+  /****************************************************************************/
+  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == NOWHERE) {
+    send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Everyone but IMPLs can only edit zones they have been assigned.        **/
+  /****************************************************************************/
+  if (!can_edit_zone(ch, OLC_ZNUM(d))) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    mudlog(BRF, LVL_IMPL, TRUE, "OLC: %s tried to edit zone %d allowed zone %d",
+      GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** If save is TRUE, save the mobiles.                                     **/
+  /****************************************************************************/
+  if (save) {
+    send_to_char(ch, "Saving all mobiles in zone %d.\r\n",
+      zone_table[OLC_ZNUM(d)].number);
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE,
+      "OLC: %s saves mobile info for zone %d.",
+      GET_NAME(ch), zone_table[OLC_ZNUM(d)].number);
+    
+    /**************************************************************************/
+    /** Save the mobiles.                                                    **/
+    /**************************************************************************/
+    save_mobiles(OLC_ZNUM(d));
+    
+    /**************************************************************************/
+    /** Free the olc structure stored in the descriptor.                     **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  OLC_NUM(d) = number;
+  
+  /****************************************************************************/
+  /** If this is a new mobile, setup a new one, otherwise, setup the         **/
+  /** existing mobile.                                                       **/
+  /****************************************************************************/
+  if ((real_num = real_mobile(number)) == NOBODY)
+    medit_setup_new(d);
+  else
+    medit_setup_existing(d, real_num);
+  
+  STATE(d) = CON_MEDIT;
+  
+  /****************************************************************************/
+  /** Display the OLC messages to the players in the same room as the        **/
+  /** builder and also log it.                                               **/
+  /****************************************************************************/
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  
+  mudlog(BRF, LVL_IMMORT, TRUE,"OLC: %s starts editing zone %d allowed zone %d",
+    GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+}
+
+void medit_save_to_disk(zone_vnum foo)
+{
+  save_mobiles(real_zone(foo));
+}
+
+void medit_setup_new(struct descriptor_data *d)
+{
+  struct char_data *mob;
+
+  /*
+   * Allocate a scratch mobile structure.  
+   */
+  CREATE(mob, struct char_data, 1);
+
+  init_mobile(mob);
+
+  GET_MOB_RNUM(mob) = NOBODY;
+  /*
+   * Set up some default strings.
+   */
+  GET_ALIAS(mob) = strdup("mob unfinished");
+  GET_SDESC(mob) = strdup("the unfinished mob");
+  GET_LDESC(mob) = strdup("An unfinished mob stands here.\r\n");
+  GET_DDESC(mob) = strdup("It looks unfinished.\r\n");
+#if CONFIG_OASIS_MPROG
+  OLC_MPROGL(d) = NULL;
+  OLC_MPROG(d) = NULL;
+#endif
+
+  OLC_MOB(d) = mob;
+  /* Has changed flag. (It hasn't so far, we just made it.) */
+  OLC_VAL(d) = FALSE;
+
+  medit_disp_menu(d);
+}
+
+/*-------------------------------------------------------------------*/
+
+void medit_setup_existing(struct descriptor_data *d, int rmob_num)
+{
+  struct char_data *mob;
+
+  /*
+   * Allocate a scratch mobile structure. 
+   */
+  CREATE(mob, struct char_data, 1);
+
+  copy_mobile(mob, mob_proto + rmob_num);
+
+#if CONFIG_OASIS_MPROG
+  {
+    MPROG_DATA *temp;
+    MPROG_DATA *head;
+
+    if (GET_MPROG(mob))
+      CREATE(OLC_MPROGL(d), MPROG_DATA, 1);
+    head = OLC_MPROGL(d);
+    for (temp = GET_MPROG(mob); temp; temp = temp->next) {
+      OLC_MPROGL(d)->type = temp->type;
+      OLC_MPROGL(d)->arglist = strdup(temp->arglist);
+      OLC_MPROGL(d)->comlist = strdup(temp->comlist);
+      if (temp->next) {
+        CREATE(OLC_MPROGL(d)->next, MPROG_DATA, 1);
+        OLC_MPROGL(d) = OLC_MPROGL(d)->next;
+      }
+    }
+    OLC_MPROGL(d) = head;
+    OLC_MPROG(d) = OLC_MPROGL(d);
+  }
+#endif
+
+  OLC_MOB(d) = mob;
+  medit_disp_menu(d);
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Ideally, this function should be in db.c, but I'll put it here for
+ * portability.
+ */
+void init_mobile(struct char_data *mob)
+{
+  clear_char(mob);
+
+  GET_HIT(mob) = GET_MANA(mob) = 1;
+  GET_MAX_MANA(mob) = GET_MAX_MOVE(mob) = 100;
+  GET_NDD(mob) = GET_SDD(mob) = 1;
+  GET_WEIGHT(mob) = 200;
+  GET_HEIGHT(mob) = 198;
+
+  mob->real_abils.str = mob->real_abils.intel = mob->real_abils.wis = 11;
+  mob->real_abils.dex = mob->real_abils.con = mob->real_abils.cha = 11;
+  mob->aff_abils = mob->real_abils;
+
+  SET_BIT(MOB_FLAGS(mob), MOB_ISNPC);
+  mob->player_specials = &dummy_mob;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Save new/edited mob to memory.
+ */
+void medit_save_internally(struct descriptor_data *d)
+{
+  int i;
+  mob_rnum new_rnum;
+  struct descriptor_data *dsc;
+
+  i = (real_mobile(OLC_NUM(d)) == NOBODY);
+
+  if ((new_rnum = add_mobile(OLC_MOB(d), OLC_NUM(d))) == NOBODY) {
+    log("medit_save_internally: add_mobile failed.");
+    return;
+  }
+
+  if (!i)	/* Only renumber on new mobiles. */
+    return;
+
+  /*
+   * Update keepers in shops being edited and other mobs being edited.
+   */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next) {
+    if (STATE(dsc) == CON_SEDIT)
+      S_KEEPER(OLC_SHOP(dsc)) += (S_KEEPER(OLC_SHOP(dsc)) >= new_rnum);
+    else if (STATE(dsc) == CON_MEDIT)
+      GET_MOB_RNUM(OLC_MOB(dsc)) += (GET_MOB_RNUM(OLC_MOB(dsc)) >= new_rnum);
+  }
+
+  /*
+   * Update other people in zedit too. From: C.Raehl 4/27/99
+   */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next)
+    if (STATE(dsc) == CON_ZEDIT)
+      for (i = 0; OLC_ZONE(dsc)->cmd[i].command != 'S'; i++)
+        if (OLC_ZONE(dsc)->cmd[i].command == 'M')
+          if (OLC_ZONE(dsc)->cmd[i].arg1 >= new_rnum)
+            OLC_ZONE(dsc)->cmd[i].arg1++;
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+/*
+ * Display positions. (sitting, standing, etc)
+ */
+void medit_disp_positions(struct descriptor_data *d)
+{
+  int i;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (i = 0; *position_types[i] != '\n'; i++) {
+    write_to_output(d, "%s%2d%s) %s\r\n", grn, i, nrm, position_types[i]);
+  }
+  write_to_output(d, "Enter position number : ");
+}
+
+/*-------------------------------------------------------------------*/
+
+#if CONFIG_OASIS_MPROG
+/*
+ * Get the type of MobProg.
+ */
+const char *medit_get_mprog_type(struct mob_prog_data *mprog)
+{
+  switch (mprog->type) {
+  case IN_FILE_PROG:	return ">in_file_prog";
+  case ACT_PROG:	return ">act_prog";
+  case SPEECH_PROG:	return ">speech_prog";
+  case RAND_PROG:	return ">rand_prog";
+  case FIGHT_PROG:	return ">fight_prog";
+  case HITPRCNT_PROG:	return ">hitprcnt_prog";
+  case DEATH_PROG:	return ">death_prog";
+  case ENTRY_PROG:	return ">entry_prog";
+  case GREET_PROG:	return ">greet_prog";
+  case ALL_GREET_PROG:	return ">all_greet_prog";
+  case GIVE_PROG:	return ">give_prog";
+  case BRIBE_PROG:	return ">bribe_prog";
+  }
+  return ">ERROR_PROG";
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display the MobProgs.
+ */
+void medit_disp_mprog(struct descriptor_data *d)
+{
+  struct mob_prog_data *mprog = OLC_MPROGL(d);
+
+  OLC_MTOTAL(d) = 1;
+
+  clear_screen(d);
+  while (mprog) {
+    write_to_output(d, "%d) %s %s\r\n", OLC_MTOTAL(d), medit_get_mprog_type(mprog),
+		(mprog->arglist ? mprog->arglist : "NONE"));
+    OLC_MTOTAL(d)++;
+    mprog = mprog->next;
+  }
+  write_to_output(d, "%d) Create New Mob Prog\r\n"
+		"%d) Purge Mob Prog\r\n"
+		"Enter number to edit [0 to exit]:  ",
+		OLC_MTOTAL(d), OLC_MTOTAL(d) + 1);
+  OLC_MODE(d) = MEDIT_MPROG;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Change the MobProgs.
+ */
+void medit_change_mprog(struct descriptor_data *d)
+{
+  clear_screen(d);
+  write_to_output(d, "1) Type: %s\r\n"
+		"2) Args: %s\r\n"
+		"3) Commands:\r\n%s\r\n\r\n"
+		"Enter number to edit [0 to exit]: ",
+	medit_get_mprog_type(OLC_MPROG(d)),
+	(OLC_MPROG(d)->arglist ? OLC_MPROG(d)->arglist: "NONE"),
+	(OLC_MPROG(d)->comlist ? OLC_MPROG(d)->comlist : "NONE"));
+
+  OLC_MODE(d) = MEDIT_CHANGE_MPROG;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Change the MobProg type.
+ */
+void medit_disp_mprog_types(struct descriptor_data *d)
+{
+  int i;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (i = 0; i < NUM_PROGS-1; i++) {
+    write_to_output(d, "%s%2d%s) %s\r\n", grn, i, nrm, mobprog_types[i]);
+  }
+  write_to_output(d, "Enter mob prog type : ");
+  OLC_MODE(d) = MEDIT_MPROG_TYPE;
+}
+#endif
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display the gender of the mobile.
+ */
+void medit_disp_sex(struct descriptor_data *d)
+{
+  int i;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (i = 0; i < NUM_GENDERS; i++) {
+    write_to_output(d, "%s%2d%s) %s\r\n", grn, i, nrm, genders[i]);
+  }
+  write_to_output(d, "Enter gender number : ");
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display attack types menu.
+ */
+void medit_disp_attack_types(struct descriptor_data *d)
+{
+  int i;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (i = 0; i < NUM_ATTACK_TYPES; i++) {
+    write_to_output(d, "%s%2d%s) %s\r\n", grn, i, nrm, attack_hit_text[i].singular);
+  }
+  write_to_output(d, "Enter attack type : ");
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display mob-flags menu.
+ */
+void medit_disp_mob_flags(struct descriptor_data *d)
+{
+  int i, columns = 0;
+  char flags[MAX_STRING_LENGTH];
+  
+  get_char_colors(d->character);
+  clear_screen(d);
+  for (i = 0; i < NUM_MOB_FLAGS; i++) {
+    write_to_output(d, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, action_bits[i],
+		!(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(MOB_FLAGS(OLC_MOB(d)), action_bits, flags, sizeof(flags));
+  write_to_output(d, "\r\nCurrent flags : %s%s%s\r\nEnter mob flags (0 to quit) : ",
+		  cyn, flags, nrm);
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display affection flags menu.
+ */
+void medit_disp_aff_flags(struct descriptor_data *d)
+{
+  int i, columns = 0;
+  char flags[MAX_STRING_LENGTH];
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  for (i = 0; i < NUM_AFF_FLAGS; i++) {
+    write_to_output(d, "%s%2d%s) %-20.20s  %s", grn, i + 1, nrm, affected_bits[i],
+			!(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(AFF_FLAGS(OLC_MOB(d)), affected_bits, flags, sizeof(flags));
+  write_to_output(d, "\r\nCurrent flags   : %s%s%s\r\nEnter aff flags (0 to quit) : ",
+			  cyn, flags, nrm);
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display main menu.
+ */
+void medit_disp_menu(struct descriptor_data *d)
+{
+  struct char_data *mob;
+  char flags[MAX_STRING_LENGTH], flag2[MAX_STRING_LENGTH];
+
+  mob = OLC_MOB(d);
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  write_to_output(d,
+  "-- Mob Number:  [%s%d%s]\r\n"
+  "%s1%s) Sex: %s%-7.7s%s	         %s2%s) Alias: %s%s\r\n"
+  "%s3%s) S-Desc: %s%s\r\n"
+  "%s4%s) L-Desc:-\r\n%s%s"
+  "%s5%s) D-Desc:-\r\n%s%s"
+  "%s6%s) Level:       [%s%4d%s],  %s7%s) Alignment:    [%s%4d%s]\r\n"
+  "%s8%s) Hitroll:     [%s%4d%s],  %s9%s) Damroll:      [%s%4d%s]\r\n"
+  "%sA%s) NumDamDice:  [%s%4d%s],  %sB%s) SizeDamDice:  [%s%4d%s]\r\n"
+  "%sC%s) Num HP Dice: [%s%4d%s],  %sD%s) Size HP Dice: [%s%4d%s],  %sE%s) HP Bonus: [%s%5d%s]\r\n"
+  "%sF%s) Armor Class: [%s%4d%s],  %sG%s) Exp:     [%s%9d%s],  %sH%s) Gold:  [%s%8d%s]\r\n",
+
+	  cyn, OLC_NUM(d), nrm,
+	  grn, nrm, yel, genders[(int)GET_SEX(mob)], nrm,
+	  grn, nrm, yel, GET_ALIAS(mob),
+	  grn, nrm, yel, GET_SDESC(mob),
+	  grn, nrm, yel, GET_LDESC(mob),
+	  grn, nrm, yel, GET_DDESC(mob),
+	  grn, nrm, cyn, GET_LEVEL(mob), nrm,
+	  grn, nrm, cyn, GET_ALIGNMENT(mob), nrm,
+	  grn, nrm, cyn, GET_HITROLL(mob), nrm,
+	  grn, nrm, cyn, GET_DAMROLL(mob), nrm,
+	  grn, nrm, cyn, GET_NDD(mob), nrm,
+	  grn, nrm, cyn, GET_SDD(mob), nrm,
+	  grn, nrm, cyn, GET_HIT(mob), nrm,
+	  grn, nrm, cyn, GET_MANA(mob), nrm,
+	  grn, nrm, cyn, GET_MOVE(mob), nrm,
+	  grn, nrm, cyn, GET_AC(mob), nrm,
+	  grn, nrm, cyn, GET_EXP(mob), nrm,
+	  grn, nrm, cyn, GET_GOLD(mob), nrm
+	  );
+
+  sprintbit(MOB_FLAGS(mob), action_bits, flags, sizeof(flags));
+  sprintbit(AFF_FLAGS(mob), affected_bits, flag2, sizeof(flag2));
+  write_to_output(d,
+	  "%sI%s) Position  : %s%s\r\n"
+	  "%sJ%s) Default   : %s%s\r\n"
+	  "%sK%s) Attack    : %s%s\r\n"
+	  "%sL%s) NPC Flags : %s%s\r\n"
+	  "%sM%s) AFF Flags : %s%s\r\n"
+#if CONFIG_OASIS_MPROG
+	  "%sP%s) Mob Progs : %s%s\r\n"
+#endif
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ",
+
+	  grn, nrm, yel, position_types[(int)GET_POS(mob)],
+	  grn, nrm, yel, position_types[(int)GET_DEFAULT_POS(mob)],
+	  grn, nrm, yel, attack_hit_text[(int)GET_ATTACK(mob)].singular,
+	  grn, nrm, cyn, flags,
+	  grn, nrm, cyn, flag2,
+#if CONFIG_OASIS_MPROG
+	  grn, nrm, cyn, (OLC_MPROGL(d) ? "Set." : "Not Set."),
+#endif
+	  grn, nrm
+	  );
+
+  OLC_MODE(d) = MEDIT_MAIN_MENU;
+}
+
+/************************************************************************
+ *			The GARGANTAUN event handler			*
+ ************************************************************************/
+
+void medit_parse(struct descriptor_data *d, char *arg)
+{
+  int i = -1;
+  char *oldtext = NULL;
+
+  if (OLC_MODE(d) > MEDIT_NUMERICAL_RESPONSE) {
+    i = atoi(arg);
+    if (!*arg || (!isdigit(arg[0]) && ((*arg == '-') && !isdigit(arg[1])))) {
+      write_to_output(d, "Field must be numerical, try again : ");
+      return;
+    }
+  } else {	/* String response. */
+    if (!genolc_checkstring(d, arg))
+      return;
+  }
+  switch (OLC_MODE(d)) {
+/*-------------------------------------------------------------------*/
+  case MEDIT_CONFIRM_SAVESTRING:
+    /*
+     * Ensure mob has MOB_ISNPC set or things will go pear shaped.
+     */
+    SET_BIT(MOB_FLAGS(OLC_MOB(d)), MOB_ISNPC);
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      /*
+       * Save the mob in memory and to disk.
+       */
+      medit_save_internally(d);
+      mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE,
+	"OLC: %s edits mob %d", GET_NAME(d->character), OLC_NUM(d));
+      if (CONFIG_OLC_SAVE) {
+	medit_save_to_disk(zone_table[real_zone_by_thing(OLC_NUM(d))].number);
+	write_to_output(d, "Mobile saved to disk.\r\n");
+      } else
+        write_to_output(d, "Mobile saved to memory.\r\n");
+      /* FALL THROUGH */
+    case 'n':
+    case 'N':
+      cleanup_olc(d, CLEANUP_ALL);
+      return;
+    default:
+      write_to_output(d, "Invalid choice!\r\n");
+      write_to_output(d, "Do you wish to save the mobile? : ");
+      return;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case MEDIT_MAIN_MENU:
+    i = 0;
+    switch (*arg) {
+    case 'q':
+    case 'Q':
+      if (OLC_VAL(d)) {	/* Anything been changed? */
+	write_to_output(d, "Do you wish to save the changes to the mobile? (y/n) : ");
+	OLC_MODE(d) = MEDIT_CONFIRM_SAVESTRING;
+      } else
+	cleanup_olc(d, CLEANUP_ALL);
+      return;
+    case '1':
+      OLC_MODE(d) = MEDIT_SEX;
+      medit_disp_sex(d);
+      return;
+    case '2':
+      OLC_MODE(d) = MEDIT_ALIAS;
+      i--;
+      break;
+    case '3':
+      OLC_MODE(d) = MEDIT_S_DESC;
+      i--;
+      break;
+    case '4':
+      OLC_MODE(d) = MEDIT_L_DESC;
+      i--;
+      break;
+    case '5':
+      OLC_MODE(d) = MEDIT_D_DESC;
+      send_editor_help(d);
+      write_to_output(d, "Enter mob description:\r\n\r\n");
+      if (OLC_MOB(d)->player.description) {
+	write_to_output(d, "%s", OLC_MOB(d)->player.description);
+	oldtext = strdup(OLC_MOB(d)->player.description);
+      }
+      string_write(d, &OLC_MOB(d)->player.description, MAX_MOB_DESC, 0, oldtext);
+      OLC_VAL(d) = 1;
+      return;
+    case '6':
+      OLC_MODE(d) = MEDIT_LEVEL;
+      i++;
+      break;
+    case '7':
+      OLC_MODE(d) = MEDIT_ALIGNMENT;
+      i++;
+      break;
+    case '8':
+      OLC_MODE(d) = MEDIT_HITROLL;
+      i++;
+      break;
+    case '9':
+      OLC_MODE(d) = MEDIT_DAMROLL;
+      i++;
+      break;
+    case 'a':
+    case 'A':
+      OLC_MODE(d) = MEDIT_NDD;
+      i++;
+      break;
+    case 'b':
+    case 'B':
+      OLC_MODE(d) = MEDIT_SDD;
+      i++;
+      break;
+    case 'c':
+    case 'C':
+      OLC_MODE(d) = MEDIT_NUM_HP_DICE;
+      i++;
+      break;
+    case 'd':
+    case 'D':
+      OLC_MODE(d) = MEDIT_SIZE_HP_DICE;
+      i++;
+      break;
+    case 'e':
+    case 'E':
+      OLC_MODE(d) = MEDIT_ADD_HP;
+      i++;
+      break;
+    case 'f':
+    case 'F':
+      OLC_MODE(d) = MEDIT_AC;
+      i++;
+      break;
+    case 'g':
+    case 'G':
+      OLC_MODE(d) = MEDIT_EXP;
+      i++;
+      break;
+    case 'h':
+    case 'H':
+      OLC_MODE(d) = MEDIT_GOLD;
+      i++;
+      break;
+    case 'i':
+    case 'I':
+      OLC_MODE(d) = MEDIT_POS;
+      medit_disp_positions(d);
+      return;
+    case 'j':
+    case 'J':
+      OLC_MODE(d) = MEDIT_DEFAULT_POS;
+      medit_disp_positions(d);
+      return;
+    case 'k':
+    case 'K':
+      OLC_MODE(d) = MEDIT_ATTACK;
+      medit_disp_attack_types(d);
+      return;
+    case 'l':
+    case 'L':
+      OLC_MODE(d) = MEDIT_NPC_FLAGS;
+      medit_disp_mob_flags(d);
+      return;
+    case 'm':
+    case 'M':
+      OLC_MODE(d) = MEDIT_AFF_FLAGS;
+      medit_disp_aff_flags(d);
+      return;
+#if CONFIG_OASIS_MPROG
+    case 'p':
+    case 'P':
+      OLC_MODE(d) = MEDIT_MPROG;
+      medit_disp_mprog(d);
+      return;
+#endif
+    default:
+      medit_disp_menu(d);
+      return;
+    }
+    if (i == 0)
+      break;
+    else if (i == 1)
+      write_to_output(d, "\r\nEnter new value : ");
+    else if (i == -1)
+      write_to_output(d, "\r\nEnter new text :\r\n] ");
+    else
+      write_to_output(d, "Oops...\r\n");
+    return;
+/*-------------------------------------------------------------------*/
+  case MEDIT_ALIAS:
+    smash_tilde(arg);
+    if (GET_ALIAS(OLC_MOB(d)))
+      free(GET_ALIAS(OLC_MOB(d)));
+    GET_ALIAS(OLC_MOB(d)) = str_udup(arg);
+    break;
+/*-------------------------------------------------------------------*/
+  case MEDIT_S_DESC:
+    smash_tilde(arg);
+    if (GET_SDESC(OLC_MOB(d)))
+      free(GET_SDESC(OLC_MOB(d)));
+    GET_SDESC(OLC_MOB(d)) = str_udup(arg);
+    break;
+/*-------------------------------------------------------------------*/
+  case MEDIT_L_DESC:
+    smash_tilde(arg);
+    if (GET_LDESC(OLC_MOB(d)))
+      free(GET_LDESC(OLC_MOB(d)));
+    if (arg && *arg) {
+      char buf[MAX_INPUT_LENGTH];
+      snprintf(buf, sizeof(buf), "%s\r\n", arg);
+      GET_LDESC(OLC_MOB(d)) = strdup(buf);
+    } else
+      GET_LDESC(OLC_MOB(d)) = strdup("undefined");
+
+    break;
+/*-------------------------------------------------------------------*/
+  case MEDIT_D_DESC:
+    /*
+     * We should never get here.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: medit_parse(): Reached D_DESC case!");
+    write_to_output(d, "Oops...\r\n");
+    break;
+/*-------------------------------------------------------------------*/
+#if CONFIG_OASIS_MPROG
+  case MEDIT_MPROG_COMLIST:
+    /*
+     * We should never get here, but if we do, bail out.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: medit_parse(): Reached MPROG_COMLIST case!");
+    break;
+#endif
+/*-------------------------------------------------------------------*/
+  case MEDIT_NPC_FLAGS:
+    if ((i = atoi(arg)) <= 0)
+      break;
+    else if (i <= NUM_MOB_FLAGS)
+      TOGGLE_BIT(MOB_FLAGS(OLC_MOB(d)), 1 << (i - 1));
+    medit_disp_mob_flags(d);
+    return;
+/*-------------------------------------------------------------------*/
+  case MEDIT_AFF_FLAGS:
+    if ((i = atoi(arg)) <= 0)
+      break;
+    else if (i <= NUM_AFF_FLAGS)
+      TOGGLE_BIT(AFF_FLAGS(OLC_MOB(d)), 1 << (i - 1));
+    /* Remove unwanted bits right away. */
+    REMOVE_BIT(AFF_FLAGS(OLC_MOB(d)),
+      AFF_CHARM | AFF_POISON | AFF_GROUP | AFF_SLEEP);
+    medit_disp_aff_flags(d);
+    return;
+/*-------------------------------------------------------------------*/
+#if CONFIG_OASIS_MPROG
+  case MEDIT_MPROG:
+    if ((i = atoi(arg)) == 0)
+      medit_disp_menu(d);
+    else if (i == OLC_MTOTAL(d)) {
+      struct mob_prog_data *temp;
+      CREATE(temp, struct mob_prog_data, 1);
+      temp->next = OLC_MPROGL(d);
+      temp->type = -1;
+      temp->arglist = NULL;
+      temp->comlist = NULL;
+      OLC_MPROG(d) = temp;
+      OLC_MPROGL(d) = temp;
+      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
+      medit_change_mprog (d);
+    } else if (i < OLC_MTOTAL(d)) {
+      struct mob_prog_data *temp;
+      int x = 1;
+      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
+        x++;
+      OLC_MPROG(d) = temp;
+      OLC_MODE(d) = MEDIT_CHANGE_MPROG;
+      medit_change_mprog (d);
+    } else if (i == (OLC_MTOTAL(d) + 1)) {
+      write_to_output(d, "Which mob prog do you want to purge? ");
+      OLC_MODE(d) = MEDIT_PURGE_MPROG;
+    } else
+      medit_disp_menu(d);
+    return;
+
+  case MEDIT_PURGE_MPROG:
+    if ((i = atoi(arg)) > 0 && i < OLC_MTOTAL(d)) {
+      struct mob_prog_data *temp;
+      int x = 1;
+
+      for (temp = OLC_MPROGL(d); temp && x < i; temp = temp->next)
+	x++;
+      OLC_MPROG(d) = temp;
+      REMOVE_FROM_LIST(OLC_MPROG(d), OLC_MPROGL(d), next);
+      free(OLC_MPROG(d)->arglist);
+      free(OLC_MPROG(d)->comlist);
+      free(OLC_MPROG(d));
+      OLC_MPROG(d) = NULL;
+      OLC_VAL(d) = 1;
+    }
+    medit_disp_mprog(d);
+    return;
+
+  case MEDIT_CHANGE_MPROG:
+    if ((i = atoi(arg)) == 1)
+      medit_disp_mprog_types(d);
+    else if (i == 2) {
+      write_to_output(d, "Enter new arg list: ");
+      OLC_MODE(d) = MEDIT_MPROG_ARGS;
+    } else if (i == 3) {
+      write_to_output(d, "Enter new mob prog commands:\r\n");
+      /*
+       * Pass control to modify.c for typing.
+       */
+      OLC_MODE(d) = MEDIT_MPROG_COMLIST;
+      if (OLC_MPROG(d)->comlist) {
+        write_to_output(d, "%s", OLC_MPROG(d)->comlist);
+        oldtext = strdup(OLC_MPROG(d)->comlist);
+      }
+      string_write(d, &OLC_MPROG(d)->comlist, MAX_STRING_LENGTH, 0, oldtext);
+      OLC_VAL(d) = 1;
+    } else
+      medit_disp_mprog(d);
+    return;
+#endif
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Numerical responses.
+ */
+
+#if CONFIG_OASIS_MPROG
+  case MEDIT_MPROG_TYPE:
+    /*
+     * This calculation may be off by one too many powers of 2?
+     * Someone who actually uses MobProgs will have to check.
+     */
+    OLC_MPROG(d)->type = (1 << LIMIT(atoi(arg), 0, NUM_PROGS - 1));
+    OLC_VAL(d) = 1;
+    medit_change_mprog(d);
+    return;
+
+  case MEDIT_MPROG_ARGS:
+    OLC_MPROG(d)->arglist = strdup(arg);
+    OLC_VAL(d) = 1;
+    medit_change_mprog(d);
+    return;
+#endif
+
+  case MEDIT_SEX:
+    GET_SEX(OLC_MOB(d)) = LIMIT(i, 0, NUM_GENDERS - 1);
+    break;
+
+  case MEDIT_HITROLL:
+    GET_HITROLL(OLC_MOB(d)) = LIMIT(i, 0, 50);
+    break;
+
+  case MEDIT_DAMROLL:
+    GET_DAMROLL(OLC_MOB(d)) = LIMIT(i, 0, 50);
+    break;
+
+  case MEDIT_NDD:
+    GET_NDD(OLC_MOB(d)) = LIMIT(i, 0, 30);
+    break;
+
+  case MEDIT_SDD:
+    GET_SDD(OLC_MOB(d)) = LIMIT(i, 0, 127);
+    break;
+
+  case MEDIT_NUM_HP_DICE:
+    GET_HIT(OLC_MOB(d)) = LIMIT(i, 0, 30);
+    break;
+
+  case MEDIT_SIZE_HP_DICE:
+    GET_MANA(OLC_MOB(d)) = LIMIT(i, 0, 1000);
+    break;
+
+  case MEDIT_ADD_HP:
+    GET_MOVE(OLC_MOB(d)) = LIMIT(i, 0, 30000);
+    break;
+
+  case MEDIT_AC:
+    GET_AC(OLC_MOB(d)) = LIMIT(i, -200, 200);
+    break;
+
+  case MEDIT_EXP:
+    GET_EXP(OLC_MOB(d)) = LIMIT(i, 0, MAX_MOB_EXP);
+    break;
+ 
+  case MEDIT_GOLD:
+    GET_GOLD(OLC_MOB(d)) = LIMIT(i, 0, MAX_MOB_GOLD);
+    break;
+
+  case MEDIT_POS:
+    GET_POS(OLC_MOB(d)) = LIMIT(i, 0, NUM_POSITIONS - 1);
+    break;
+
+  case MEDIT_DEFAULT_POS:
+    GET_DEFAULT_POS(OLC_MOB(d)) = LIMIT(i, 0, NUM_POSITIONS - 1);
+    break;
+
+  case MEDIT_ATTACK:
+    GET_ATTACK(OLC_MOB(d)) = LIMIT(i, 0, NUM_ATTACK_TYPES - 1);
+    break;
+
+  case MEDIT_LEVEL:
+    GET_LEVEL(OLC_MOB(d)) = LIMIT(i, 1, 100);
+    break;
+
+  case MEDIT_ALIGNMENT:
+    GET_ALIGNMENT(OLC_MOB(d)) = LIMIT(i, -1000, 1000);
+    break;
+
+/*-------------------------------------------------------------------*/
+  default:
+    /*
+     * We should never get here.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: medit_parse(): Reached default case!");
+    write_to_output(d, "Oops...\r\n");
+    break;
+  }
+/*-------------------------------------------------------------------*/
+
+/*
+ * END OF CASE 
+ * If we get here, we have probably changed something, and now want to
+ * return to main menu.  Use OLC_VAL as a 'has changed' flag  
+ */
+
+  OLC_VAL(d) = TRUE;
+  medit_disp_menu(d);
+}
+
+void medit_string_cleanup(struct descriptor_data *d, int terminator)
+{
+  switch (OLC_MODE(d)) {
+
+#if CONFIG_OASIS_MPROG
+  case MEDIT_MPROG_COMLIST:
+    medit_change_mprog(d);
+    break;
+#endif
+
+  case MEDIT_D_DESC:
+  default:
+     medit_disp_menu(d);
+     break;
+  }
+}
+
diff -BENbdpru circle-3.1/src/modify.c circle3.1_oasis206/src/modify.c
--- circle-3.1/src/modify.c	2002-04-09 16:12:16.000000000 +0200
+++ circle3.1_oasis206/src/modify.c	2003-10-07 10:37:02.000000000 +0200
@@ -21,11 +21,13 @@
 #include "spells.h"
 #include "mail.h"
 #include "boards.h"
+#include "improved-edit.h"
+#include "oasis.h"
+#include "tedit.h"
 
 void show_string(struct descriptor_data *d, char *input);
 
 extern struct spell_info_type spell_info[];
-extern const char *MENU;
 extern const char *unused_spellname;	/* spell_parser.c */
 
 /* local functions */
@@ -34,6 +36,8 @@ ACMD(do_skillset);
 char *next_page(char *str);
 int count_pages(char *str);
 void paginate_string(char *str, struct descriptor_data *d);
+void playing_string_cleanup(struct descriptor_data *d, int action);
+void exdesc_string_cleanup(struct descriptor_data *d, int action);
 
 const char *string_fields[] =
 {
@@ -71,6 +75,16 @@ int length[] =
  */
 void smash_tilde(char *str)
 {
+  /*
+   * Erase any _line ending_ tildes inserted in the editor. 
+   * The load mechanism can't handle those, yet.
+   * -- Welcor 04/2003
+   */
+
+   char *p = str;
+   for (; *p; p++)
+     if (*p == '~' && (*(p+1)=='\r' || *(p+1)=='\n' || *(p+1)=='\0'))
+       *p=' ';
 #if 0
   /*
    * Erase any ~'s inserted by people in the editor.  This prevents anyone
@@ -95,36 +109,48 @@ void string_write(struct descriptor_data
   if (d->character && !IS_NPC(d->character))
     SET_BIT(PLR_FLAGS(d->character), PLR_WRITING);
 
-  if (data)
-    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: string_write: I don't understand special data.");
+  if (using_improved_editor)
+    d->backstr = (char *)data;
+  else if (data)
+    free(data); 
 
   d->str = writeto;
   d->max_str = len;
   d->mail_to = mailto;
 }
 
-/* Add user input to the 'current' string (as defined by d->str) */
+/*
+ * Add user input to the 'current' string (as defined by d->str).
+ * This is still overly complex.
+ */
 void string_add(struct descriptor_data *d, char *str)
 {
-  int terminator;
+  int action;
 
   /* determine if this is the terminal string, and truncate if so */
   /* changed to only accept '@' at the beginning of line - J. Elson 1/17/94 */
 
   delete_doubledollar(str);
+  smash_tilde(str);
 
-  if ((terminator = (*str == '@')))
+  /* determine if this is the terminal string, and truncate if so */
+  /* changed to only accept '@' at the beginning of line - J. Elson 1/17/94 */
+  if ((action = (*str == '@')))
     *str = '\0';
+  else
+    if ((action = improved_editor_execute(d, str)) == STRINGADD_ACTION)
+      return;
 
-  smash_tilde(str);
-
-  if (!(*d->str)) {
+  if (action != STRINGADD_OK)
+    /* Do nothing. */ ;
+  else if (!(*d->str)) {
     if (strlen(str) + 3 > d->max_str) { /* \r\n\0 */
       send_to_char(d->character, "String too long - Truncated.\r\n");
       strcpy(&str[d->max_str - 3], "\r\n");	/* strcpy: OK (size checked) */
       CREATE(*d->str, char, d->max_str);
       strcpy(*d->str, str);	/* strcpy: OK (size checked) */
-      terminator = 1;
+      if (!using_improved_editor)
+        action = STRINGADD_SAVE; 
     } else {
       CREATE(*d->str, char, strlen(str) + 3);
       strcpy(*d->str, str);	/* strcpy: OK (size checked) */
@@ -132,39 +158,113 @@ void string_add(struct descriptor_data *
   } else {
     if (strlen(str) + strlen(*d->str) + 3 > d->max_str) { /* \r\n\0 */
       send_to_char(d->character, "String too long.  Last line skipped.\r\n");
-      terminator = 1;
+      if (!using_improved_editor)
+        action = STRINGADD_SAVE; 
+      else if (action == STRINGADD_OK)
+        action = STRINGADD_ACTION;    /* No appending \r\n\0, but still let them save. */
     } else {
       RECREATE(*d->str, char, strlen(*d->str) + strlen(str) + 3); /* \r\n\0 */
       strcat(*d->str, str);	/* strcat: OK (size precalculated) */
     }
   }
 
-  if (terminator) {
-    if (STATE(d) == CON_PLAYING && (PLR_FLAGGED(d->character, PLR_MAILING))) {
-      store_mail(d->mail_to, GET_IDNUM(d->character), *d->str);
+  /*
+   * Common cleanup code.
+   */
+  switch (action) {
+    case STRINGADD_ABORT:
+      switch (STATE(d)) {
+        case CON_CEDIT:
+        case CON_TEDIT:
+        case CON_REDIT:
+        case CON_MEDIT:
+        case CON_OEDIT:
+        case CON_EXDESC:
+          free(*d->str);
+          *d->str = d->backstr;
+          d->backstr = NULL;
+          d->str = NULL;
+          break;
+        default:
+          log("SYSERR: string_add: Aborting write from unknown origin.");
+          break;
+      }
+      break;
+    case STRINGADD_SAVE:
+      if (d->str && *d->str && **d->str == '\0') {
+        free(*d->str);
+        *d->str = strdup("Nothing.\r\n");
+      }
+      if (d->backstr)
+        free(d->backstr);
+      d->backstr = NULL;
+      break;
+    case STRINGADD_ACTION:
+      break;
+  }
+
+  /* Ok, now final cleanup. */
+
+  if (action == STRINGADD_SAVE || action == STRINGADD_ABORT) {
+    int i;
+    struct {
+      int mode;
+      void (*func)(struct descriptor_data *d, int action);
+    } cleanup_modes[] = {
+      { CON_CEDIT  , cedit_string_cleanup },
+      { CON_MEDIT  , medit_string_cleanup },
+      { CON_OEDIT  , oedit_string_cleanup },
+      { CON_REDIT  , redit_string_cleanup },
+      { CON_TEDIT  , tedit_string_cleanup },
+      { CON_EXDESC , exdesc_string_cleanup },
+      { CON_PLAYING, playing_string_cleanup },
+      { -1, NULL }
+    };
+
+    for (i = 0; cleanup_modes[i].func; i++)
+      if (STATE(d) == cleanup_modes[i].mode)
+        (*cleanup_modes[i].func)(d, action);
+
+    /* Common post cleanup code. */
+    d->str = NULL;
       d->mail_to = 0;
+    d->max_str = 0;
+    if (d->character && !IS_NPC(d->character))
+      REMOVE_BIT(PLR_FLAGS(d->character), PLR_MAILING | PLR_WRITING);
+  } else if (action != STRINGADD_ACTION && strlen(*d->str) + 3 <= d->max_str) /* 3 = \r\n\0 */
+     strcat(*d->str, "\r\n");
+}
+
+void playing_string_cleanup(struct descriptor_data *d, int action)
+{
+  if (PLR_FLAGGED(d->character, PLR_MAILING)) {
+    if (action == STRINGADD_SAVE && *d->str) {
+      store_mail(d->mail_to, GET_IDNUM(d->character), *d->str);
+      write_to_output(d, "Message sent!\r\n");
+    } else
+      write_to_output(d, "Mail aborted.\r\n");
       free(*d->str);
       free(d->str);
-      write_to_output(d, "Message sent!\r\n");
-      if (!IS_NPC(d->character))
-	REMOVE_BIT(PLR_FLAGS(d->character), PLR_MAILING | PLR_WRITING);
     }
-    d->str = NULL;
 
+  /*
+   * We have no way of knowing which slot the post was sent to so we can only give the message...
+   */
     if (d->mail_to >= BOARD_MAGIC) {
       Board_save_board(d->mail_to - BOARD_MAGIC);
-      d->mail_to = 0;
-    }
-    if (STATE(d) == CON_EXDESC) {
-      write_to_output(d, "%s", MENU);
-      STATE(d) = CON_MENU;
+      if (action == STRINGADD_ABORT)
+        write_to_output(d, "Post not aborted, use REMOVE <post #>.\r\n");
     }
-    if (STATE(d) == CON_PLAYING && d->character && !IS_NPC(d->character))
-      REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING);
-  } else
-    strcat(*d->str, "\r\n");	/* strcat: OK (size checked) */
 }
 
+void exdesc_string_cleanup(struct descriptor_data *d, int action)
+{
+  if (action == STRINGADD_ABORT)
+    write_to_output(d, "Description aborted.\r\n");
+  
+  write_to_output(d, "%s", CONFIG_MENU);
+  STATE(d) = CON_MENU;
+}
 
 
 /* **********************************************************************
@@ -196,7 +296,7 @@ ACMD(do_skillset)
   }
 
   if (!(vict = get_char_vis(ch, name, NULL, FIND_CHAR_WORLD))) {
-    send_to_char(ch, "%s", NOPERSON);
+    send_to_char(ch, "%s", CONFIG_NOPERSON);
     return;
   }
   skip_spaces(&argument);
diff -BENbdpru circle-3.1/src/oasis.c circle3.1_oasis206/src/oasis.c
--- circle-3.1/src/oasis.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis.c	2003-10-07 10:37:02.000000000 +0200
@@ -0,0 +1,394 @@
+/************************************************************************
+ * OasisOLC - General / oasis.c					v2.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "interpreter.h"
+#include "comm.h"
+#include "db.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genmob.h"
+#include "genshp.h"
+#include "genzon.h"
+#include "genwld.h"
+#include "genobj.h"
+#include "oasis.h"
+#include "screen.h"
+
+const char *nrm, *grn, *cyn, *yel;
+
+/******************************************************************************/
+/** External Data Structures                                                 **/
+/******************************************************************************/
+extern struct obj_data *obj_proto;
+extern struct char_data *mob_proto;
+extern struct room_data *world;
+extern zone_rnum top_of_zone_table;
+extern struct zone_data *zone_table;
+extern struct descriptor_data *descriptor_list;
+
+/******************************************************************************/
+/** External Functions                                                       **/
+/******************************************************************************/
+int is_name(const char *str, const char *namelist);
+
+/******************************************************************************/
+/** Internal Data Structures                                                 **/
+/******************************************************************************/
+struct olc_scmd_info_t {
+  const char *text;
+  int con_type;
+} olc_scmd_info[] = {
+  { "room",	CON_REDIT },
+  { "object",	CON_OEDIT },
+  { "zone",	CON_ZEDIT },
+  { "mobile",	CON_MEDIT },
+  { "shop",	CON_SEDIT },
+  { "config",   CON_CEDIT },
+  { "action",   CON_AEDIT },
+  { "\n",	-1	  }
+};
+
+/******************************************************************************/
+/** Internal Functions                                                       **/
+/******************************************************************************/
+void free_config(struct config_data *data);
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Only player characters should be using OLC anyway.
+ */
+void clear_screen(struct descriptor_data *d)
+{
+  if (PRF_FLAGGED(d->character, PRF_CLS))
+    write_to_output(d, "[H[J");
+}
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Exported ACMD do_oasis function.
+ *
+ * This function is the OLC interface.  It deals with all the 
+ * generic OLC stuff, then passes control to the sub-olc sections.
+ *
+ * UPDATE:
+ *  I believe that yes, putting the code together that is common in all of the
+ *  olc functions is good to a certain extent, but the do_oasis command was
+ *  getting ridiculous.  Therefore, I have separated them into separate
+ *  functions that get called from in do_oasis....yes, similar code, but it is
+ *  easier to handle....   - Kip Potter
+ */
+ACMD(do_oasis)
+{
+  /*
+   * No screwing around as a mobile.
+   */
+  if (IS_NPC(ch) || !ch->desc)
+     return;
+   
+  /*
+   * Prevent forcing people in OLC to edit other stuff.
+   * 'force' just lets command_interpreter() handle the input,
+   * regardless of the state of the victim. 
+   * This can wreck havoc if people are i OLC already 
+   * - ie. their input should have been redirected by nanny(), and
+   * never get to command_interpreter().
+   * -- Welcor 09/03 
+   * - thanks to Mark Garringer (zizazat@hotmail.com) for the bug report.
+   */
+  if (STATE(ch->desc) != CON_PLAYING) 
+    return;
+  
+
+  switch (subcmd) {
+  /*
+   * The command to see what needs to be saved, typically 'olc'.
+   */
+    case SCMD_OLC_SAVEINFO:
+      do_show_save_list(ch);
+      break;
+      
+    case SCMD_OASIS_CEDIT:
+      do_oasis_cedit(ch, argument, cmd, subcmd);
+      break;
+      
+    case SCMD_OASIS_ZEDIT:
+      do_oasis_zedit(ch, argument, cmd, subcmd);
+      break;
+    
+    case SCMD_OASIS_REDIT:
+      do_oasis_redit(ch, argument, cmd, subcmd);
+      break;
+    
+    case SCMD_OASIS_OEDIT:
+      do_oasis_oedit(ch, argument, cmd, subcmd);
+      break;
+      
+    case SCMD_OASIS_MEDIT:
+      do_oasis_medit(ch, argument, cmd, subcmd);
+      break;
+      
+    case SCMD_OASIS_SEDIT:
+      do_oasis_sedit(ch, argument, cmd, subcmd);
+      break;
+      
+    case SCMD_OASIS_AEDIT:
+      do_oasis_aedit(ch, argument, cmd, subcmd);
+      break;
+
+    case SCMD_OASIS_RLIST:
+    case SCMD_OASIS_MLIST:
+    case SCMD_OASIS_OLIST:
+    case SCMD_OASIS_SLIST:
+    case SCMD_OASIS_ZLIST:
+      do_oasis_list(ch, argument, cmd, subcmd);
+      break;
+
+    case SCMD_OASIS_LINKS:
+      do_oasis_links(ch, argument, cmd, subcmd);
+      break;
+      
+    default:
+      log("SYSERR: (OLC) Invalid subcmd passed to do_oasis, subcmd - (%d)",
+	subcmd);
+      return;
+  }
+  
+  return;
+}
+
+/*------------------------------------------------------------*\
+ Exported utilities 
+\*------------------------------------------------------------*/
+
+/*
+ * Set the colour string pointers for that which this char will
+ * see at color level NRM.  Changing the entries here will change 
+ * the colour scheme throughout the OLC.
+ */
+void get_char_colors(struct char_data *ch)
+{
+  nrm = CCNRM(ch, C_NRM);
+  grn = CCGRN(ch, C_NRM);
+  cyn = CCCYN(ch, C_NRM);
+  yel = CCYEL(ch, C_NRM);
+}
+
+/*
+ * This procedure frees up the strings and/or the structures
+ * attatched to a descriptor, sets all flags back to how they
+ * should be.
+ */
+void cleanup_olc(struct descriptor_data *d, byte cleanup_type)
+{
+  /*
+   * Clean up WHAT?
+   */
+  if (d->olc == NULL)
+    return;
+
+  /*
+   * Check for a room. free_room doesn't perform
+   * sanity checks, we must be careful here.
+   */
+  if (OLC_ROOM(d)) {
+    switch (cleanup_type) {
+    case CLEANUP_ALL:
+      free_room(OLC_ROOM(d));
+      break;
+    case CLEANUP_STRUCTS:
+      free(OLC_ROOM(d));
+      break;
+    case CLEANUP_CONFIG:
+      free_config(OLC_CONFIG(d));
+      break;
+    default: /* The caller has screwed up. */
+      log("SYSERR: cleanup_olc: Unknown type!");
+      break;
+    }
+  }
+
+  /*
+   * Check for an existing object in the OLC.  The strings
+   * aren't part of the prototype any longer.  They get added
+   * with strdup().
+   */
+  if (OLC_OBJ(d)) {
+    free_object_strings(OLC_OBJ(d));
+    free(OLC_OBJ(d));
+  }
+
+  /*
+   * Check for a mob.  free_mobile() makes sure strings are not in
+   * the prototype.
+   */
+  if (OLC_MOB(d))
+    free_mobile(OLC_MOB(d));
+
+  /*
+   * Check for a zone.  cleanup_type is irrelevant here, free() everything.
+   */
+  if (OLC_ZONE(d)) {
+    free(OLC_ZONE(d)->name);
+    free(OLC_ZONE(d)->cmd);
+    free(OLC_ZONE(d));
+  }
+
+  /*. Check for aedit stuff -- M. Scott */
+  if (OLC_ACTION(d))  {
+    switch(cleanup_type)  {
+      case CLEANUP_ALL:
+ 	free_action(OLC_ACTION(d));
+ 	break;
+      case CLEANUP_STRUCTS:
+        free(OLC_ACTION(d));
+        break;
+      default:
+        /* Caller has screwed up */
+ 	break;
+    }
+  }
+
+  /* free storage if allocated (for tedit and aedit) */
+  if (OLC_STORAGE(d)) { 
+    free(OLC_STORAGE(d));
+    OLC_STORAGE(d) = NULL;
+  }
+  /*
+   * Check for a shop.  free_shop doesn't perform sanity checks, we must
+   * be careful here.
+   */
+  if (OLC_SHOP(d)) {
+    switch (cleanup_type) {
+    case CLEANUP_ALL:
+      free_shop(OLC_SHOP(d));
+      break;
+    case CLEANUP_STRUCTS:
+      free(OLC_SHOP(d));
+      break;
+    default:
+      /* The caller has screwed up but we already griped above. */
+      break;
+    }
+  }
+
+  /* free storage if allocated (for tedit) */
+  if (OLC_STORAGE(d)) 
+    free(OLC_STORAGE(d));
+
+  /*
+   * Restore descriptor playing status.
+   */
+  if (d->character) {
+    REMOVE_BIT(PLR_FLAGS(d->character), PLR_WRITING);
+    act("$n stops using OLC.", TRUE, d->character, NULL, NULL, TO_ROOM);
+    
+    if (cleanup_type == CLEANUP_CONFIG)
+      mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s stops editing the game configuration", GET_NAME(d->character));
+    else if (STATE(d) == CON_TEDIT)
+      mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s stops editing text files.", GET_NAME(d->character));
+    else
+      mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s stops editing zone %d allowed zone %d", GET_NAME(d->character), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(d->character));
+
+    STATE(d) = CON_PLAYING;
+  }
+
+  free(d->olc);
+  d->olc = NULL;
+}
+
+/*
+ * This function is an exact duplicate of the tag_argument function found in
+ * one of the ascii patches located on the circlemud ftp website.
+ */
+void split_argument(char *argument, char *tag)
+{
+  char *tmp = argument, *ttag = tag, *wrt = argument;
+  int i;
+  
+  for (i = 0; *tmp; tmp++, i++) {
+    if (*tmp != ' ' && *tmp != '=')
+      *(ttag++) = *tmp;
+    else if (*tmp == '=')
+      break;
+  }
+  
+  *ttag = '\0';
+  
+  while (*tmp == '=' || *tmp == ' ')
+    tmp++;
+  
+  while (*tmp)
+    *(wrt++) = *(tmp++);
+  
+  *wrt = '\0';
+}
+
+void free_config(struct config_data *data)
+{
+  /****************************************************************************/
+  /** Free strings.                                                          **/
+  /****************************************************************************/
+  free_strings(data, OASIS_CFG);
+  
+  /****************************************************************************/
+  /** Free the data structure.                                               **/
+  /****************************************************************************/
+  free(data);
+}
+
+/******************************************************************************/
+/**                                                                          **/
+/** Function       : can_edit_zone()                                         **/
+/**                                                                          **/
+/** Description    : Checks to see if a builder can modify the specified     **/
+/**                  zone.                                                   **/
+/**                                                                          **/
+/** Arguments      :                                                         **/
+/**   ch                                                                     **/
+/**     The character requesting access to modify this zone.                 **/
+/**   rnum                                                                   **/
+/**     The real number of the zone attempted to be modified.                **/
+/**                                                                          **/
+/** Returns        : Returns TRUE if the builder has access, otherwise       **/
+/**                  FALSE.                                                  **/
+/**                                                                          **/
+/******************************************************************************/
+int can_edit_zone(struct char_data *ch, zone_rnum rnum)
+{
+  /* no access if called with bad arguments */
+  if (!ch->desc || IS_NPC(ch) || rnum == NOWHERE)
+    return FALSE;
+
+  /* always access if ch is high enough level */
+  if (GET_LEVEL(ch) >= LVL_IMPL)
+    return (TRUE);
+
+  /* always access if a player have helped build the zone in the first place */
+  if (is_name(GET_NAME(ch), zone_table[rnum].builders))
+    return (TRUE);
+
+  /* no access if you haven't been assigned a zone */
+  if (GET_OLC_ZONE(ch) == NOWHERE)
+    return FALSE;
+ 
+  /* no access if you're not at least LVL_BUILDER */
+  if (GET_LEVEL(ch) < LVL_BUILDER)
+    return FALSE;
+ 
+  /* always access if you're assigned to this zone */
+  if (real_zone(GET_OLC_ZONE(ch)) == rnum)
+    return TRUE;
+ 
+  return (FALSE);
+}
diff -BENbdpru circle-3.1/src/oasis.h circle3.1_oasis206/src/oasis.h
--- circle-3.1/src/oasis.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis.h	2003-10-07 11:24:10.000000000 +0200
@@ -0,0 +1,550 @@
+/************************************************************************
+ * OasisOLC - General / oasis.h					v2.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#define _OASISOLC	0x206   /* 2.0.6 */
+/*
+ * Used to determine what version of OasisOLC is installed.
+ *
+ * Ex: #if _OASISOLC >= OASIS_VERSION(2,0,0)
+ */
+#define OASIS_VERSION(x,y,z)	(((x) << 8 | (y) << 4 | (z))
+
+#define AEDIT_PERMISSION  999  /* arbitrary number higher than max zone vnum*/
+
+/*
+ * Set this to 1 to enable MobProg support.  MobProgs are available on
+ * the CircleMUD FTP site in the "contrib/scripting/" directory.
+ *
+ * -- THIS WILL NOT WORK WITHOUT MobProgs INSTALLED. --
+ * -- OasisOLC DOES NOT COME WITH THEM. -- Loud enough for you?
+ *
+ * It might work with DG Scripts (successor to MobProgs) but I haven't
+ * tried, nor have I heard of anyone trying.
+ */
+#define CONFIG_OASIS_MPROG	0
+
+/*
+ * Macros, defines, structs and globals for the OLC suite.  You will need
+ * to adjust these numbers if you ever add more.
+ */
+#define NUM_ROOM_FLAGS 		16
+#define NUM_ROOM_SECTORS	10
+
+#define NUM_MOB_FLAGS		18
+#define NUM_AFF_FLAGS		22
+#define NUM_ATTACK_TYPES	15
+
+#define NUM_ITEM_TYPES		24
+#define NUM_ITEM_FLAGS		17
+#define NUM_ITEM_WEARS 		15
+#define NUM_APPLIES		25
+#define NUM_LIQ_TYPES 		16
+#define NUM_POSITIONS		15
+#define NUM_SPELLS		51
+
+#define NUM_GENDERS		3
+#define NUM_SHOP_FLAGS 		2
+#define NUM_TRADERS 		7
+
+#if CONFIG_OASIS_MPROG
+/*
+ * Define this to how many MobProg scripts you have.
+ */
+#define NUM_PROGS		12
+#endif
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Limit information.
+ */
+#define MAX_ROOM_NAME	75
+#define MAX_MOB_NAME	50
+#define MAX_OBJ_NAME	50
+#define MAX_ROOM_DESC	2048
+#define MAX_EXIT_DESC	256
+#define MAX_EXTRA_DESC  512
+#define MAX_MOB_DESC	1024
+#define MAX_OBJ_DESC	512
+#define MAX_DUPLICATES  100  /* when loading in zedit */
+
+/* arbitrary limits - roll your own */
+/* max weapon is 50d50 .. avg. 625 dam... */
+#define MAX_WEAPON_SDICE         50
+#define MAX_WEAPON_NDICE         50
+
+#define MAX_OBJ_WEIGHT      1000000
+#define MAX_OBJ_COST        2000000
+#define MAX_OBJ_RENT        2000000
+#define MAX_CONTAINER_SIZE    10000
+
+#define MAX_MOB_GOLD        1000000 
+#define MAX_MOB_EXP         1500000
+/* this is one mud year.. */
+#define MAX_OBJ_TIMER       1071000 
+
+/* this defines how much memory is alloacted for 'bit strings' when
+ * saving in OLC. Remember to change it if you go for longer bitvectors.
+ */
+#define BIT_STRING_LENGTH 33
+/*
+ * The data types for miscellaneous functions.
+ */
+#define OASIS_WLD	0
+#define OASIS_MOB	1
+#define OASIS_OBJ	2
+#define OASIS_ZON	3
+#define OASIS_EXI	4
+#define OASIS_CFG	5
+
+/* -------------------------------------------------------------------------- */
+
+extern int top_of_socialt;
+
+/*
+ * Utilities exported from olc.c.
+ *   -- Umm, shouldn't this say 'from oasis.c' now???  * Mythran
+ */
+void cleanup_olc(struct descriptor_data *d, byte cleanup_type);
+void get_char_colors(struct char_data *ch);
+void split_argument(char *argument, char *tag);
+
+/*
+ * OLC structures.
+ */
+/* -------------------------------------------------------------------------- */
+
+/*
+ * The following defines used to be in config.c.
+ */
+#define NO	0
+#define YES	1
+
+struct oasis_olc_data {
+  int mode;                      /* how to parse input       */
+  zone_rnum zone_num;            /* current zone             */
+  room_vnum number;              /* vnum of subject          */
+  int value;                     /* mostly 'has changed' flag*/
+  char *storage;                 /* used for 'tedit'         */
+  struct char_data *mob;         /* used for 'medit'         */
+  struct room_data *room;        /* used for 'redit'         */
+  struct obj_data *obj;          /* used for 'oedit'         */
+  struct zone_data *zone;        /* used for 'zedit'         */
+  struct shop_data *shop;        /* used for 'sedit'         */
+  struct config_data *config;    /* used for 'cedit'         */
+  struct extra_descr_data *desc; /* used in '[r|o|m]edit'    */
+#if CONFIG_OASIS_MPROG           /*                          */
+  int total_mprogs;              /*                          */
+  struct mob_prog_data *mprog;   /*                          */
+  struct mob_prog_data *mprogl;  /*                          */
+#endif
+  struct social_messg *action;   /* Aedit uses this one      */
+};
+
+/*
+ * Exported globals.
+ */
+extern const char *nrm, *grn, *cyn, *yel;
+
+/*
+ * Descriptor access macros.
+ */
+#define OLC(d)		((d)->olc)
+#define OLC_MODE(d) 	(OLC(d)->mode)		/* Parse input mode.	*/
+#define OLC_NUM(d) 	(OLC(d)->number)	/* Room/Obj VNUM.	*/
+#define OLC_VAL(d) 	(OLC(d)->value)		/* Scratch variable.	*/
+#define OLC_ZNUM(d) 	(OLC(d)->zone_num)	/* Real zone number.	*/
+
+#define OLC_STORAGE(d)  (OLC(d)->storage)	/* char pointer.	*/
+#define OLC_ROOM(d) 	(OLC(d)->room)		/* Room structure.	*/
+#define OLC_OBJ(d) 	(OLC(d)->obj)		/* Object structure.	*/
+#define OLC_ZONE(d)     (OLC(d)->zone)          /* Zone structure.	*/
+#define OLC_MOB(d)	(OLC(d)->mob)		/* Mob structure.	*/
+#define OLC_SHOP(d) 	(OLC(d)->shop)		/* Shop structure.	*/
+#define OLC_DESC(d) 	(OLC(d)->desc)		/* Extra description.	*/
+#define OLC_CONFIG(d)	(OLC(d)->config)	/* Config structure.	*/
+
+#if CONFIG_OASIS_MPROG
+#define OLC_MPROG(d)	(OLC(d)->mprog)		/* Temporary MobProg.	*/
+#define OLC_MPROGL(d)	(OLC(d)->mprogl)	/* MobProg list.	*/
+#define OLC_MTOTAL(d)	(OLC(d)->total_mprogs)	/* Total mprog number.	*/
+#endif
+
+#define OLC_ACTION(d)   (OLC(d)->action)        /* Action structure     */
+
+/*
+ * Other macros.
+ */
+#define OLC_EXIT(d)		(OLC_ROOM(d)->dir_option[OLC_VAL(d)])
+
+/*
+ * Cleanup types.
+ */
+#define CLEANUP_ALL		1	/* Free the whole lot.			*/
+#define CLEANUP_STRUCTS 	2	/* Don't free strings.			*/
+#define CLEANUP_CONFIG          3       /* Used just to send proper message. 	*/
+
+/* Submodes of AEDIT connectedness     */
+#define AEDIT_CONFIRM_SAVESTRING       0
+#define AEDIT_CONFIRM_EDIT             1
+#define AEDIT_CONFIRM_ADD              2
+#define AEDIT_MAIN_MENU                3
+#define AEDIT_ACTION_NAME              4
+#define AEDIT_SORT_AS                  5
+#define AEDIT_MIN_CHAR_POS             6
+#define AEDIT_MIN_VICT_POS             7
+#define AEDIT_HIDDEN_FLAG              8
+#define AEDIT_MIN_CHAR_LEVEL           9
+#define AEDIT_NOVICT_CHAR              10
+#define AEDIT_NOVICT_OTHERS            11
+#define AEDIT_VICT_CHAR_FOUND          12
+#define AEDIT_VICT_OTHERS_FOUND        13
+#define AEDIT_VICT_VICT_FOUND          14
+#define AEDIT_VICT_NOT_FOUND           15
+#define AEDIT_SELF_CHAR                16
+#define AEDIT_SELF_OTHERS              17
+#define AEDIT_VICT_CHAR_BODY_FOUND     18
+#define AEDIT_VICT_OTHERS_BODY_FOUND   19
+#define AEDIT_VICT_VICT_BODY_FOUND     20
+#define AEDIT_OBJ_CHAR_FOUND           21
+#define AEDIT_OBJ_OTHERS_FOUND         22
+/*
+ * Submodes of OEDIT connectedness.
+ */
+#define OEDIT_MAIN_MENU              	1
+#define OEDIT_EDIT_NAMELIST          	2
+#define OEDIT_SHORTDESC              	3
+#define OEDIT_LONGDESC               	4
+#define OEDIT_ACTDESC                	5
+#define OEDIT_TYPE                   	6
+#define OEDIT_EXTRAS                 	7
+#define OEDIT_WEAR                  	8
+#define OEDIT_WEIGHT                	9
+#define OEDIT_COST                  	10
+#define OEDIT_COSTPERDAY            	11
+#define OEDIT_TIMER                 	12
+#define OEDIT_VALUE_1               	13
+#define OEDIT_VALUE_2               	14
+#define OEDIT_VALUE_3               	15
+#define OEDIT_VALUE_4               	16
+#define OEDIT_APPLY                 	17
+#define OEDIT_APPLYMOD              	18
+#define OEDIT_EXTRADESC_KEY         	19
+#define OEDIT_CONFIRM_SAVEDB        	20
+#define OEDIT_CONFIRM_SAVESTRING    	21
+#define OEDIT_PROMPT_APPLY          	22
+#define OEDIT_EXTRADESC_DESCRIPTION 	23
+#define OEDIT_EXTRADESC_MENU        	24
+#define OEDIT_LEVEL                 	25
+#define OEDIT_PERM			26
+
+/*
+ * Submodes of REDIT connectedness.
+ */
+#define REDIT_MAIN_MENU 		1
+#define REDIT_NAME 			2
+#define REDIT_DESC 			3
+#define REDIT_FLAGS 			4
+#define REDIT_SECTOR 			5
+#define REDIT_EXIT_MENU 		6
+#define REDIT_CONFIRM_SAVEDB 		7
+#define REDIT_CONFIRM_SAVESTRING 	8
+#define REDIT_EXIT_NUMBER 		9
+#define REDIT_EXIT_DESCRIPTION 		10
+#define REDIT_EXIT_KEYWORD 		11
+#define REDIT_EXIT_KEY 			12
+#define REDIT_EXIT_DOORFLAGS 		13
+#define REDIT_EXTRADESC_MENU 		14
+#define REDIT_EXTRADESC_KEY 		15
+#define REDIT_EXTRADESC_DESCRIPTION 	16
+#define REDIT_DELETE			17
+
+/*
+ * Submodes of ZEDIT connectedness.
+ */
+#define ZEDIT_MAIN_MENU              	0
+#define ZEDIT_DELETE_ENTRY		1
+#define ZEDIT_NEW_ENTRY			2
+#define ZEDIT_CHANGE_ENTRY		3
+#define ZEDIT_COMMAND_TYPE		4
+#define ZEDIT_IF_FLAG			5
+#define ZEDIT_ARG1			6
+#define ZEDIT_ARG2			7
+#define ZEDIT_ARG3			8
+#define ZEDIT_ZONE_NAME			9
+#define ZEDIT_ZONE_LIFE			10
+#define ZEDIT_ZONE_BOT			11
+#define ZEDIT_ZONE_TOP			12
+#define ZEDIT_ZONE_RESET		13
+#define ZEDIT_CONFIRM_SAVESTRING	14
+#define ZEDIT_ZONE_BUILDERS		15
+
+/*
+ * Submodes of MEDIT connectedness.
+ */
+#define MEDIT_MAIN_MENU              	0
+#define MEDIT_ALIAS			1
+#define MEDIT_S_DESC			2
+#define MEDIT_L_DESC			3
+#define MEDIT_D_DESC			4
+#define MEDIT_NPC_FLAGS			5
+#define MEDIT_AFF_FLAGS			6
+#define MEDIT_CONFIRM_SAVESTRING	7
+/*
+ * Numerical responses.
+ */
+#define MEDIT_NUMERICAL_RESPONSE	10
+#define MEDIT_SEX			11
+#define MEDIT_HITROLL			12
+#define MEDIT_DAMROLL			13
+#define MEDIT_NDD			14
+#define MEDIT_SDD			15
+#define MEDIT_NUM_HP_DICE		16
+#define MEDIT_SIZE_HP_DICE		17
+#define MEDIT_ADD_HP			18
+#define MEDIT_AC			19
+#define MEDIT_EXP			20
+#define MEDIT_GOLD			21
+#define MEDIT_POS			22
+#define MEDIT_DEFAULT_POS		23
+#define MEDIT_ATTACK			24
+#define MEDIT_LEVEL			25
+#define MEDIT_ALIGNMENT			26
+#if CONFIG_OASIS_MPROG
+#define MEDIT_MPROG                     27
+#define MEDIT_CHANGE_MPROG              28
+#define MEDIT_MPROG_COMLIST             29
+#define MEDIT_MPROG_ARGS                30
+#define MEDIT_MPROG_TYPE                31
+#define MEDIT_PURGE_MPROG               32
+#endif
+
+/*
+ * Submodes of SEDIT connectedness.
+ */
+#define SEDIT_MAIN_MENU              	0
+#define SEDIT_CONFIRM_SAVESTRING	1
+#define SEDIT_NOITEM1			2
+#define SEDIT_NOITEM2			3
+#define SEDIT_NOCASH1			4
+#define SEDIT_NOCASH2			5
+#define SEDIT_NOBUY			6
+#define SEDIT_BUY			7
+#define SEDIT_SELL			8
+#define SEDIT_PRODUCTS_MENU		11
+#define SEDIT_ROOMS_MENU		12
+#define SEDIT_NAMELIST_MENU		13
+#define SEDIT_NAMELIST			14
+/*
+ * Numerical responses.
+ */
+#define SEDIT_NUMERICAL_RESPONSE	20
+#define SEDIT_OPEN1			21
+#define SEDIT_OPEN2			22
+#define SEDIT_CLOSE1			23
+#define SEDIT_CLOSE2			24
+#define SEDIT_KEEPER			25
+#define SEDIT_BUY_PROFIT		26
+#define SEDIT_SELL_PROFIT		27
+#define SEDIT_TYPE_MENU			29
+#define SEDIT_DELETE_TYPE		30
+#define SEDIT_DELETE_PRODUCT		31
+#define SEDIT_NEW_PRODUCT		32
+#define SEDIT_DELETE_ROOM		33
+#define SEDIT_NEW_ROOM			34
+#define SEDIT_SHOP_FLAGS		35
+#define SEDIT_NOTRADE			36
+
+/* 
+ * Submodes of CEDIT connectedness.
+ */
+#define CEDIT_MAIN_MENU			0
+#define CEDIT_CONFIRM_SAVESTRING	1
+#define CEDIT_GAME_OPTIONS_MENU		2
+#define CEDIT_CRASHSAVE_OPTIONS_MENU	3
+#define CEDIT_OPERATION_OPTIONS_MENU	4
+#define CEDIT_DISP_EXPERIENCE_MENU	5
+#define CEDIT_ROOM_NUMBERS_MENU		6
+#define CEDIT_AUTOWIZ_OPTIONS_MENU	7
+#define CEDIT_OK			8
+#define CEDIT_NOPERSON			9
+#define CEDIT_NOEFFECT			10
+#define CEDIT_DFLT_IP			11
+#define CEDIT_DFLT_DIR			12
+#define CEDIT_LOGNAME			13
+#define CEDIT_MENU			14
+#define CEDIT_WELC_MESSG		15
+#define CEDIT_START_MESSG		16
+
+/*
+ * Numerical responses.
+ */
+#define CEDIT_NUMERICAL_RESPONSE	20
+#define CEDIT_LEVEL_CAN_SHOUT		21
+#define CEDIT_HOLLER_MOVE_COST		22
+#define CEDIT_TUNNEL_SIZE		23
+#define CEDIT_MAX_EXP_GAIN		24
+#define CEDIT_MAX_EXP_LOSS		25
+#define CEDIT_MAX_NPC_CORPSE_TIME	26
+#define CEDIT_MAX_PC_CORPSE_TIME	27
+#define CEDIT_IDLE_VOID			28
+#define CEDIT_IDLE_RENT_TIME		29
+#define CEDIT_IDLE_MAX_LEVEL		30
+#define CEDIT_DTS_ARE_DUMPS		31
+#define CEDIT_LOAD_INTO_INVENTORY	32
+#define CEDIT_TRACK_THROUGH_DOORS	33
+#define CEDIT_IMMORT_LEVEL_OK		34
+#define CEDIT_MAX_OBJ_SAVE		35
+#define CEDIT_MIN_RENT_COST		36
+#define CEDIT_AUTOSAVE_TIME		37
+#define CEDIT_CRASH_FILE_TIMEOUT	38
+#define CEDIT_RENT_FILE_TIMEOUT		39
+#define CEDIT_MORTAL_START_ROOM		40
+#define CEDIT_IMMORT_START_ROOM		41
+#define CEDIT_FROZEN_START_ROOM		42
+#define CEDIT_DONATION_ROOM_1		43
+#define CEDIT_DONATION_ROOM_2		44
+#define CEDIT_DONATION_ROOM_3		45
+#define CEDIT_DFLT_PORT			46
+#define CEDIT_MAX_PLAYING		47
+#define CEDIT_MAX_FILESIZE		48
+#define CEDIT_MAX_BAD_PWS		49
+#define CEDIT_SITEOK_EVERYONE		50
+#define CEDIT_NAMESERVER_IS_SLOW	51
+#define CEDIT_USE_AUTOWIZ		52
+#define CEDIT_MIN_WIZLIST_LEV		53
+
+/* -------------------------------------------------------------------------- */
+
+#ifndef __GENOLC_C__
+
+/*
+ * Prototypes to keep.
+ */
+#ifndef ACMD
+#define ACMD(name)  \
+   void name(struct char_data *ch, char *argument, int cmd, int subcmd)
+#endif
+void clear_screen(struct descriptor_data *);
+ACMD(do_oasis);
+ACMD(do_oasis_list);
+ACMD(do_oasis_links);
+
+/*
+ * Prototypes, to be moved later.
+ */
+void medit_free_mobile(struct char_data *mob);
+void medit_setup_new(struct descriptor_data *d);
+void medit_setup_existing(struct descriptor_data *d, int rmob_num);
+void init_mobile(struct char_data *mob);
+void medit_save_internally(struct descriptor_data *d);
+void medit_save_to_disk(zone_vnum zone_num);
+void medit_disp_positions(struct descriptor_data *d);
+void medit_disp_mprog(struct descriptor_data *d);
+void medit_change_mprog(struct descriptor_data *d);
+void medit_disp_mprog_types(struct descriptor_data *d);
+void medit_disp_sex(struct descriptor_data *d);
+void medit_disp_attack_types(struct descriptor_data *d);
+void medit_disp_mob_flags(struct descriptor_data *d);
+void medit_disp_aff_flags(struct descriptor_data *d);
+void medit_disp_menu(struct descriptor_data *d);
+void medit_parse(struct descriptor_data *d, char *arg);
+void medit_string_cleanup(struct descriptor_data *d, int terminator);
+ACMD(do_oasis_medit);
+
+void oedit_setup_new(struct descriptor_data *d);
+void oedit_setup_existing(struct descriptor_data *d, int real_num);
+void oedit_save_internally(struct descriptor_data *d);
+void oedit_save_to_disk(int zone_num);
+void oedit_disp_container_flags_menu(struct descriptor_data *d);
+void oedit_disp_extradesc_menu(struct descriptor_data *d);
+void oedit_disp_prompt_apply_menu(struct descriptor_data *d);
+void oedit_liquid_type(struct descriptor_data *d);
+void oedit_disp_apply_menu(struct descriptor_data *d);
+void oedit_disp_weapon_menu(struct descriptor_data *d);
+void oedit_disp_spells_menu(struct descriptor_data *d);
+void oedit_disp_val1_menu(struct descriptor_data *d);
+void oedit_disp_val2_menu(struct descriptor_data *d);
+void oedit_disp_val3_menu(struct descriptor_data *d);
+void oedit_disp_val4_menu(struct descriptor_data *d);
+void oedit_disp_type_menu(struct descriptor_data *d);
+void oedit_disp_extra_menu(struct descriptor_data *d);
+void oedit_disp_wear_menu(struct descriptor_data *d);
+void oedit_disp_menu(struct descriptor_data *d);
+void oedit_parse(struct descriptor_data *d, char *arg);
+void oedit_disp_perm_menu(struct descriptor_data *d);
+void oedit_string_cleanup(struct descriptor_data *d, int terminator);
+ACMD(do_oasis_oedit);
+
+void redit_string_cleanup(struct descriptor_data *d, int terminator);
+void redit_setup_new(struct descriptor_data *d);
+void redit_setup_existing(struct descriptor_data *d, int real_num);
+void redit_save_internally(struct descriptor_data *d);
+void redit_save_to_disk(zone_vnum zone_num);
+void redit_disp_extradesc_menu(struct descriptor_data *d);
+void redit_disp_exit_menu(struct descriptor_data *d);
+void redit_disp_exit_flag_menu(struct descriptor_data *d);
+void redit_disp_flag_menu(struct descriptor_data *d);
+void redit_disp_sector_menu(struct descriptor_data *d);
+void redit_disp_menu(struct descriptor_data *d);
+void redit_parse(struct descriptor_data *d, char *arg);
+void free_room(struct room_data *room);
+ACMD(do_oasis_redit);
+
+void sedit_setup_new(struct descriptor_data *d);
+void sedit_setup_existing(struct descriptor_data *d, int rshop_num);
+void sedit_save_internally(struct descriptor_data *d);
+void sedit_save_to_disk(int zone_num);
+void sedit_products_menu(struct descriptor_data *d);
+void sedit_compact_rooms_menu(struct descriptor_data *d);
+void sedit_rooms_menu(struct descriptor_data *d);
+void sedit_namelist_menu(struct descriptor_data *d);
+void sedit_shop_flags_menu(struct descriptor_data *d);
+void sedit_no_trade_menu(struct descriptor_data *d);
+void sedit_types_menu(struct descriptor_data *d);
+void sedit_disp_menu(struct descriptor_data *d);
+void sedit_parse(struct descriptor_data *d, char *arg);
+ACMD(do_oasis_sedit);
+
+void zedit_setup(struct descriptor_data *d, int room_num);
+void zedit_new_zone(struct char_data *ch, zone_vnum vzone_num, room_vnum bottom, room_vnum top);
+void zedit_create_index(int znum, char *type);
+void zedit_save_internally(struct descriptor_data *d);
+void zedit_save_to_disk(int zone_num);
+void zedit_disp_menu(struct descriptor_data *d);
+void zedit_disp_comtype(struct descriptor_data *d);
+void zedit_disp_arg1(struct descriptor_data *d);
+void zedit_disp_arg2(struct descriptor_data *d);
+void zedit_disp_arg3(struct descriptor_data *d);
+void zedit_parse(struct descriptor_data *d, char *arg);
+ACMD(do_oasis_zedit);
+
+void cedit_setup(struct descriptor_data *d);
+void cedit_parse(struct descriptor_data *d, char *arg);
+void cedit_save_to_disk( void );
+void cedit_string_cleanup(struct descriptor_data *d, int terminator);
+ACMD(do_oasis_cedit);
+
+void aedit_disp_menu(struct descriptor_data * d);
+void aedit_parse(struct descriptor_data * d, char *arg);
+void aedit_setup_new(struct descriptor_data *d);
+void aedit_setup_existing(struct descriptor_data *d, int real_num);
+void aedit_save_to_disk(struct descriptor_data *d);
+void aedit_save_internally(struct descriptor_data *d);
+void free_action(struct social_messg *mess);
+ACMD(do_oasis_aedit);
+
+int free_strings(void *data, int type);
+void list_rooms(struct char_data *ch  , zone_rnum rnum, room_vnum vmin, room_vnum vmax);
+void list_mobiles(struct char_data *ch, zone_rnum rnum, mob_vnum vmin , mob_vnum vmax );
+void list_objects(struct char_data *ch, zone_rnum rnum, obj_vnum vmin , obj_vnum vmax );
+void list_shops(struct char_data *ch  , zone_rnum rnum, shop_vnum vmin, shop_vnum vmax);
+void list_zones(struct char_data *ch);
+void print_zone(struct char_data *ch, zone_vnum vnum);
+int can_edit_zone(struct char_data *ch, zone_rnum rnum);
+
+#endif // ifndef __GENOLC_C__
diff -BENbdpru circle-3.1/src/oasis_copy.c circle3.1_oasis206/src/oasis_copy.c
--- circle-3.1/src/oasis_copy.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis_copy.c	2003-10-07 10:39:46.000000000 +0200
@@ -0,0 +1,368 @@
+/******************************************************************************/
+/** OasisOLC - InGame OLC Copying                                      v2.0  **/
+/** Original author: Levork                                                  **/
+/** Copyright 1996 Harvey Gilpin                                             **/
+/** Copyright 1997-2001 George Greer (greerga@circlemud.org)                 **/
+/** Copyright 2002 Kip Potter [Mythran] (kip_potter@hotmail.com)             **/
+/******************************************************************************/
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "handler.h"
+#include "db.h"
+#include "genolc.h"
+#include "genzon.h"
+#include "genwld.h"
+#include "oasis.h"
+#include "improved-edit.h"
+#include "constants.h"
+
+
+/******************************************************************************/
+/** Internal Functions                                                       **/
+/******************************************************************************/
+ACMD(do_dig);
+ACMD(do_room_copy);
+
+/******************************************************************************/
+/** Commands                                                                 **/
+/******************************************************************************/
+ACMD(do_dig)
+{
+  char sdir[MAX_INPUT_LENGTH], sroom[MAX_INPUT_LENGTH], *new_room_name;
+  room_vnum rvnum = NOWHERE;
+  room_rnum rrnum = NOWHERE;
+  zone_rnum zone;
+  int dir = 0, rawvnum;
+  struct descriptor_data *d = ch->desc; /* will save us some typing */
+  
+  /* Grab the room's name (if available). */
+  new_room_name = two_arguments(argument, sdir, sroom);
+  skip_spaces(&new_room_name);
+  
+  /* Can't dig if we don't know where to go. */
+  if (!*sdir || !*sroom) {
+    send_to_char(ch, "Format: dig <direction> <room> - to create an exit\r\n"
+                     "        dig <direction> -1     - to delete an exit\r\n");
+    return;
+  }
+
+  rawvnum = atoi(sroom);
+  if (rawvnum == -1)
+    rvnum = NOWHERE;
+  else
+    rvnum = (room_vnum)rawvnum;
+  rrnum = real_room(rvnum);  
+  dir = search_block(sdir, dirs, FALSE);
+  zone = world[IN_ROOM(ch)].zone;
+
+  if (dir < 0) {
+    send_to_char(ch, "Can not create an exit to the '%s'.\r\n", sdir);
+    return;
+  }
+  /* Make sure that the builder has access to the zone he's in. */
+  if ((zone == NOWHERE) || !can_edit_zone(ch, zone)) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    return;
+  }
+  /*
+   * Lets not allow digging to limbo. 
+   * After all, it'd just get us more errors on 'show errors'
+   */
+  if (rvnum == 0) {
+   send_to_char(ch, "The target exists, but you can't dig to limbo!\r\n");
+   return;
+  }
+  /*
+   * target room == -1 removes the exit 
+   */
+  if (rvnum == NOTHING) {
+    if (W_EXIT(IN_ROOM(ch), dir)) {
+      /* free the old pointers, if any */
+      if (W_EXIT(IN_ROOM(ch), dir)->general_description)
+        free(W_EXIT(IN_ROOM(ch), dir)->general_description);
+      if (W_EXIT(IN_ROOM(ch), dir)->keyword)
+        free(W_EXIT(IN_ROOM(ch), dir)->keyword);
+      free(W_EXIT(IN_ROOM(ch), dir));
+      W_EXIT(IN_ROOM(ch), dir) = NULL;
+      add_to_save_list(zone_table[world[IN_ROOM(ch)].zone].number, SL_WLD);
+      send_to_char(ch, "You remove the exit to the %s.\r\n", dirs[dir]);
+      return;
+    }
+    send_to_char(ch, "There is no exit to the %s.\r\n"
+                     "No exit removed.\r\n", dirs[dir]);
+    return;
+  }  
+  /*
+   * Can't dig in a direction, if it's already a door. 
+   */
+  if (W_EXIT(IN_ROOM(ch), dir)) {
+      send_to_char(ch, "There already is an exit to the %s.\r\n", dirs[dir]);
+      return;
+  }
+  
+  /* Make sure that the builder has access to the zone he's linking to. */
+  zone = real_zone_by_thing(rvnum);  
+  if (zone == NOWHERE) {
+    send_to_char(ch, "You cannot link to a non-existing zone!\r\n");
+    return;
+  }
+  if (!can_edit_zone(ch, zone)) {
+    send_to_char(ch, "You do not have permission to edit room #%d.\r\n", rvnum);
+    return;
+  }
+  /*
+   * Now we know the builder is allowed to make the link 
+   */
+  /* If the room doesn't exist, create it.*/
+  if (rrnum == NOWHERE) {
+    /*
+     * Give the descriptor an olc struct.
+     * This way we can let redit_save_internally handle the room adding.
+     */
+    if (d->olc) {
+      mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_dig: Player already had olc structure.");
+      free(d->olc);
+    }
+    CREATE(d->olc, struct oasis_olc_data, 1);
+    OLC_ZNUM(d) = zone;
+    OLC_NUM(d) = rvnum;
+    CREATE(OLC_ROOM(d), struct room_data, 1);
+    
+    
+    /* Copy the room's name. */
+    if (*new_room_name)
+     OLC_ROOM(d)->name = strdup(new_room_name);
+    else
+     OLC_ROOM(d)->name = strdup("An unfinished room");
+    
+    /* Copy the room's description.*/
+    OLC_ROOM(d)->description = strdup("You are in an unfinished room.\r\n");
+    OLC_ROOM(d)->zone = OLC_ZNUM(d);
+    OLC_ROOM(d)->number = NOWHERE;
+    
+    /*
+     * Save the new room to memory.
+     * redit_save_internally handles adding the room in the right place, etc.
+     */
+    redit_save_internally(d);
+    OLC_VAL(d) = 0;
+    
+    send_to_char(ch, "New room (%d) created.\r\n", rvnum);
+    cleanup_olc(d, CLEANUP_STRUCTS);
+    /* 
+     * update rrnum to the correct room rnum after adding the room 
+     */
+    rrnum = real_room(rvnum);
+  }
+
+  /*
+   * Now dig.
+   */
+  CREATE(W_EXIT(IN_ROOM(ch), dir), struct room_direction_data, 1);
+  W_EXIT(IN_ROOM(ch), dir)->general_description = NULL;
+  W_EXIT(IN_ROOM(ch), dir)->keyword = NULL;
+  W_EXIT(IN_ROOM(ch), dir)->to_room = rrnum;
+  add_to_save_list(zone_table[world[IN_ROOM(ch)].zone].number, SL_WLD);
+  
+  send_to_char(ch, "You make an exit %s to room %d (%s).\r\n", 
+                   dirs[dir], rvnum, world[rrnum].name);
+
+  /* 
+   * check if we can dig from there to here. 
+   */
+  if (W_EXIT(rrnum, rev_dir[dir])) 
+    send_to_char(ch, "Can not dig from %d to here. The target room already has an exit to the %s.\r\n",
+                     rvnum, dirs[rev_dir[dir]]);
+  else {
+    CREATE(W_EXIT(rrnum, rev_dir[dir]), struct room_direction_data, 1);
+    W_EXIT(rrnum, rev_dir[dir])->general_description = NULL;
+    W_EXIT(rrnum, rev_dir[dir])->keyword = NULL;
+    W_EXIT(rrnum, rev_dir[dir])->to_room = IN_ROOM(ch);
+    add_to_save_list(zone_table[world[rrnum].zone].number, SL_WLD);
+  }
+}
+
+ACMD(do_room_copy)
+{
+   struct room_data *room_src, *room_dst;
+   int room_num, j, buf_num;
+   zone_rnum dst_zone;
+   struct descriptor_data *dsc;
+   char buf[MAX_INPUT_LENGTH];
+     
+   one_argument(argument, buf);
+   
+   if (!*buf) {
+     send_to_char(ch, "Usage: rclone <target room>\r\n");
+     return;
+   }
+   
+   if (real_room((buf_num = atoi(buf))) != NOWHERE) {
+     send_to_char(ch, "That room already exist!\r\n");
+     return;
+   }
+
+   if ((dst_zone = real_zone_by_thing(buf_num)) == NOWHERE) {
+     send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+     return;
+   }
+    
+   if (!can_edit_zone(ch, dst_zone) ||
+       !can_edit_zone(ch, world[IN_ROOM(ch)].zone) ) {
+     send_to_char(ch, "You may only copy rooms within your designated zone(s)!\r\n");
+     return;
+   }
+   
+   
+   room_src = &world[IN_ROOM(ch)];
+   CREATE(room_dst, struct room_data, 1);
+
+   room_dst->zone = dst_zone;
+ 
+   /*
+   * Allocate space for all strings.
+   */
+   send_to_char(ch, "Cloning room....\r\n");
+   
+   room_dst->name = str_udup(world[IN_ROOM(ch)].name);
+   room_dst->description = str_udup(world[IN_ROOM(ch)].description);
+   room_dst->description = str_udup(world[IN_ROOM(ch)].description);
+   room_dst->number = buf_num;
+   room_dst->room_flags = ROOM_FLAGS(IN_ROOM(ch));
+   
+  /*
+   * Extra descriptions, if necessary.
+   */
+  
+  send_to_char(ch, "Cloning extra descriptions....\r\n");
+  if (world[IN_ROOM(ch)].ex_description) {
+    struct extra_descr_data *tdesc, *temp, *temp2;
+    CREATE(temp, struct extra_descr_data, 1);
+
+    room_dst->ex_description = temp;
+    for (tdesc = world[IN_ROOM(ch)].ex_description; tdesc; tdesc = tdesc->next) {
+      temp->keyword = strdup(tdesc->keyword);
+      temp->description = strdup(tdesc->description);
+      if (tdesc->next) {
+	CREATE(temp2, struct extra_descr_data, 1);
+	temp->next = temp2;
+	temp = temp2;
+      } else
+	temp->next = NULL;
+    }
+  }
+   /*
+    * Now save the room in the right place:
+    */ 
+  send_to_char(ch, "Saving new room...\r\n");
+    
+  if ((room_num = add_room(room_dst)) == NOWHERE) {
+    send_to_char(ch, "Something went wrong...\r\n");
+    log("SYSERR: do_room_copy: Something failed! (%d)", room_num);
+    return;
+  }
+    /* Idea contributed by C.Raehl 4/27/99 */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next) {
+    if (dsc == ch->desc)
+      continue;
+
+    if (STATE(dsc) == CON_ZEDIT) {
+      for (j = 0; OLC_ZONE(dsc)->cmd[j].command != 'S'; j++)
+        switch (OLC_ZONE(dsc)->cmd[j].command) {
+          case 'O':
+          case 'M':
+            OLC_ZONE(dsc)->cmd[j].arg3 += (OLC_ZONE(dsc)->cmd[j].arg3 >= room_num);
+            break;
+          case 'D':
+            OLC_ZONE(dsc)->cmd[j].arg2 += (OLC_ZONE(dsc)->cmd[j].arg2 >= room_num);
+            /* Fall through */
+          case 'R':
+            OLC_ZONE(dsc)->cmd[j].arg1 += (OLC_ZONE(dsc)->cmd[j].arg1 >= room_num);
+            break;
+          }
+    } else if (STATE(dsc) == CON_REDIT) {
+      for (j = 0; j < NUM_OF_DIRS; j++)
+        if (OLC_ROOM(dsc)->dir_option[j])
+          if (OLC_ROOM(dsc)->dir_option[j]->to_room >= room_num)
+            OLC_ROOM(dsc)->dir_option[j]->to_room++;
+    }
+  }
+  add_to_save_list(real_zone_by_thing(atoi(buf)), SL_WLD);
+  redit_save_to_disk(real_zone_by_thing(atoi(buf)));
+  send_to_char(ch, "Room cloned to %d.\r\nAll Done.\r\n", buf_num);
+}
+
+
+/****************************************************************************
+* BuildWalk - OasisOLC Extension by D. Tyler Barnes                         *
+****************************************************************************/
+
+/* For buildwalk. Finds the next free vnum in the zone */
+room_vnum redit_find_new_vnum(zone_rnum zone) {
+
+  room_vnum vnum = zone_table[zone].bot;
+  room_rnum rnum = real_room(vnum);
+
+  if (rnum != NOWHERE) {
+    for(; vnum <= zone_table[zone].top && rnum < top_of_world; vnum++, rnum++)
+      if (world[rnum].number > vnum)
+        return (vnum);
+  }
+  return(NOWHERE);
+
+}
+
+int buildwalk(struct char_data *ch, int dir) {
+
+  struct room_data *room;
+  room_vnum vnum;
+  room_rnum rnum;
+  char buf[MAX_STRING_LENGTH];
+
+  if (IS_NPC(ch))
+    return (0);
+  if (!PRF_FLAGGED(ch, PRF_BUILDWALK))
+    return (0);
+  if (!can_edit_zone(ch, world[IN_ROOM(ch)].zone))
+    return (0);
+  
+  vnum = redit_find_new_vnum(world[IN_ROOM(ch)].zone);
+  if (vnum == NOWHERE) {
+    send_to_char(ch, "No free vnums are available in this zone!\r\n");
+    return (0);
+  }
+
+  get_char_colors(ch);
+  
+  /* Set up data for add_room function */
+  CREATE(room, struct room_data, 1);
+  room->name = strdup("New BuildWalk Room");
+  snprintf(buf, sizeof(buf), "This unfinished room was created by %s.\r\n", GET_NAME(ch));
+  room->description = strdup(buf);
+  room->number = vnum;
+  room->zone = world[ch->in_room].zone;
+      
+  /* Add the room */
+  add_room(room);
+
+  /* Link rooms */
+  CREATE(EXIT(ch, dir), struct room_direction_data, 1);
+  EXIT(ch, dir)->to_room = (rnum = real_room(vnum));
+  CREATE(world[rnum].dir_option[rev_dir[dir]], struct room_direction_data, 1);
+  world[rnum].dir_option[rev_dir[dir]]->to_room = ch->in_room;
+
+  /* Memory cleanup */
+  free(room->name);
+  free(room->description);
+  free(room);
+
+  /* Report room creation to user */
+  send_to_char(ch, "%sRoom #%d created by BuildWalk.%s\r\n",
+                   yel, vnum, nrm);
+  return(1);
+}
diff -BENbdpru circle-3.1/src/oasis_delete.c circle3.1_oasis206/src/oasis_delete.c
--- circle-3.1/src/oasis_delete.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis_delete.c	2003-10-07 10:42:04.000000000 +0200
@@ -0,0 +1,134 @@
+/************************************************************************
+ *  OasisOLC - InGame OLC Deletion				v2.0	*
+ *  Original author: Levork						*
+ *  Copyright 1996 Harvey Gilpin					*
+ *  Copyright 1997-2001 George Greer (greerga@circlemud.org)		*
+ *  Copyright 2002 Kip Potter [Mythran] (kip_potter@hotmail.com)	*
+ ************************************************************************/
+ 
+/* 
+   +-----------------------------------------------------------------------+
+   | As of right now, all I have made is the ability to delete rooms.      |
+   | Deleting the rest of the area (objects, zones, mobiles) will be       |
+   | a little more difficult.  This is because they are broader and        |
+   | deleting one is more tedious (but not impossible).  I will (hopefully)|
+   | be adding more deletion code after this patch.                        |
+   |   -- Mythran                                                          |
+   +-----------------------------------------------------------------------+
+*/                                                                       
+
+
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "handler.h"
+#include "db.h"
+#include "genolc.h"
+#include "oasis.h"
+#include "improved-edit.h"
+
+/* Internal Functions */
+int free_strings(void *data, int type);
+
+/*
+ * remove_room_from_memory has been removed itself :P
+ * It was a duplication of delete_room() in genwld.c
+ * -- Welcor
+ */
+ 
+/************************************************************************\
+ ** Description :                                                      **
+ **   Free's strings from any object, room, mobiles, or player.        **
+ **                                                                    **
+ ** Return Value:                                                      **
+ **   TRUE if successful, otherwise, it returns FALSE.                 **
+ **                                                                    **
+ ** Parameters  :                                                      **
+ **   type - The OLC type constant relating to the data type of data.  **
+\************************************************************************/
+int free_strings(void *data, int type)
+{
+  struct room_data *room;
+  struct config_data *config;
+  int i;
+  
+  switch (type) {
+    case OASIS_WLD:
+      room = (struct room_data *) data;
+      
+      /* Free Descriptions */
+      if (room->name)
+        free(room->name);
+      
+      if (room->description)
+        free(room->description);
+      
+      if (room->ex_description)
+	free_ex_descriptions(room->ex_description);
+      
+      /* Return the return value of free_strings(). */
+      return (free_strings(room, OASIS_EXI));
+    
+    case OASIS_EXI:
+      room = (struct room_data *) data;
+      
+      for (i = 0; i < NUM_OF_DIRS; i++) {
+        if (room->dir_option[i]) {
+          if (room->dir_option[i]->general_description)
+            free(room->dir_option[i]->general_description);
+            
+          if (room->dir_option[i]->keyword)
+            free(room->dir_option[i]->keyword);
+          
+          free(room->dir_option[i]);
+        }
+      }
+      
+      return (TRUE);
+    
+    case OASIS_MOB:
+    case OASIS_OBJ:
+      return (FALSE);		/* For now... */
+    
+    case OASIS_CFG:
+      config = (struct config_data *) data;
+      
+      if (config->play.OK)
+        free(config->play.OK);
+        
+      if (config->play.NOPERSON)
+        free(config->play.NOPERSON);
+        
+      if (config->play.NOEFFECT)
+        free(config->play.NOEFFECT);
+      
+      if (config->operation.DFLT_IP)
+        free(config->operation.DFLT_IP);
+        
+      if (config->operation.DFLT_DIR)
+        free(config->operation.DFLT_DIR);
+        
+      if (config->operation.LOGNAME)
+        free(config->operation.LOGNAME);
+        
+      if (config->operation.MENU)
+        free(config->operation.MENU);
+        
+      if (config->operation.WELC_MESSG)
+        free(config->operation.WELC_MESSG);
+        
+      if (config->operation.START_MESSG)
+        free(config->operation.START_MESSG);
+      
+      return (TRUE);
+    
+    default:
+      mudlog(BRF, LVL_GOD, TRUE, "SYSERR: oasis_delete.c: free_strings: Invalid type handled (Type %d).", type);
+      return (FALSE);
+  }
+}
diff -BENbdpru circle-3.1/src/oasis_delete.h circle3.1_oasis206/src/oasis_delete.h
--- circle-3.1/src/oasis_delete.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis_delete.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,4 @@
+/*
+ * Function prototypes defined in oasis_delete.c.
+ */
+void remove_room_from_memory(room_rnum rnum);
diff -BENbdpru circle-3.1/src/oasis_list.c circle3.1_oasis206/src/oasis_list.c
--- circle-3.1/src/oasis_list.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oasis_list.c	2003-10-07 11:04:48.000000000 +0200
@@ -0,0 +1,413 @@
+/******************************************************************************/
+/** OasisOLC - InGame OLC Listings                                     v2.0  **/
+/** Original author: Levork                                                  **/
+/** Copyright 1996 Harvey Gilpin                                             **/
+/** Copyright 1997-2001 George Greer (greerga@circlemud.org)                 **/
+/** Copyright 2002 Kip Potter [Mythran] (kip_potter@hotmail.com)             **/
+/******************************************************************************/
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "handler.h"
+#include "db.h"
+#include "genolc.h"
+#include "oasis.h"
+#include "improved-edit.h"
+#include "shop.h"
+#include "screen.h"
+#include "constants.h"
+
+/******************************************************************************/
+/** External Variables                                                       **/
+/******************************************************************************/
+extern struct shop_data *shop_index;
+extern int top_shop;
+
+
+/******************************************************************************/
+/** Internal Functions                                                       **/
+/******************************************************************************/
+void list_rooms(struct char_data *ch  , zone_rnum rnum, room_vnum vmin, room_vnum vmax);
+void list_mobiles(struct char_data *ch, zone_rnum rnum, mob_vnum vmin , mob_vnum vmax );
+void list_objects(struct char_data *ch, zone_rnum rnum, obj_vnum vmin , obj_vnum vmax );
+void list_shops(struct char_data *ch  , zone_rnum rnum, shop_vnum vmin, shop_vnum vmax);
+void list_zones(struct char_data *ch);
+void print_zone(struct char_data *ch, zone_vnum vnum);
+
+
+/******************************************************************************/
+/** Ingame Commands                                                          **/
+/******************************************************************************/
+ACMD(do_oasis_list)
+{
+  zone_rnum rzone = NOWHERE;
+  room_rnum vmin = NOWHERE;
+  room_rnum vmax = NOWHERE;
+  char smin[MAX_INPUT_LENGTH];
+  char smax[MAX_INPUT_LENGTH];
+
+  two_arguments(argument, smin, smax);
+
+  if (subcmd == SCMD_OASIS_ZLIST) { /* special case */
+    if (smin && *smin && is_number(smin))
+      print_zone(ch, atoi(smin));
+    else
+      list_zones(ch);
+    return;
+  }
+
+  if (!*smin || *smin == '.') {
+    rzone = world[IN_ROOM(ch)].zone;
+  } else if (!*smax) {
+    rzone = real_zone(atoi(smin));
+
+    if (rzone == NOWHERE) {
+      send_to_char(ch, "Sorry, there's no zone with that number\r\n");
+      return;
+    }
+  } else {
+    /** Listing by min vnum / max vnum.  Retrieve the numeric values. **/
+    vmin = atoi(smin);
+    vmax = atoi(smax);
+
+    if (vmin > vmax) {
+      send_to_char(ch, "List from %d to %d - Aren't we funny today!\r\n",
+	vmin, vmax);
+      return;
+    }
+  }
+
+  switch (subcmd) {
+    case SCMD_OASIS_MLIST: list_mobiles(ch, rzone, vmin, vmax); break;
+    case SCMD_OASIS_OLIST: list_objects(ch, rzone, vmin, vmax); break;
+    case SCMD_OASIS_RLIST: list_rooms(ch, rzone, vmin, vmax); break;
+    case SCMD_OASIS_SLIST: list_shops(ch, rzone, vmin, vmax); break;
+    default:
+      send_to_char(ch, "You can't list that!\r\n");
+      mudlog(BRF, LVL_IMMORT, TRUE,
+        "SYSERR: do_oasis_list: Unknown list option: %d", subcmd);
+  }
+}
+
+ACMD(do_oasis_links)
+{
+  zone_rnum zrnum;
+  zone_vnum zvnum;
+  room_rnum nr, to_room;
+  int first, last, j;
+  char arg[MAX_INPUT_LENGTH];
+
+  skip_spaces(&argument);
+  one_argument(argument, arg);
+    
+  if (!arg || !*arg) {
+    send_to_char(ch,
+      "Syntax: links <zone_vnum> ('.' for zone you are standing in)\r\n");
+      return;
+    }
+    
+  if (!strcmp(arg, ".")) {
+    zrnum = world[IN_ROOM(ch)].zone;
+    zvnum = zone_table[zrnum].number;
+  } else {
+    zvnum = atoi(arg);
+    zrnum = real_zone(zvnum);
+  }
+    
+  if (zrnum == NOWHERE || zvnum == NOWHERE) {
+    send_to_char(ch, "No zone was found with that number.\n\r");
+    return;
+  }
+
+  last  = zone_table[zrnum].top;
+  first = zone_table[zrnum].bot;
+
+  send_to_char(ch, "Zone %d is linked to the following zones:\r\n", zvnum);
+  for (nr = 0; nr <= top_of_world && (GET_ROOM_VNUM(nr) <= last); nr++) {
+    if (GET_ROOM_VNUM(nr) >= first) {
+      for (j = 0; j < NUM_OF_DIRS; j++) {
+	if (world[nr].dir_option[j]) {
+	  to_room = world[nr].dir_option[j]->to_room;
+	  if (to_room != NOWHERE && (zrnum != world[to_room].zone))
+	    send_to_char(ch, "%3d %-30s at %5d (%-5s) ---> %5d\r\n",
+	      zone_table[world[to_room].zone].number,
+	      zone_table[world[to_room].zone].name,
+	      GET_ROOM_VNUM(nr), dirs[j], world[to_room].number);
+	}
+      }
+    }
+  }
+}
+
+/******************************************************************************/
+/** Helper Functions                                                         **/
+/******************************************************************************/
+
+
+/*
+ * List all rooms in a zone.                              
+ */                                                                           
+void list_rooms(struct char_data *ch, zone_rnum rnum, zone_vnum vmin, zone_vnum vmax)
+{
+  int i, j, bottom, top, counter = 0;
+  /*
+   * Expect a minimum / maximum number if the rnum for the zone is NOWHERE. 
+   */
+  if (rnum != NOWHERE) {
+    bottom = zone_table[rnum].bot;
+    top    = zone_table[rnum].top;
+  } else {
+    bottom = vmin;
+    top    = vmax;
+  }
+  
+  send_to_char (ch,
+  "Index VNum    Room Name                                Exits\r\n"
+  "----- ------- ---------------------------------------- -----\r\n");
+  
+  for (i = 0; i <= top_of_world; i++) {
+    
+    /** Check to see if this room is one of the ones needed to be listed.    **/
+    if ((world[i].number >= bottom) && (world[i].number <= top)) {
+      counter++;
+      
+      send_to_char(ch, "%4d) [%s%-5d%s] %s%-40.40s%s ",
+        counter, QGRN, world[i].number, QNRM, QCYN, world[i].name, QNRM);
+
+      for (j = 0; j < NUM_OF_DIRS; j++) {
+        if (W_EXIT(i, j) == NULL)
+          continue;
+        if (W_EXIT(i, j)->to_room == NOWHERE)
+          continue;
+          
+        if (world[W_EXIT(i, j)->to_room].zone != world[i].zone) 
+          send_to_char(ch, "(%s%d%s)", QYEL, world[W_EXIT(i, j)->to_room].number, QNRM);
+     
+      }
+    
+      send_to_char(ch, "\r\n");
+    }
+  }
+  
+  if (counter == 0)
+    send_to_char(ch, "No rooms found for zone #%d\r\n", zone_table[rnum].number);
+}
+
+/*
+ * List all mobiles in a zone.                              
+ */                                                                           
+void list_mobiles(struct char_data *ch, zone_rnum rnum, zone_vnum vmin, zone_vnum vmax)
+{
+  int i, bottom, top, counter = 0;
+  
+  if (rnum != NOWHERE) {
+    bottom = zone_table[rnum].bot;
+    top    = zone_table[rnum].top;
+  } else {
+    bottom = vmin;
+    top    = vmax;
+  }
+  
+  send_to_char(ch,
+  "Index VNum    Mobile Name                                   Level\r\n"
+  "----- ------- --------------------------------------------- -----\r\n");
+  
+  for (i = 0; i <= top_of_mobt; i++) {
+    if (mob_index[i].vnum >= bottom && mob_index[i].vnum <= top) {
+      counter++;
+      
+      send_to_char(ch, "%s%4d%s) [%s%-5d%s] %s%-44.44s %s%4d%s\r\n",
+        QGRN, counter, QNRM, QGRN, mob_index[i].vnum, QNRM,
+        QCYN, mob_proto[i].player.short_descr, 
+        QYEL, mob_proto[i].player.level, QNRM);
+      
+    }
+  }
+  
+  if (counter == 0)
+    send_to_char(ch, "None found.\r\n");
+}
+
+/*
+ * List all objects in a zone.                              
+ */                                                                           
+void list_objects(struct char_data *ch, zone_rnum rnum, room_vnum vmin, room_vnum vmax)
+{
+  int i, bottom, top, counter = 0;
+  
+  if (rnum != NOWHERE) {
+    bottom = zone_table[rnum].bot;
+    top    = zone_table[rnum].top;
+  } else {
+    bottom = vmin;
+    top    = vmax;
+  }
+  
+  send_to_char(ch,
+  "Index VNum    Object Name                                  Object Type\r\n"
+  "----- ------- -------------------------------------------- ----------------\r\n");
+  
+  for (i = 0; i <= top_of_objt; i++) {
+    if (obj_index[i].vnum >= bottom && obj_index[i].vnum <= top) {
+      counter++;
+      
+      send_to_char(ch, "%s%4d%s) [%s%-5d%s] %s%-44.44s %s[%s]%s\r\n",
+        QGRN, counter, QNRM, QGRN, obj_index[i].vnum, QNRM,
+        QCYN, obj_proto[i].short_description, QYEL,
+        item_types[obj_proto[i].obj_flags.type_flag], QNRM);
+      
+    }
+  }
+  
+  if (counter == 0)
+    send_to_char(ch, "None found.\r\n");
+}
+
+
+/*
+ * List all shops in a zone.                              
+ */                                                                           
+void list_shops(struct char_data *ch, zone_rnum rnum, shop_vnum vmin, shop_vnum vmax)
+{
+  int i, j, bottom, top, counter = 0;
+  
+  if (rnum != NOWHERE) {
+    bottom = zone_table[rnum].bot;
+    top    = zone_table[rnum].top;
+  } else {
+    bottom = vmin;
+    top    = vmax;
+  }
+  
+  send_to_char (ch,
+  "Index VNum    RNum    Shop Room(s)\r\n"
+  "----- ------- ------- -----------------------------------------\r\n");
+  
+  for (i = 0; i <= top_shop; i++) {
+    if (SHOP_NUM(i) >= bottom && SHOP_NUM(i) <= top) {
+      counter++;
+      
+      /* the +1 is strange but fits the rest of the shop code */
+      send_to_char(ch, "%s%4d%s) [%s%-5d%s] [%s%-5d%s]",
+        QGRN, counter, QNRM, QGRN, SHOP_NUM(i), QNRM, QGRN, i + 1, QNRM); 
+      
+      /* Thanks to Ken Ray (kenr86@hotmail.com) for this display fix -- Welcor*/      
+      for (j = 0; SHOP_ROOM(i, j) != NOWHERE; j++)
+        send_to_char(ch, "%s%s[%s%-5d%s]%s",
+                      ((j > 0) && (j % 6 == 0)) ? "\r\n                      " : " ",
+                      QCYN, QYEL, SHOP_ROOM(i, j), QCYN, QNRM);
+      
+      if (j == 0)
+        send_to_char(ch, "%sNone.%s", QCYN, QNRM);
+      
+      send_to_char(ch, "\r\n");
+    }
+  }
+  
+  if (counter == 0)
+    send_to_char(ch, "None found.\r\n");
+}
+
+/*
+ * List all zones in the world (sort of like 'show zones').                              
+ */                                                                           
+void list_zones(struct char_data *ch)
+{
+  int i;
+  
+  send_to_char(ch,
+  "VNum  Zone Name                      Builder(s)\r\n"
+  "----- ------------------------------ --------------------------------------\r\n");
+  
+  for (i = 0; i <= top_of_zone_table; i++)
+    send_to_char(ch, "[%s%3d%s] %s%-30.30s %s%-1s%s\r\n",
+      QGRN, zone_table[i].number, QNRM, QCYN, zone_table[i].name,
+      QYEL, zone_table[i].builders ? zone_table[i].builders : "None.", QNRM);
+}
+
+
+
+/*
+ * Prints all of the zone information for the selected zone.
+ */
+void print_zone(struct char_data *ch, zone_vnum vnum)
+{
+  zone_rnum rnum;
+  int size_rooms, size_objects, size_mobiles, i;
+  room_vnum top, bottom;
+  int largest_table;
+  
+  if ((rnum = real_zone(vnum)) == NOWHERE) {
+    send_to_char(ch, "Zone #%d does not exist in the database.\r\n", vnum);
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Locate the largest of the three, top_of_world, top_of_mobt, or         **/
+  /** top_of_objt.                                                           **/
+  /****************************************************************************/
+  if (top_of_world >= top_of_objt && top_of_world >= top_of_mobt)
+    largest_table = top_of_world;
+  else if (top_of_objt >= top_of_mobt && top_of_objt >= top_of_world)
+    largest_table = top_of_objt;
+  else
+    largest_table = top_of_mobt;
+  
+  /****************************************************************************/
+  /** Initialize some of the variables.                                      **/
+  /****************************************************************************/
+  size_rooms   = 0;
+  size_objects = 0;
+  size_mobiles = 0;
+  top          = zone_table[rnum].top;
+  bottom       = zone_table[rnum].bot;
+  
+  for (i = 0; i <= largest_table; i++) {
+    if (i <= top_of_world)
+      if (world[i].zone == rnum)
+        size_rooms++;
+    
+    if (i <= top_of_objt)
+      if (obj_index[i].vnum >= bottom && obj_index[i].vnum <= top)
+        size_objects++;
+    
+    if (i <= top_of_mobt)
+      if (mob_index[i].vnum >= bottom && mob_index[i].vnum <= top)
+        size_mobiles++;
+  }
+  
+  /****************************************************************************/
+  /** Display all of the zone information at once.                           **/
+  /****************************************************************************/
+  send_to_char(ch,
+    "%sVirtual Number = %s%d\r\n"
+    "%sName of zone   = %s%s\r\n"
+    "%sBuilders       = %s%s\r\n"
+    "%sLifespan       = %s%d\r\n"
+    "%sAge            = %s%d\r\n"
+    "%sBottom of Zone = %s%d\r\n"
+    "%sTop of Zone    = %s%d\r\n"
+    "%sReset Mode     = %s%s\r\n"
+    "%sSize\r\n"
+    "%s   Rooms       = %s%d\r\n"
+    "%s   Objects     = %s%d\r\n"
+    "%s   Mobiles     = %s%d%s\r\n",
+    QGRN, QCYN, zone_table[rnum].number,
+    QGRN, QCYN, zone_table[rnum].name,
+    QGRN, QCYN, zone_table[rnum].builders,
+    QGRN, QCYN, zone_table[rnum].lifespan,
+    QGRN, QCYN, zone_table[rnum].age,
+    QGRN, QCYN, zone_table[rnum].bot, 
+    QGRN, QCYN, zone_table[rnum].top,
+    QGRN, QCYN, zone_table[rnum].reset_mode ? ((zone_table[rnum].reset_mode == 1) ?
+    "Reset when no players are in zone." : "Normal reset.") : "Never reset",
+    QGRN,
+    QGRN, QCYN, size_rooms,
+    QGRN, QCYN, size_objects,
+    QGRN, QCYN, size_mobiles, QNRM);
+}
+
diff -BENbdpru circle-3.1/src/objsave.c circle3.1_oasis206/src/objsave.c
--- circle-3.1/src/objsave.c	2002-05-02 05:12:42.000000000 +0200
+++ circle3.1_oasis206/src/objsave.c	2003-07-26 10:19:22.000000000 +0200
@@ -30,10 +30,6 @@
 /* external variables */
 extern struct player_index_element *player_table;
 extern int top_of_p_table;
-extern int rent_file_timeout, crash_file_timeout;
-extern int free_rent;
-extern int min_rent_cost;
-extern int max_obj_save;	/* change in config.c */
 
 /* Extern functions */
 ACMD(do_action);
@@ -297,7 +293,7 @@ int Crash_clean_file(char *name)
 
   if ((rent.rentcode == RENT_CRASH) ||
       (rent.rentcode == RENT_FORCED) || (rent.rentcode == RENT_TIMEDOUT)) {
-    if (rent.time < time(0) - (crash_file_timeout * SECS_PER_REAL_DAY)) {
+    if (rent.time < time(0) - (CONFIG_CRASH_TIMEOUT * SECS_PER_REAL_DAY)) {
       const char *filetype;
 
       Crash_delete_file(name);
@@ -320,7 +316,7 @@ int Crash_clean_file(char *name)
     }
     /* Must retrieve rented items w/in 30 days */
   } else if (rent.rentcode == RENT_RENTED)
-    if (rent.time < time(0) - (rent_file_timeout * SECS_PER_REAL_DAY)) {
+    if (rent.time < time(0) - (CONFIG_RENT_TIMEOUT * SECS_PER_REAL_DAY)) {
       Crash_delete_file(name);
       log("    Deleting %s's rent file.", name);
       return (1);
@@ -605,7 +601,7 @@ int Crash_load(struct char_data *ch)
 
   /* Little hoarding check. -gg 3/1/98 */
   mudlog(NRM, MAX(GET_INVIS_LEV(ch), LVL_GOD), TRUE, "%s (level %d) has %d object%s (max %d).",
-	GET_NAME(ch), GET_LEVEL(ch), num_objs, num_objs != 1 ? "s" : "", max_obj_save);
+	GET_NAME(ch), GET_LEVEL(ch), num_objs, num_objs != 1 ? "s" : "", CONFIG_MAX_OBJ_SAVE);
 
   /* turn this into a crash file by re-writing the control block */
   rent.rentcode = RENT_CRASH;
@@ -1020,7 +1016,7 @@ int Crash_offer_rent(struct char_data *c
   if (norent)
     return (0);
 
-  totalcost = min_rent_cost * factor;
+  totalcost = CONFIG_MIN_RENT_COST * factor;
 
   Crash_report_rent(ch, recep, ch->carrying, &totalcost, &numitems, display, factor);
 
@@ -1032,17 +1028,17 @@ int Crash_offer_rent(struct char_data *c
 	FALSE, recep, 0, ch, TO_VICT);
     return (0);
   }
-  if (numitems > max_obj_save) {
+  if (numitems > CONFIG_MAX_OBJ_SAVE) {
     char buf[256];
 
-    snprintf(buf, sizeof(buf), "$n tells you, 'Sorry, but I cannot store more than %d items.'", max_obj_save);
+    snprintf(buf, sizeof(buf), "$n tells you, 'Sorry, but I cannot store more than %d items.'", CONFIG_MAX_OBJ_SAVE);
     act(buf, FALSE, recep, 0, ch, TO_VICT);
     return (0);
   }
   if (display) {
     char buf[256];
 
-    snprintf(buf, sizeof(buf), "$n tells you, 'Plus, my %d coin fee..'", min_rent_cost * factor);
+    snprintf(buf, sizeof(buf), "$n tells you, 'Plus, my %d coin fee..'", CONFIG_MIN_RENT_COST * factor);
     act(buf, FALSE, recep, 0, ch, TO_VICT);
 
     snprintf(buf, sizeof(buf), "$n tells you, 'For a total of %ld coins%s.'", totalcost, factor == RENT_FACTOR ? " per day" : "");
@@ -1087,7 +1083,7 @@ int gen_receptionist(struct char_data *c
     return (TRUE);
   }
 
-  if (free_rent) {
+  if (CONFIG_FREE_RENT) {
     act("$n tells you, 'Rent is free here.  Just quit, and your objects will be saved!'",
 	FALSE, recep, 0, ch, TO_VICT);
     return (1);
diff -BENbdpru circle-3.1/src/oedit.c circle3.1_oasis206/src/oedit.c
--- circle-3.1/src/oedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/oedit.c	2003-10-07 11:04:48.000000000 +0200
@@ -0,0 +1,1258 @@
+/************************************************************************
+ * OasisOLC - Objects / oedit.c					v2.0	*
+ * Original author: Levork						*
+ * Copyright 1996 by Harvey Gilpin					*
+ * Copyright 1997-2001 by George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "spells.h"
+#include "utils.h"
+#include "db.h"
+#include "boards.h"
+#include "constants.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genobj.h"
+#include "genzon.h"
+#include "oasis.h"
+#include "improved-edit.h"
+
+/*------------------------------------------------------------------------*/
+
+/*
+ * External variable declarations.
+ */
+
+extern struct obj_data *obj_proto;
+extern struct index_data *obj_index;
+extern struct obj_data *object_list;
+extern obj_rnum top_of_objt;
+extern struct zone_data *zone_table;
+extern zone_rnum top_of_zone_table;
+extern struct shop_data *shop_index;
+extern struct attack_hit_type attack_hit_text[];
+extern struct spell_info_type spell_info[];
+extern struct board_info_type board_info[];
+extern struct descriptor_data *descriptor_list;
+
+/*------------------------------------------------------------------------*/
+
+/*
+ * Handy macros.
+ */
+#define S_PRODUCT(s, i) ((s)->producing[(i)])
+
+/*------------------------------------------------------------------------*\
+  Utility and exported functions
+\*------------------------------------------------------------------------*/
+
+ACMD(do_oasis_oedit)
+{
+  int number = NOWHERE, save = 0, real_num;
+  struct descriptor_data *d;
+  char *buf3;
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  
+  /****************************************************************************/
+  /** Parse any arguments.                                                   **/
+  /****************************************************************************/
+  buf3 = two_arguments(argument, buf1, buf2);
+  
+  /****************************************************************************/
+  /** If there aren't any arguments...well...they can't modify nothing now   **/
+  /** can they?                                                              **/
+  /****************************************************************************/
+  if (!*buf1) {
+    send_to_char(ch, "Specify an object VNUM to edit.\r\n");
+    return;
+  } else if (!isdigit(*buf1)) {
+    if (str_cmp("save", buf1) != 0) {
+      send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+      return;
+    }
+    
+    save = TRUE;
+    
+    if (is_number(buf2))
+      number = atoi(buf2);
+    else if (GET_OLC_ZONE(ch) > 0) {
+      zone_rnum zlok;
+      
+      if ((zlok = real_zone(GET_OLC_ZONE(ch))) == NOWHERE)
+        number = NOWHERE;
+      else
+        number = genolc_zone_bottom(zlok);
+    }
+    
+    if (number == NOWHERE) {
+      send_to_char(ch, "Save which zone?\r\n");
+      return;
+    }
+  }
+  
+  /****************************************************************************/
+  /** If a numeric argument was given, get it.                               **/
+  /****************************************************************************/
+  if (number == NOWHERE)
+    number = atoi(buf1);
+  
+  /****************************************************************************/
+  /** Check that whatever it is isn't already being edited.                  **/
+  /****************************************************************************/
+  for (d = descriptor_list; d; d = d->next) {
+    if (STATE(d) == CON_OEDIT) {
+      if (d->olc && OLC_NUM(d) == number) {
+        send_to_char(ch, "That object is currently being edited by %s.\r\n",
+          PERS(d->character, ch));
+        return;
+      }
+    }
+  }
+  
+  /****************************************************************************/
+  /** Point d to the builder's descriptor (for easier typing later).         **/
+  /****************************************************************************/
+  d = ch->desc;
+  
+  /****************************************************************************/
+  /** Give the descriptor an OLC structure.                                  **/
+  /****************************************************************************/
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE,
+      "SYSERR: do_oasis: Player already had olc structure.");
+    free(d->olc);
+  }
+  
+  CREATE(d->olc, struct oasis_olc_data, 1);
+  
+  /****************************************************************************/
+  /** Find the zone.                                                         **/
+  /****************************************************************************/
+  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == NOWHERE) {
+    send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Everyone but IMPLs can only edit zones they have been assigned.        **/
+  /****************************************************************************/
+  if (!can_edit_zone(ch, OLC_ZNUM(d))) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    mudlog(BRF, LVL_IMPL, TRUE, "OLC: %s tried to edit zone %d allowed zone %d",
+      GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** If we need to save, save the objects.                                  **/
+  /****************************************************************************/
+  if (save) {
+    send_to_char(ch, "Saving all objects in zone %d.\r\n",
+      zone_table[OLC_ZNUM(d)].number);
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE,
+      "OLC: %s saves object info for zone %d.", GET_NAME(ch),
+      zone_table[OLC_ZNUM(d)].number);
+    
+    /**************************************************************************/
+    /** Save the objects in this zone.                                       **/
+    /**************************************************************************/
+    save_objects(OLC_ZNUM(d));
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  OLC_NUM(d) = number;
+  
+  /****************************************************************************/
+  /** If this is a new object, setup a new object, otherwise setup the       **/
+  /** existing object.                                                       **/
+  /****************************************************************************/
+  if ((real_num = real_object(number)) != NOTHING)
+    oedit_setup_existing(d, real_num);
+  else
+    oedit_setup_new(d);
+    
+  STATE(d) = CON_OEDIT;
+  
+  /****************************************************************************/
+  /** Send the OLC message to the players in the same room as the builder.   **/
+  /****************************************************************************/
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  
+  /****************************************************************************/
+  /** Log the OLC message.                                                   **/
+  /****************************************************************************/
+  mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s starts editing zone %d allowed zone %d",
+    GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+}
+
+void oedit_setup_new(struct descriptor_data *d)
+{
+  CREATE(OLC_OBJ(d), struct obj_data, 1);
+
+  clear_object(OLC_OBJ(d));
+  OLC_OBJ(d)->name = strdup("unfinished object");
+  OLC_OBJ(d)->description = strdup("An unfinished object is lying here.");
+  OLC_OBJ(d)->short_description = strdup("an unfinished object");
+  GET_OBJ_WEAR(OLC_OBJ(d)) = ITEM_WEAR_TAKE;
+  OLC_VAL(d) = 0;
+  oedit_disp_menu(d);
+}
+
+/*------------------------------------------------------------------------*/
+
+void oedit_setup_existing(struct descriptor_data *d, int real_num)
+{
+  struct obj_data *obj;
+
+  /*
+   * Allocate object in memory.
+   */
+  CREATE(obj, struct obj_data, 1);
+  copy_object(obj, &obj_proto[real_num]);
+
+  /*
+   * Attach new object to player's descriptor.
+   */
+  OLC_OBJ(d) = obj;
+  OLC_VAL(d) = 0;
+  oedit_disp_menu(d);
+}
+
+/*------------------------------------------------------------------------*/
+
+void oedit_save_internally(struct descriptor_data *d)
+{
+  int i;
+  obj_rnum robj_num;
+  struct descriptor_data *dsc;
+
+  i = (real_object(OLC_NUM(d)) == NOTHING);
+
+  if ((robj_num = add_object(OLC_OBJ(d), OLC_NUM(d))) == NOTHING) {
+    log("oedit_save_internally: add_object failed.");
+    return;
+  }
+
+  if (!i)	/* If it's not a new object, don't renumber. */
+    return;
+
+  /*
+   * Renumber produce in shops being edited.
+   */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next)
+    if (STATE(dsc) == CON_SEDIT)
+      for (i = 0; S_PRODUCT(OLC_SHOP(dsc), i) != NOTHING; i++)
+	if (S_PRODUCT(OLC_SHOP(dsc), i) >= robj_num)
+	  S_PRODUCT(OLC_SHOP(dsc), i)++;
+
+
+  /* Update other people in zedit too. From: C.Raehl 4/27/99 */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next)
+    if (STATE(dsc) == CON_ZEDIT)
+      for (i = 0; OLC_ZONE(dsc)->cmd[i].command != 'S'; i++)
+        switch (OLC_ZONE(dsc)->cmd[i].command) {
+          case 'P':
+            OLC_ZONE(dsc)->cmd[i].arg3 += (OLC_ZONE(dsc)->cmd[i].arg3 >= robj_num);
+            /* Fall through. */
+          case 'E':
+          case 'G':
+          case 'O':
+            OLC_ZONE(dsc)->cmd[i].arg1 += (OLC_ZONE(dsc)->cmd[i].arg1 >= robj_num);
+            break;
+          case 'R':
+            OLC_ZONE(dsc)->cmd[i].arg2 += (OLC_ZONE(dsc)->cmd[i].arg2 >= robj_num);
+            break;
+          default:
+          break;
+        }
+}
+
+/*------------------------------------------------------------------------*/
+
+void oedit_save_to_disk(int zone_num)
+{
+  save_objects(zone_table[zone_num].number);
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+/*
+ * For container flags.
+ */
+void oedit_disp_container_flags_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  sprintbit(GET_OBJ_VAL(OLC_OBJ(d), 1), container_bits, bits, sizeof(bits));
+  write_to_output(d, 
+	  "%s1%s) CLOSEABLE\r\n"
+	  "%s2%s) PICKPROOF\r\n"
+	  "%s3%s) CLOSED\r\n"
+	  "%s4%s) LOCKED\r\n"
+	  "Container flags: %s%s%s\r\n"
+	  "Enter flag, 0 to quit : ",
+	  grn, nrm, grn, nrm, grn, nrm, grn, nrm, cyn, bits, nrm);
+}
+
+/*
+ * For extra descriptions.
+ */
+void oedit_disp_extradesc_menu(struct descriptor_data *d)
+{
+  struct extra_descr_data *extra_desc = OLC_DESC(d);
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  write_to_output(d,
+	  "Extra desc menu\r\n"
+	  "%s1%s) Keyword: %s%s\r\n"
+	  "%s2%s) Description:\r\n%s%s\r\n"
+	  "%s3%s) Goto next description: %s\r\n"
+	  "%s0%s) Quit\r\n"
+	  "Enter choice : ",
+
+     	  grn, nrm, yel, (extra_desc->keyword && *extra_desc->keyword) ? extra_desc->keyword : "<NONE>",
+	  grn, nrm, yel, (extra_desc->description && *extra_desc->description) ? extra_desc->description : "<NONE>",
+	  grn, nrm, !extra_desc->next ? "<Not set>\r\n" : "Set.", grn, nrm);
+  OLC_MODE(d) = OEDIT_EXTRADESC_MENU;
+}
+
+/*
+ * Ask for *which* apply to edit.
+ */
+void oedit_disp_prompt_apply_menu(struct descriptor_data *d)
+{
+  char apply_buf[MAX_STRING_LENGTH];
+  int counter;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < MAX_OBJ_AFFECT; counter++) {
+    if (OLC_OBJ(d)->affected[counter].modifier) {
+      sprinttype(OLC_OBJ(d)->affected[counter].location, apply_types, apply_buf, sizeof(apply_buf));
+      write_to_output(d, " %s%d%s) %+d to %s\r\n", grn, counter + 1, nrm,
+	      OLC_OBJ(d)->affected[counter].modifier, apply_buf);
+    } else {
+      write_to_output(d, " %s%d%s) None.\r\n", grn, counter + 1, nrm);
+    }
+  }
+  write_to_output(d, "\r\nEnter affection to modify (0 to quit) : ");
+  OLC_MODE(d) = OEDIT_PROMPT_APPLY;
+}
+
+/*
+ * Ask for liquid type.
+ */
+void oedit_liquid_type(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_LIQ_TYPES; counter++) {
+    write_to_output(d, " %s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
+	    drinks[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\n%sEnter drink type : ", nrm);
+  OLC_MODE(d) = OEDIT_VALUE_3;
+}
+
+/*
+ * The actual apply to set.
+ */
+void oedit_disp_apply_menu(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_APPLIES; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
+		apply_types[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\nEnter apply type (0 is no apply) : ");
+  OLC_MODE(d) = OEDIT_APPLY;
+}
+
+/*
+ * Weapon type.
+ */
+void oedit_disp_weapon_menu(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_ATTACK_TYPES; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
+		attack_hit_text[counter].singular,
+		!(++columns % 2) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\nEnter weapon type : ");
+}
+
+/*
+ * Spell type.
+ */
+void oedit_disp_spells_menu(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_SPELLS; counter++) {
+    write_to_output(d, "%s%2d%s) %s%-20.20s %s", grn, counter, nrm, yel,
+		spell_info[counter].name, !(++columns % 3) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\n%sEnter spell choice (-1 for none) : ", nrm);
+}
+
+/*
+ * Object value #1
+ */
+void oedit_disp_val1_menu(struct descriptor_data *d)
+{
+  OLC_MODE(d) = OEDIT_VALUE_1;
+  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+  case ITEM_LIGHT:
+    /*
+     * values 0 and 1 are unused.. jump to 2 
+     */
+    oedit_disp_val3_menu(d);
+    break;
+  case ITEM_SCROLL:
+  case ITEM_WAND:
+  case ITEM_STAFF:
+  case ITEM_POTION:
+    write_to_output(d, "Spell level : ");
+    break;
+  case ITEM_WEAPON:
+    /*
+     * This doesn't seem to be used if I remembe right.
+     */
+    write_to_output(d, "Modifier to Hitroll : ");
+    break;
+  case ITEM_ARMOR:
+    write_to_output(d, "Apply to AC : ");
+    break;
+  case ITEM_CONTAINER:
+    write_to_output(d, "Max weight to contain : ");
+    break;
+  case ITEM_DRINKCON:
+  case ITEM_FOUNTAIN:
+    write_to_output(d, "Max drink units : ");
+    break;
+  case ITEM_FOOD:
+    write_to_output(d, "Hours to fill stomach : ");
+    break;
+  case ITEM_MONEY:
+    write_to_output(d, "Number of gold coins : ");
+    break;
+  case ITEM_NOTE:
+    /*
+     * This is supposed to be language, but it's unused.
+     */
+    break;
+  default:
+    oedit_disp_menu(d);
+  }
+}
+
+/*
+ * Object value #2
+ */
+void oedit_disp_val2_menu(struct descriptor_data *d)
+{
+  OLC_MODE(d) = OEDIT_VALUE_2;
+  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+  case ITEM_SCROLL:
+  case ITEM_POTION:
+    oedit_disp_spells_menu(d);
+    break;
+  case ITEM_WAND:
+  case ITEM_STAFF:
+    write_to_output(d, "Max number of charges : ");
+    break;
+  case ITEM_WEAPON:
+    write_to_output(d, "Number of damage dice : ");
+    break;
+  case ITEM_FOOD:
+    /*
+     * Values 2 and 3 are unused, jump to 4...Odd.
+     */
+    oedit_disp_val4_menu(d);
+    break;
+  case ITEM_CONTAINER:
+    /*
+     * These are flags, needs a bit of special handling.
+     */
+    oedit_disp_container_flags_menu(d);
+    break;
+  case ITEM_DRINKCON:
+  case ITEM_FOUNTAIN:
+    write_to_output(d, "Initial drink units : ");
+    break;
+  default:
+    oedit_disp_menu(d);
+  }
+}
+
+/*
+ * Object value #3
+ */
+void oedit_disp_val3_menu(struct descriptor_data *d)
+{
+  OLC_MODE(d) = OEDIT_VALUE_3;
+  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+  case ITEM_LIGHT:
+    write_to_output(d, "Number of hours (0 = burnt, -1 is infinite) : ");
+    break;
+  case ITEM_SCROLL:
+  case ITEM_POTION:
+    oedit_disp_spells_menu(d);
+    break;
+  case ITEM_WAND:
+  case ITEM_STAFF:
+    write_to_output(d, "Number of charges remaining : ");
+    break;
+  case ITEM_WEAPON:
+    write_to_output(d, "Size of damage dice : ");
+    break;
+  case ITEM_CONTAINER:
+    write_to_output(d, "Vnum of key to open container (-1 for no key) : ");
+    break;
+  case ITEM_DRINKCON:
+  case ITEM_FOUNTAIN:
+    oedit_liquid_type(d);
+    break;
+  default:
+    oedit_disp_menu(d);
+  }
+}
+
+/*
+ * Object value #4
+ */
+void oedit_disp_val4_menu(struct descriptor_data *d)
+{
+  OLC_MODE(d) = OEDIT_VALUE_4;
+  switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+  case ITEM_SCROLL:
+  case ITEM_POTION:
+  case ITEM_WAND:
+  case ITEM_STAFF:
+    oedit_disp_spells_menu(d);
+    break;
+  case ITEM_WEAPON:
+    oedit_disp_weapon_menu(d);
+    break;
+  case ITEM_DRINKCON:
+  case ITEM_FOUNTAIN:
+  case ITEM_FOOD:
+    write_to_output(d, "Poisoned (0 = not poison) : ");
+    break;
+  default:
+    oedit_disp_menu(d);
+  }
+}
+
+/*
+ * Object type.
+ */
+void oedit_disp_type_menu(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_ITEM_TYPES; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
+		item_types[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\nEnter object type : ");
+}
+
+/*
+ * Object extra flags.
+ */
+void oedit_disp_extra_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_ITEM_FLAGS; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
+		extra_bits[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(GET_OBJ_EXTRA(OLC_OBJ(d)), extra_bits, bits, sizeof(bits));
+  write_to_output(d, "\r\nObject flags: %s%s%s\r\n"
+	  "Enter object extra flag (0 to quit) : ",
+	  cyn, bits, nrm);
+}
+
+/*
+ * Object perm flags.
+ */
+void oedit_disp_perm_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_AFF_FLAGS; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm, affected_bits[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(GET_OBJ_PERM(OLC_OBJ(d)), affected_bits, bits, sizeof(bits));
+  write_to_output(d, "\r\nObject permanent flags: %s%s%s\r\n"
+          "Enter object perm flag (0 to quit) : ", cyn, bits, nrm);
+}
+
+/*
+ * Object wear flags.
+ */
+void oedit_disp_wear_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  for (counter = 0; counter < NUM_ITEM_WEARS; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
+		wear_bits[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(GET_OBJ_WEAR(OLC_OBJ(d)), wear_bits, bits, sizeof(bits));
+  write_to_output(d, "\r\nWear flags: %s%s%s\r\n"
+	  "Enter wear flag, 0 to quit : ", cyn, bits, nrm);
+}
+
+/*
+ * Display main menu.
+ */
+void oedit_disp_menu(struct descriptor_data *d)
+{
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  struct obj_data *obj;
+
+  obj = OLC_OBJ(d);
+  get_char_colors(d->character);
+  clear_screen(d);
+
+  /*
+   * Build buffers for first part of menu.
+   */
+  sprinttype(GET_OBJ_TYPE(obj), item_types, buf1, sizeof(buf1));
+  sprintbit(GET_OBJ_EXTRA(obj), extra_bits, buf2, sizeof(buf2));
+
+  /*
+   * Build first half of menu.
+   */
+  write_to_output(d,
+	  "-- Item number : [%s%d%s]\r\n"
+	  "%s1%s) Namelist : %s%s\r\n"
+	  "%s2%s) S-Desc   : %s%s\r\n"
+	  "%s3%s) L-Desc   :-\r\n%s%s\r\n"
+	  "%s4%s) A-Desc   :-\r\n%s%s"
+	  "%s5%s) Type        : %s%s\r\n"
+	  "%s6%s) Extra flags : %s%s\r\n",
+
+	  cyn, OLC_NUM(d), nrm,
+	  grn, nrm, yel, (obj->name && *obj->name) ? obj->name : "undefined",
+	  grn, nrm, yel, (obj->short_description && *obj->short_description) ? obj->short_description : "undefined",
+	  grn, nrm, yel, (obj->description && *obj->description) ? obj->description : "undefined",
+	  grn, nrm, yel, (obj->action_description && *obj->action_description) ? obj->action_description : "<not set>\r\n",
+	  grn, nrm, cyn, buf1,
+	  grn, nrm, cyn, buf2
+	  );
+  /*
+   * Send first half.
+   */
+
+  /*
+   * Build second half of menu.
+   */
+  sprintbit(GET_OBJ_WEAR(obj), wear_bits, buf1, sizeof(buf1));
+  sprintbit(GET_OBJ_PERM(obj), affected_bits, buf2, sizeof(buf2));
+
+  write_to_output(d,
+	  "%s7%s) Wear flags  : %s%s\r\n"
+	  "%s8%s) Weight      : %s%d\r\n"
+	  "%s9%s) Cost        : %s%d\r\n"
+	  "%sA%s) Cost/Day    : %s%d\r\n"
+	  "%sB%s) Timer       : %s%d\r\n"
+	  "%sC%s) Values      : %s%d %d %d %d\r\n"
+	  "%sD%s) Applies menu\r\n"
+	  "%sE%s) Extra descriptions menu\r\n"
+          "%sM%s) Min Level   : %s%d\r\n"
+          "%sP%s) Perm Affects: %s%s\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ",
+
+	  grn, nrm, cyn, buf1,
+	  grn, nrm, cyn, GET_OBJ_WEIGHT(obj),
+	  grn, nrm, cyn, GET_OBJ_COST(obj),
+	  grn, nrm, cyn, GET_OBJ_RENT(obj),
+	  grn, nrm, cyn, GET_OBJ_TIMER(obj),
+	  grn, nrm, cyn, GET_OBJ_VAL(obj, 0),
+	  GET_OBJ_VAL(obj, 1),
+	  GET_OBJ_VAL(obj, 2),
+	  GET_OBJ_VAL(obj, 3),
+	  grn, nrm, grn, nrm,
+          grn, nrm, cyn, GET_OBJ_LEVEL(obj),
+          grn, nrm, cyn, buf2,
+          grn, nrm
+  );
+  OLC_MODE(d) = OEDIT_MAIN_MENU;
+}
+
+/***************************************************************************
+ main loop (of sorts).. basically interpreter throws all input to here
+ ***************************************************************************/
+
+void oedit_parse(struct descriptor_data *d, char *arg)
+{
+  int number, max_val, min_val;
+  char *oldtext = NULL;
+
+  switch (OLC_MODE(d)) {
+
+  case OEDIT_CONFIRM_SAVESTRING:
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      oedit_save_internally(d);
+      mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE,
+	"OLC: %s edits obj %d", GET_NAME(d->character), OLC_NUM(d));
+      if (CONFIG_OLC_SAVE) {
+	oedit_save_to_disk(real_zone_by_thing(OLC_NUM(d)));
+	write_to_output(d, "Object saved to disk.\r\n");
+      } else
+        write_to_output(d, "Object saved to memory.\r\n");
+      /* Fall through. */
+    case 'n':
+    case 'N':
+      cleanup_olc(d, CLEANUP_ALL);
+      return;
+    case 'a': /* abort quit */
+    case 'A':
+      oedit_disp_menu(d);
+      return;
+    default:
+      write_to_output(d, "Invalid choice!\r\n");
+      write_to_output(d, "Do you wish to save this object?\r\n");
+      return;
+    }
+
+  case OEDIT_MAIN_MENU:
+    /*
+     * Throw us out to whichever edit mode based on user input.
+     */
+    switch (*arg) {
+    case 'q':
+    case 'Q':
+      if (OLC_VAL(d)) {	/* Something has been modified. */
+        write_to_output(d, "Do you wish to save this object?\r\n");
+	OLC_MODE(d) = OEDIT_CONFIRM_SAVESTRING;
+      } else
+	cleanup_olc(d, CLEANUP_ALL);
+      return;
+    case '1':
+      write_to_output(d, "Enter namelist : ");
+      OLC_MODE(d) = OEDIT_EDIT_NAMELIST;
+      break;
+    case '2':
+      write_to_output(d, "Enter short desc : ");
+      OLC_MODE(d) = OEDIT_SHORTDESC;
+      break;
+    case '3':
+      write_to_output(d, "Enter long desc :-\r\n| ");
+      OLC_MODE(d) = OEDIT_LONGDESC;
+      break;
+    case '4':
+      OLC_MODE(d) = OEDIT_ACTDESC;
+      send_editor_help(d);
+      write_to_output(d, "Enter action description:\r\n\r\n");
+      if (OLC_OBJ(d)->action_description) {
+	write_to_output(d, "%s", OLC_OBJ(d)->action_description);
+	oldtext = strdup(OLC_OBJ(d)->action_description);
+      }
+      string_write(d, &OLC_OBJ(d)->action_description, MAX_MESSAGE_LENGTH, 0, oldtext);
+      OLC_VAL(d) = 1;
+      break;
+    case '5':
+      oedit_disp_type_menu(d);
+      OLC_MODE(d) = OEDIT_TYPE;
+      break;
+    case '6':
+      oedit_disp_extra_menu(d);
+      OLC_MODE(d) = OEDIT_EXTRAS;
+      break;
+    case '7':
+      oedit_disp_wear_menu(d);
+      OLC_MODE(d) = OEDIT_WEAR;
+      break;
+    case '8':
+      write_to_output(d, "Enter weight : ");
+      OLC_MODE(d) = OEDIT_WEIGHT;
+      break;
+    case '9':
+      write_to_output(d, "Enter cost : ");
+      OLC_MODE(d) = OEDIT_COST;
+      break;
+    case 'a':
+    case 'A':
+      write_to_output(d, "Enter cost per day : ");
+      OLC_MODE(d) = OEDIT_COSTPERDAY;
+      break;
+    case 'b':
+    case 'B':
+      write_to_output(d, "Enter timer : ");
+      OLC_MODE(d) = OEDIT_TIMER;
+      break;
+    case 'c':
+    case 'C':
+      /*
+       * Clear any old values  
+       */
+      GET_OBJ_VAL(OLC_OBJ(d), 0) = 0;
+      GET_OBJ_VAL(OLC_OBJ(d), 1) = 0;
+      GET_OBJ_VAL(OLC_OBJ(d), 2) = 0;
+      GET_OBJ_VAL(OLC_OBJ(d), 3) = 0;
+      OLC_VAL(d) = 1;
+      oedit_disp_val1_menu(d);
+      break;
+    case 'd':
+    case 'D':
+      oedit_disp_prompt_apply_menu(d);
+      break;
+    case 'e':
+    case 'E':
+      /*
+       * If extra descriptions don't exist.
+       */
+      if (OLC_OBJ(d)->ex_description == NULL) {
+	CREATE(OLC_OBJ(d)->ex_description, struct extra_descr_data, 1);
+	OLC_OBJ(d)->ex_description->next = NULL;
+      }
+      OLC_DESC(d) = OLC_OBJ(d)->ex_description;
+      oedit_disp_extradesc_menu(d);
+      break;
+    case 'm':
+    case 'M':
+      write_to_output(d, "Enter new minimum level: ");
+      OLC_MODE(d) = OEDIT_LEVEL;
+      break;
+    case 'p':
+    case 'P':
+      oedit_disp_perm_menu(d);
+      OLC_MODE(d) = OEDIT_PERM;
+      break;
+    default:
+      oedit_disp_menu(d);
+      break;
+    }
+    return;			/*
+				 * end of OEDIT_MAIN_MENU 
+				 */
+
+  case OEDIT_EDIT_NAMELIST:
+    if (!genolc_checkstring(d, arg))
+      break;
+    if (OLC_OBJ(d)->name)
+      free(OLC_OBJ(d)->name);
+    OLC_OBJ(d)->name = str_udup(arg);
+    break;
+
+  case OEDIT_SHORTDESC:
+    if (!genolc_checkstring(d, arg))
+      break;
+    if (OLC_OBJ(d)->short_description)
+      free(OLC_OBJ(d)->short_description);
+    OLC_OBJ(d)->short_description = str_udup(arg);
+    break;
+
+  case OEDIT_LONGDESC:
+    if (!genolc_checkstring(d, arg))
+      break;
+    if (OLC_OBJ(d)->description)
+      free(OLC_OBJ(d)->description);
+    OLC_OBJ(d)->description = str_udup(arg);
+    break;
+
+  case OEDIT_TYPE:
+    number = atoi(arg);
+    if ((number < 1) || (number >= NUM_ITEM_TYPES)) {
+      write_to_output(d, "Invalid choice, try again : ");
+      return;
+    } else
+      GET_OBJ_TYPE(OLC_OBJ(d)) = number;
+    /* what's the boundschecking worth if we don't do this ? -- Welcor */
+    GET_OBJ_VAL(OLC_OBJ(d), 0) = GET_OBJ_VAL(OLC_OBJ(d), 1) =
+      GET_OBJ_VAL(OLC_OBJ(d), 2) = GET_OBJ_VAL(OLC_OBJ(d), 3) = 0;
+    break;
+
+  case OEDIT_EXTRAS:
+    number = atoi(arg);
+    if ((number < 0) || (number > NUM_ITEM_FLAGS)) {
+      oedit_disp_extra_menu(d);
+      return;
+    } else if (number == 0)
+      break;
+    else {
+      TOGGLE_BIT(GET_OBJ_EXTRA(OLC_OBJ(d)), 1 << (number - 1));
+      oedit_disp_extra_menu(d);
+      return;
+    }
+
+  case OEDIT_WEAR:
+    number = atoi(arg);
+    if ((number < 0) || (number > NUM_ITEM_WEARS)) {
+      write_to_output(d, "That's not a valid choice!\r\n");
+      oedit_disp_wear_menu(d);
+      return;
+    } else if (number == 0)	/* Quit. */
+      break;
+    else {
+      TOGGLE_BIT(GET_OBJ_WEAR(OLC_OBJ(d)), 1 << (number - 1));
+      oedit_disp_wear_menu(d);
+      return;
+    }
+
+  case OEDIT_WEIGHT:
+    GET_OBJ_WEIGHT(OLC_OBJ(d)) = LIMIT(atoi(arg), 0, MAX_OBJ_WEIGHT);
+    break;
+
+  case OEDIT_COST:
+    GET_OBJ_COST(OLC_OBJ(d)) = LIMIT(atoi(arg), 0, MAX_OBJ_COST);
+    break;
+
+  case OEDIT_COSTPERDAY:
+    GET_OBJ_RENT(OLC_OBJ(d)) = LIMIT(atoi(arg), 0, MAX_OBJ_RENT);
+    break;
+
+  case OEDIT_TIMER:
+    GET_OBJ_TIMER(OLC_OBJ(d)) = LIMIT(atoi(arg), 0, MAX_OBJ_TIMER);
+    break;
+
+  case OEDIT_LEVEL:
+    GET_OBJ_LEVEL(OLC_OBJ(d)) = LIMIT(atoi(arg), 0, LVL_IMPL);
+    break;
+
+  case OEDIT_PERM:
+    if ((number = atoi(arg)) == 0)
+      break;
+    if (number > 0 && number <= NUM_AFF_FLAGS)
+      TOGGLE_BIT(GET_OBJ_PERM(OLC_OBJ(d)), 1 << (number - 1));
+    oedit_disp_perm_menu(d);
+    return;
+
+  case OEDIT_VALUE_1:
+    /*
+     * Lucky, I don't need to check any of these for out of range values.
+     * Hmm, I'm not so sure - Rv  
+     */
+    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+      case ITEM_WEAPON:
+	GET_OBJ_VAL(OLC_OBJ(d), 0) = MIN(MAX(atoi(arg), -50), 50);
+	break;
+      case ITEM_CONTAINER:
+        GET_OBJ_VAL(OLC_OBJ(d), 0) = LIMIT(atoi(arg), 0, MAX_CONTAINER_SIZE); 
+        break;
+      default:
+      GET_OBJ_VAL(OLC_OBJ(d), 0) = atoi(arg);
+    }
+    /*
+     * proceed to menu 2 
+     */
+    oedit_disp_val2_menu(d);
+    return;
+  case OEDIT_VALUE_2:
+    /*
+     * Here, I do need to check for out of range values.
+     */
+    number = atoi(arg);
+    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+    case ITEM_SCROLL:
+    case ITEM_POTION:
+      if (number == 0 || number == -1)
+	GET_OBJ_VAL(OLC_OBJ(d), 1) = -1;
+      else
+	GET_OBJ_VAL(OLC_OBJ(d), 1) = LIMIT(number, 1, NUM_SPELLS-1);
+      
+      oedit_disp_val3_menu(d);
+      break;
+    case ITEM_CONTAINER:
+      /*
+       * Needs some special handling since we are dealing with flag values
+       * here.
+       */
+      if (number < 0 || number > 4)
+	oedit_disp_container_flags_menu(d);
+      else if (number != 0) {
+        TOGGLE_BIT(GET_OBJ_VAL(OLC_OBJ(d), 1), 1 << (number - 1));
+        OLC_VAL(d) = 1;
+	oedit_disp_val2_menu(d);
+      } else
+	oedit_disp_val3_menu(d);
+      break;
+    case ITEM_WEAPON:
+      GET_OBJ_VAL(OLC_OBJ(d), 1) = LIMIT(number, 1, MAX_WEAPON_NDICE); 
+      oedit_disp_val3_menu(d);
+      break;
+
+    default:
+      GET_OBJ_VAL(OLC_OBJ(d), 1) = number;
+      oedit_disp_val3_menu(d);
+    }
+    return;
+
+  case OEDIT_VALUE_3:
+    number = atoi(arg);
+    /*
+     * Quick'n'easy error checking.
+     */
+    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+    case ITEM_SCROLL:
+    case ITEM_POTION:
+      if (number == 0 || number == -1) {
+	GET_OBJ_VAL(OLC_OBJ(d), 2) = -1;
+	oedit_disp_val4_menu(d);
+	return;
+      }
+      min_val = 1;
+      max_val = NUM_SPELLS - 1;
+      break;
+    case ITEM_WEAPON:
+      min_val = 1;
+      max_val = MAX_WEAPON_SDICE;
+      break;
+    case ITEM_WAND:
+    case ITEM_STAFF:
+      min_val = 0;
+      max_val = 20;
+      break;
+    case ITEM_DRINKCON:
+    case ITEM_FOUNTAIN:
+      min_val = 0;
+      max_val = NUM_LIQ_TYPES - 1;
+      break;
+    case ITEM_KEY:
+      min_val = 0;
+      max_val = 32099;
+      break;
+    default:
+      min_val = -32000;
+      max_val = 32000;
+    }
+    GET_OBJ_VAL(OLC_OBJ(d), 2) = LIMIT(number, min_val, max_val);
+    oedit_disp_val4_menu(d);
+    return;
+
+  case OEDIT_VALUE_4:
+    number = atoi(arg);
+    switch (GET_OBJ_TYPE(OLC_OBJ(d))) {
+    case ITEM_SCROLL:
+    case ITEM_POTION:
+      if (number == 0 || number == -1) {
+	GET_OBJ_VAL(OLC_OBJ(d), 3) = -1;
+        oedit_disp_menu(d);
+	return;
+      }
+      min_val = 1;
+      max_val = NUM_SPELLS - 1;
+      break;
+    case ITEM_WAND:
+    case ITEM_STAFF:
+      min_val = 1;
+      max_val = NUM_SPELLS - 1;
+      break;
+    case ITEM_WEAPON:
+      min_val = 0;
+      max_val = NUM_ATTACK_TYPES - 1;
+      break;
+    default:
+      min_val = -32000;
+      max_val = 32000;
+      break;
+    }
+    GET_OBJ_VAL(OLC_OBJ(d), 3) = LIMIT(number, min_val, max_val);
+    break;
+
+  case OEDIT_PROMPT_APPLY:
+    if ((number = atoi(arg)) == 0)
+      break;
+    else if (number < 0 || number > MAX_OBJ_AFFECT) {
+      oedit_disp_prompt_apply_menu(d);
+      return;
+    }
+    OLC_VAL(d) = number - 1;
+    OLC_MODE(d) = OEDIT_APPLY;
+    oedit_disp_apply_menu(d);
+    return;
+
+  case OEDIT_APPLY:
+    if ((number = atoi(arg)) == 0) {
+      OLC_OBJ(d)->affected[OLC_VAL(d)].location = 0;
+      OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = 0;
+      oedit_disp_prompt_apply_menu(d);
+    } else if (number < 0 || number >= NUM_APPLIES)
+      oedit_disp_apply_menu(d);
+    else {
+      int counter;
+
+      /* add in check here if already applied.. deny builders another */
+      if (GET_LEVEL(d->character) < LVL_IMPL) {
+        for (counter = 0; counter < MAX_OBJ_AFFECT; counter++) {
+          if (OLC_OBJ(d)->affected[counter].location == number) {
+            write_to_output(d, "Object already has that apply.");
+            return;
+          }
+        }
+      }
+
+      OLC_OBJ(d)->affected[OLC_VAL(d)].location = number;
+      write_to_output(d, "Modifier : ");
+      OLC_MODE(d) = OEDIT_APPLYMOD;
+    }
+    return;
+
+  case OEDIT_APPLYMOD:
+    OLC_OBJ(d)->affected[OLC_VAL(d)].modifier = atoi(arg);
+    oedit_disp_prompt_apply_menu(d);
+    return;
+
+  case OEDIT_EXTRADESC_KEY:
+    if (genolc_checkstring(d, arg)) {
+      if (OLC_DESC(d)->keyword)
+        free(OLC_DESC(d)->keyword);
+      OLC_DESC(d)->keyword = str_udup(arg);
+    }
+    oedit_disp_extradesc_menu(d);
+    return;
+
+  case OEDIT_EXTRADESC_MENU:
+    switch ((number = atoi(arg))) {
+    case 0:
+      if (!OLC_DESC(d)->keyword || !OLC_DESC(d)->description) {
+        struct extra_descr_data *temp;
+
+	if (OLC_DESC(d)->keyword)
+	  free(OLC_DESC(d)->keyword);
+	if (OLC_DESC(d)->description)
+	  free(OLC_DESC(d)->description);
+
+	/*
+	 * Clean up pointers  
+	 */
+	REMOVE_FROM_LIST(OLC_DESC(d), OLC_OBJ(d)->ex_description, next);
+	free(OLC_DESC(d));
+	OLC_DESC(d) = NULL;
+      }
+    break;
+
+    case 1:
+      OLC_MODE(d) = OEDIT_EXTRADESC_KEY;
+      write_to_output(d, "Enter keywords, separated by spaces :-\r\n| ");
+      return;
+
+    case 2:
+      OLC_MODE(d) = OEDIT_EXTRADESC_DESCRIPTION;
+      send_editor_help(d);
+      write_to_output(d, "Enter the extra description:\r\n\r\n");
+      if (OLC_DESC(d)->description) {
+	write_to_output(d, "%s", OLC_DESC(d)->description);
+	oldtext = strdup(OLC_DESC(d)->description);
+      }
+      string_write(d, &OLC_DESC(d)->description, MAX_MESSAGE_LENGTH, 0, oldtext);
+      OLC_VAL(d) = 1;
+      return;
+
+    case 3:
+      /*
+       * Only go to the next description if this one is finished.
+       */
+      if (OLC_DESC(d)->keyword && OLC_DESC(d)->description) {
+	struct extra_descr_data *new_extra;
+
+	if (OLC_DESC(d)->next)
+	  OLC_DESC(d) = OLC_DESC(d)->next;
+	else {	/* Make new extra description and attach at end. */
+	  CREATE(new_extra, struct extra_descr_data, 1);
+	  OLC_DESC(d)->next = new_extra;
+	  OLC_DESC(d) = OLC_DESC(d)->next;
+	}
+      }
+      /*
+       * No break - drop into default case.
+       */
+    default:
+      oedit_disp_extradesc_menu(d);
+      return;
+    }
+    break;
+  default:
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: Reached default case in oedit_parse()!");
+    write_to_output(d, "Oops...\r\n");
+    break;
+  }
+
+  /*
+   * If we get here, we have changed something.  
+   */
+  OLC_VAL(d) = 1;
+  oedit_disp_menu(d);
+}
+
+void oedit_string_cleanup(struct descriptor_data *d, int terminator)
+{
+  switch (OLC_MODE(d)) {
+  case OEDIT_ACTDESC:
+    oedit_disp_menu(d);
+    break;
+  case OEDIT_EXTRADESC_DESCRIPTION:
+    oedit_disp_extradesc_menu(d);
+    break;
+  }
+}
diff -BENbdpru circle-3.1/src/olc.c circle3.1_oasis206/src/olc.c
--- circle-3.1/src/olc.c	2002-02-01 03:19:40.000000000 +0100
+++ circle3.1_oasis206/src/olc.c	2003-07-26 10:19:22.000000000 +0200
@@ -286,7 +286,7 @@ void olc_string(char **string, size_t ma
       if (*string != NULL)
 	free(*string);
       *string = strdup(arg);
-      send_to_char(olc_ch, "%s", OK);
+      send_to_char(olc_ch, "%s", CONFIG_OK);
     }
   }
 }
diff -BENbdpru circle-3.1/src/redit.c circle3.1_oasis206/src/redit.c
--- circle-3.1/src/redit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/redit.c	2003-10-07 11:07:22.000000000 +0200
@@ -0,0 +1,867 @@
+/************************************************************************
+ *  OasisOLC - Rooms / redit.c					v2.0	*
+ *  Original author: Levork						*
+ *  Copyright 1996 Harvey Gilpin					*
+ *  Copyright 1997-2001 George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+
+#include "structs.h"
+#include "utils.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "db.h"
+#include "boards.h"
+#include "genolc.h"
+#include "genwld.h"
+#include "genzon.h"
+#include "oasis.h"
+#include "improved-edit.h"
+
+/*------------------------------------------------------------------------*/
+
+/*
+ * External data structures.
+ */
+extern struct room_data *world;
+extern struct obj_data *obj_proto;
+extern struct char_data *mob_proto;
+extern const char *room_bits[];
+extern const char *sector_types[];
+extern const char *exit_bits[];
+extern struct zone_data *zone_table;
+extern struct descriptor_data *descriptor_list;
+
+/*------------------------------------------------------------------------*/
+
+
+/*------------------------------------------------------------------------*\
+  Utils and exported functions.
+\*------------------------------------------------------------------------*/
+
+ACMD(do_oasis_redit)
+{
+  char *buf3;
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  int number = NOWHERE, save = 0, real_num;
+  struct descriptor_data *d;
+  
+  /* Parse any arguments. */
+  buf3 = two_arguments(argument, buf1, buf2);
+  
+  if (!*buf1)
+    number = GET_ROOM_VNUM(IN_ROOM(ch));
+  else if (!isdigit(*buf1)) {
+    if (str_cmp("save", buf1) != 0) {
+      send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+      return;
+    }
+    
+    save = TRUE;
+      
+    if (is_number(buf2))
+      number = atoi(buf2);
+    else if (GET_OLC_ZONE(ch) >= 0) {
+      zone_rnum zlok;
+        
+      if ((zlok = real_zone(GET_OLC_ZONE(ch))) == NOWHERE)
+        number = NOWHERE;
+      else
+        number = genolc_zone_bottom(zlok);
+    }
+      
+    if (number == NOWHERE) {
+      send_to_char(ch, "Save which zone?\r\n");
+      return;
+    }
+  }
+  
+  /*
+   * If a numeric argument was given (like a room number), get it.
+   */
+  if (number == NOWHERE)
+    number = atoi(buf1);
+  
+  /* Check to make sure the room isn't already being edited. */
+  for (d = descriptor_list; d; d = d->next) {
+    if (STATE(d) == CON_REDIT) {
+      if (d->olc && OLC_NUM(d) == number) {
+        send_to_char(ch, "That room is currently being edited by %s.\r\n", 
+          PERS(d->character, ch));
+        return;
+      }
+    }
+  }
+  
+  /* Retrieve the player's descriptor. */
+  d = ch->desc;
+  
+  /* Give the descriptor an OLC structure. */
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_oasis_redit: Player already had olc structure.");
+    free(d->olc);
+  }
+  
+  /* Create the OLC structure. */
+  CREATE(d->olc, struct oasis_olc_data, 1);
+  
+  /* Find the zone. */
+  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == NOWHERE) {
+    send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /* Make sure the builder is allowed to modify this zone. */
+  if (!can_edit_zone(ch, OLC_ZNUM(d))) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    mudlog(BRF, LVL_IMPL, TRUE, "OLC: %s tried to edit zone %d allowed zone %d",
+               GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+    
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  if (save) {
+    send_to_char(ch, "Saving all rooms in zone %d.\r\n", zone_table[OLC_ZNUM(d)].number);
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE, "OLC: %s saves room info for zone %d.", GET_NAME(ch), zone_table[OLC_ZNUM(d)].number);
+    
+    /* Save the rooms. */
+    save_rooms(OLC_ZNUM(d));
+    
+    /* Free the olc data from the descriptor. */
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  OLC_NUM(d) = number;
+  
+  if ((real_num = real_room(number)) >= 0)
+    redit_setup_existing(d, real_num);
+  else
+    redit_setup_new(d);
+  
+  STATE(d) = CON_REDIT;
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  
+  mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s starts editing zone %d allowed zone %d",
+    GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+}
+
+void redit_setup_new(struct descriptor_data *d)
+{
+  CREATE(OLC_ROOM(d), struct room_data, 1);
+
+  OLC_ROOM(d)->name = strdup("An unfinished room");
+  OLC_ROOM(d)->description = strdup("You are in an unfinished room.\r\n");
+  OLC_ROOM(d)->number = NOWHERE;
+  redit_disp_menu(d);
+  OLC_VAL(d) = 0;
+}
+
+/*------------------------------------------------------------------------*/
+
+void redit_setup_existing(struct descriptor_data *d, int real_num)
+{
+  struct room_data *room;
+  int counter;
+
+  /*
+   * Build a copy of the room for editing.
+   */
+  CREATE(room, struct room_data, 1);
+
+  *room = world[real_num];
+  /*
+   * Allocate space for all strings.
+   */
+  room->name = str_udup(world[real_num].name);
+  room->description = str_udup(world[real_num].description);
+
+  /*
+   * Exits - We allocate only if necessary.
+   */
+  for (counter = 0; counter < NUM_OF_DIRS; counter++) {
+    if (world[real_num].dir_option[counter]) {
+      CREATE(room->dir_option[counter], struct room_direction_data, 1);
+
+      /*
+       * Copy the numbers over.
+       */
+      *room->dir_option[counter] = *world[real_num].dir_option[counter];
+      /*
+       * Allocate the strings.
+       */
+      if (world[real_num].dir_option[counter]->general_description)
+        room->dir_option[counter]->general_description = strdup(world[real_num].dir_option[counter]->general_description);
+      if (world[real_num].dir_option[counter]->keyword)
+        room->dir_option[counter]->keyword = strdup(world[real_num].dir_option[counter]->keyword);
+    }
+  }
+
+  /*
+   * Extra descriptions, if necessary.
+   */
+  if (world[real_num].ex_description) {
+    struct extra_descr_data *tdesc, *temp, *temp2;
+    CREATE(temp, struct extra_descr_data, 1);
+
+    room->ex_description = temp;
+    for (tdesc = world[real_num].ex_description; tdesc; tdesc = tdesc->next) {
+      temp->keyword = strdup(tdesc->keyword);
+      temp->description = strdup(tdesc->description);
+      if (tdesc->next) {
+	CREATE(temp2, struct extra_descr_data, 1);
+	temp->next = temp2;
+	temp = temp2;
+      } else
+	temp->next = NULL;
+    }
+  }
+  /*
+   * Attach copy of room to player's descriptor.
+   */
+  OLC_ROOM(d) = room;
+  OLC_VAL(d) = 0;
+  redit_disp_menu(d);
+}
+
+/*------------------------------------------------------------------------*/
+
+void redit_save_internally(struct descriptor_data *d)
+{
+  int j, room_num, new_room = FALSE;
+  struct descriptor_data *dsc;
+
+  if (OLC_ROOM(d)->number == NOWHERE) {
+    new_room = TRUE;
+    OLC_ROOM(d)->number = OLC_NUM(d);
+  }
+  /* FIXME: Why is this not set elsewhere? */
+  OLC_ROOM(d)->zone = OLC_ZNUM(d);
+
+  if ((room_num = add_room(OLC_ROOM(d))) == NOWHERE) {
+    write_to_output(d, "Something went wrong...\r\n");
+    log("SYSERR: redit_save_internally: Something failed! (%d)", room_num);
+    return;
+  }
+
+  /* Don't adjust numbers on a room update. */
+  if (!new_room)
+    return;
+
+  /* Idea contributed by C.Raehl 4/27/99 */
+  for (dsc = descriptor_list; dsc; dsc = dsc->next) {
+    if (dsc == d)
+      continue;
+
+    if (STATE(dsc) == CON_ZEDIT) {
+      for (j = 0; OLC_ZONE(dsc)->cmd[j].command != 'S'; j++)
+        switch (OLC_ZONE(dsc)->cmd[j].command) {
+          case 'O':
+          case 'M':
+            OLC_ZONE(dsc)->cmd[j].arg3 += (OLC_ZONE(dsc)->cmd[j].arg3 >= room_num);
+            break;
+          case 'D':
+            OLC_ZONE(dsc)->cmd[j].arg2 += (OLC_ZONE(dsc)->cmd[j].arg2 >= room_num);
+            /* Fall through */
+          case 'R':
+            OLC_ZONE(dsc)->cmd[j].arg1 += (OLC_ZONE(dsc)->cmd[j].arg1 >= room_num);
+            break;
+          }
+    } else if (STATE(dsc) == CON_REDIT) {
+      for (j = 0; j < NUM_OF_DIRS; j++)
+        if (OLC_ROOM(dsc)->dir_option[j])
+          if (OLC_ROOM(dsc)->dir_option[j]->to_room >= room_num)
+            OLC_ROOM(dsc)->dir_option[j]->to_room++;
+    }
+  }
+}
+
+/*------------------------------------------------------------------------*/
+
+void redit_save_to_disk(zone_vnum zone_num)
+{
+  save_rooms(zone_num);		/* :) */
+}
+
+/*------------------------------------------------------------------------*/
+
+void free_room(struct room_data *room)
+{
+  /* Free the strings (Mythran). */
+  free_strings(room, OASIS_WLD);
+  
+  /* Free the room. */
+  free(room);	/* XXX ? */
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+/*
+ * For extra descriptions.
+ */
+void redit_disp_extradesc_menu(struct descriptor_data *d)
+{
+  struct extra_descr_data *extra_desc = OLC_DESC(d);
+
+  clear_screen(d);
+  write_to_output(d,
+	  "%s1%s) Keyword: %s%s\r\n"
+	  "%s2%s) Description:\r\n%s%s\r\n"
+	  "%s3%s) Goto next description: ",
+
+	  grn, nrm, yel, extra_desc->keyword ? extra_desc->keyword : "<NONE>",
+	  grn, nrm, yel, extra_desc->description ? extra_desc->description : "<NONE>",
+	  grn, nrm
+	  );
+
+  write_to_output(d, !extra_desc->next ? "<NOT SET>\r\n" : "Set.\r\n");
+  write_to_output(d, "Enter choice (0 to quit) : ");
+  OLC_MODE(d) = REDIT_EXTRADESC_MENU;
+}
+
+/*
+ * For exits.
+ */
+void redit_disp_exit_menu(struct descriptor_data *d)
+{
+  char door_buf[24];
+  /*
+   * if exit doesn't exist, alloc/create it 
+   */
+  if (OLC_EXIT(d) == NULL)
+    CREATE(OLC_EXIT(d), struct room_direction_data, 1);
+
+  /*
+   * Weird door handling! 
+   */
+  if (IS_SET(OLC_EXIT(d)->exit_info, EX_ISDOOR)) {
+    if (IS_SET(OLC_EXIT(d)->exit_info, EX_PICKPROOF))
+      strncpy(door_buf, "Pickproof", sizeof(door_buf)-1);
+    else
+      strncpy(door_buf, "Is a door", sizeof(door_buf)-1);
+  } else
+    strncpy(door_buf, "No door", sizeof(door_buf)-1);
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  write_to_output(d,
+	  "%s1%s) Exit to     : %s%d\r\n"
+	  "%s2%s) Description :-\r\n%s%s\r\n"
+	  "%s3%s) Door name   : %s%s\r\n"
+	  "%s4%s) Key         : %s%d\r\n"
+	  "%s5%s) Door flags  : %s%s\r\n"
+	  "%s6%s) Purge exit.\r\n"
+	  "Enter choice, 0 to quit : ",
+
+	  grn, nrm, cyn, OLC_EXIT(d)->to_room != NOWHERE ? world[OLC_EXIT(d)->to_room].number : -1,
+	  grn, nrm, yel, OLC_EXIT(d)->general_description ? OLC_EXIT(d)->general_description : "<NONE>",
+	  grn, nrm, yel, OLC_EXIT(d)->keyword ? OLC_EXIT(d)->keyword : "<NONE>",
+	  grn, nrm, cyn, OLC_EXIT(d)->key != NOTHING ? OLC_EXIT(d)->key : -1,
+	  grn, nrm, cyn, door_buf, grn, nrm
+	  );
+
+  OLC_MODE(d) = REDIT_EXIT_MENU;
+}
+
+/*
+ * For exit flags.
+ */
+void redit_disp_exit_flag_menu(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  write_to_output(d, "%s0%s) No door\r\n"
+	  "%s1%s) Closeable door\r\n"
+	  "%s2%s) Pickproof\r\n"
+	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
+}
+
+/*
+ * For room flags.
+ */
+void redit_disp_flag_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int counter, columns = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  for (counter = 0; counter < NUM_ROOM_FLAGS; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter + 1, nrm,
+		room_bits[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  sprintbit(OLC_ROOM(d)->room_flags, room_bits, bits, sizeof(bits));
+  write_to_output(d, "\r\nRoom flags: %s%s%s\r\n"
+	  "Enter room flags, 0 to quit : ", cyn, bits, nrm);
+  OLC_MODE(d) = REDIT_FLAGS;
+}
+
+/*
+ * For sector type.
+ */
+void redit_disp_sector_menu(struct descriptor_data *d)
+{
+  int counter, columns = 0;
+
+  clear_screen(d);
+  for (counter = 0; counter < NUM_ROOM_SECTORS; counter++) {
+    write_to_output(d, "%s%2d%s) %-20.20s %s", grn, counter, nrm,
+		sector_types[counter], !(++columns % 2) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\nEnter sector type : ");
+  OLC_MODE(d) = REDIT_SECTOR;
+}
+
+/*
+ * The main menu.
+ */
+void redit_disp_menu(struct descriptor_data *d)
+{
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  struct room_data *room;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  room = OLC_ROOM(d);
+
+  sprintbit((long)room->room_flags, room_bits, buf1, sizeof(buf1));
+  sprinttype(room->sector_type, sector_types, buf2, sizeof(buf2));
+  write_to_output(d,
+	  "-- Room number : [%s%d%s]  	Room zone: [%s%d%s]\r\n"
+	  "%s1%s) Name        : %s%s\r\n"
+	  "%s2%s) Description :\r\n%s%s"
+	  "%s3%s) Room flags  : %s%s\r\n"
+	  "%s4%s) Sector type : %s%s\r\n"
+	  "%s5%s) Exit north  : %s%d\r\n"
+	  "%s6%s) Exit east   : %s%d\r\n"
+	  "%s7%s) Exit south  : %s%d\r\n"
+	  "%s8%s) Exit west   : %s%d\r\n"
+	  "%s9%s) Exit up     : %s%d\r\n"
+	  "%sA%s) Exit down   : %s%d\r\n"
+	  "%sB%s) Extra descriptions menu\r\n"
+	  "%sD%s) Delete Room\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ",
+
+	  cyn, OLC_NUM(d), nrm,
+	  cyn, zone_table[OLC_ZNUM(d)].number, nrm,
+	  grn, nrm, yel, room->name,
+	  grn, nrm, yel, room->description,
+	  grn, nrm, cyn, buf1,
+	  grn, nrm, cyn, buf2,
+	  grn, nrm, cyn,
+	  room->dir_option[NORTH] && room->dir_option[NORTH]->to_room != NOWHERE ?
+	  world[room->dir_option[NORTH]->to_room].number : -1,
+	  grn, nrm, cyn,
+	  room->dir_option[EAST] && room->dir_option[EAST]->to_room != NOWHERE ?
+	  world[room->dir_option[EAST]->to_room].number : -1,
+	  grn, nrm, cyn,
+	  room->dir_option[SOUTH] && room->dir_option[SOUTH]->to_room != NOWHERE ?
+	  world[room->dir_option[SOUTH]->to_room].number : -1,
+	  grn, nrm, cyn,
+	  room->dir_option[WEST] && room->dir_option[WEST]->to_room != NOWHERE ?
+	  world[room->dir_option[WEST]->to_room].number : -1,
+	  grn, nrm, cyn,
+	  room->dir_option[UP] && room->dir_option[UP]->to_room != NOWHERE ? 
+	  world[room->dir_option[UP]->to_room].number : -1,
+	  grn, nrm, cyn,
+	  room->dir_option[DOWN] && room->dir_option[DOWN]->to_room != NOWHERE ?
+	  world[room->dir_option[DOWN]->to_room].number : -1,
+	  grn, nrm,
+          grn, nrm,
+          grn, nrm
+	  );
+
+  OLC_MODE(d) = REDIT_MAIN_MENU;
+}
+
+/**************************************************************************
+  The main loop
+ **************************************************************************/
+
+void redit_parse(struct descriptor_data *d, char *arg)
+{
+  int number;
+  char *oldtext = NULL;
+
+  switch (OLC_MODE(d)) {
+  case REDIT_CONFIRM_SAVESTRING:
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      redit_save_internally(d);
+      mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE,
+	"OLC: %s edits room %d.", GET_NAME(d->character), OLC_NUM(d));
+      if (CONFIG_OLC_SAVE) {
+	redit_save_to_disk(real_zone_by_thing(OLC_NUM(d)));
+	write_to_output(d, "Room saved to disk.\r\n");
+      } else
+        write_to_output(d, "Room saved to memory.\r\n");
+      /*
+       * Do NOT free strings! Just the room structure. 
+       */
+      cleanup_olc(d, CLEANUP_STRUCTS);
+      break;
+    case 'n':
+    case 'N':
+      /*
+       * Free everything up, including strings, etc.
+       */
+      cleanup_olc(d, CLEANUP_ALL);
+      break;
+    default:
+      write_to_output(d, "Invalid choice!\r\nDo you wish to save this room ? : ");
+      break;
+    }
+    return;
+
+  case REDIT_MAIN_MENU:
+    switch (*arg) {
+    case 'q':
+    case 'Q':
+      if (OLC_VAL(d)) { /* Something has been modified. */
+        write_to_output(d, "Do you wish to save this room ? : ");
+        OLC_MODE(d) = REDIT_CONFIRM_SAVESTRING;
+      } else
+        cleanup_olc(d, CLEANUP_ALL);
+      return;
+    case '1':
+      write_to_output(d, "Enter room name:-\r\n] ");
+      OLC_MODE(d) = REDIT_NAME;
+      break;
+    case '2':
+      OLC_MODE(d) = REDIT_DESC;
+      clear_screen(d);
+      send_editor_help(d);
+      write_to_output(d, "Enter room description:\r\n\r\n");
+
+      if (OLC_ROOM(d)->description) {
+	write_to_output(d, "%s", OLC_ROOM(d)->description);
+	oldtext = strdup(OLC_ROOM(d)->description);
+      }
+      string_write(d, &OLC_ROOM(d)->description, MAX_ROOM_DESC, 0, oldtext);
+      OLC_VAL(d) = 1;
+      break;
+    case '3':
+      redit_disp_flag_menu(d);
+      break;
+    case '4':
+      redit_disp_sector_menu(d);
+      break;
+    case '5':
+      OLC_VAL(d) = NORTH;
+      redit_disp_exit_menu(d);
+      break;
+    case '6':
+      OLC_VAL(d) = EAST;
+      redit_disp_exit_menu(d);
+      break;
+    case '7':
+      OLC_VAL(d) = SOUTH;
+      redit_disp_exit_menu(d);
+      break;
+    case '8':
+      OLC_VAL(d) = WEST;
+      redit_disp_exit_menu(d);
+      break;
+    case '9':
+      OLC_VAL(d) = UP;
+      redit_disp_exit_menu(d);
+      break;
+    case 'a':
+    case 'A':
+      OLC_VAL(d) = DOWN;
+      redit_disp_exit_menu(d);
+      break;
+    case 'b':
+    case 'B':
+      /*
+       * If the extra description doesn't exist.
+       */
+      if (!OLC_ROOM(d)->ex_description)
+	CREATE(OLC_ROOM(d)->ex_description, struct extra_descr_data, 1);
+      OLC_DESC(d) = OLC_ROOM(d)->ex_description;
+      redit_disp_extradesc_menu(d);
+      break;
+    case 'd':
+    case 'D':
+      /* Delete the room, prompt first. */
+      write_to_output(d, "Are you sure you want to delete this room? ");
+      OLC_MODE(d) = REDIT_DELETE;
+      break;
+      
+    default:
+      write_to_output(d, "Invalid choice!");
+      redit_disp_menu(d);
+      break;
+    }
+    return;
+    
+  case REDIT_NAME:
+    if (!genolc_checkstring(d, arg))
+      break;
+    if (OLC_ROOM(d)->name)
+      free(OLC_ROOM(d)->name);
+    arg[MAX_ROOM_NAME - 1] = '\0';
+    OLC_ROOM(d)->name = str_udup(arg);
+    break;
+
+  case REDIT_DESC:
+    /*
+     * We will NEVER get here, we hope.
+     */
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: Reached REDIT_DESC case in parse_redit().");
+    write_to_output(d, "Oops, in REDIT_DESC.\r\n");
+    break;
+
+  case REDIT_FLAGS:
+    number = atoi(arg);
+    if (number < 0 || number > NUM_ROOM_FLAGS) {
+      write_to_output(d, "That is not a valid choice!\r\n");
+      redit_disp_flag_menu(d);
+    } else if (number == 0)
+      break;
+    else {
+      /*
+       * Toggle the bit.
+       */
+      TOGGLE_BIT(OLC_ROOM(d)->room_flags, 1 << (number - 1));
+      redit_disp_flag_menu(d);
+    }
+    return;
+
+  case REDIT_SECTOR:
+    number = atoi(arg);
+    if (number < 0 || number >= NUM_ROOM_SECTORS) {
+      write_to_output(d, "Invalid choice!");
+      redit_disp_sector_menu(d);
+      return;
+    }
+    OLC_ROOM(d)->sector_type = number;
+    break;
+
+  case REDIT_EXIT_MENU:
+    switch (*arg) {
+    case '0':
+      break;
+    case '1':
+      OLC_MODE(d) = REDIT_EXIT_NUMBER;
+      write_to_output(d, "Exit to room number : ");
+      return;
+    case '2':
+      OLC_MODE(d) = REDIT_EXIT_DESCRIPTION;
+      send_editor_help(d);
+      write_to_output(d, "Enter exit description:\r\n\r\n");
+      if (OLC_EXIT(d)->general_description) {
+	write_to_output(d, "%s", OLC_EXIT(d)->general_description);
+	oldtext = strdup(OLC_EXIT(d)->general_description);
+      }
+      string_write(d, &OLC_EXIT(d)->general_description, MAX_EXIT_DESC, 0, oldtext);
+      return;
+    case '3':
+      OLC_MODE(d) = REDIT_EXIT_KEYWORD;
+      write_to_output(d, "Enter keywords : ");
+      return;
+    case '4':
+      OLC_MODE(d) = REDIT_EXIT_KEY;
+      write_to_output(d, "Enter key number : ");
+      return;
+    case '5':
+      OLC_MODE(d) = REDIT_EXIT_DOORFLAGS;
+      redit_disp_exit_flag_menu(d);
+      return;
+    case '6':
+      /*
+       * Delete an exit.
+       */
+      if (OLC_EXIT(d)->keyword)
+	free(OLC_EXIT(d)->keyword);
+      if (OLC_EXIT(d)->general_description)
+	free(OLC_EXIT(d)->general_description);
+      if (OLC_EXIT(d))
+	free(OLC_EXIT(d));
+      OLC_EXIT(d) = NULL;
+      break;
+    default:
+      write_to_output(d, "Try again : ");
+      return;
+    }
+    break;
+
+  case REDIT_EXIT_NUMBER:
+    if ((number = atoi(arg)) != -1)
+      if ((number = real_room(number)) == NOWHERE) {
+	write_to_output(d, "That room does not exist, try again : ");
+	return;
+      }
+    OLC_EXIT(d)->to_room = number;
+    redit_disp_exit_menu(d);
+    return;
+
+  case REDIT_EXIT_DESCRIPTION:
+    /*
+     * We should NEVER get here, hopefully.
+     */
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: Reached REDIT_EXIT_DESC case in parse_redit");
+    write_to_output(d, "Oops, in REDIT_EXIT_DESCRIPTION.\r\n");
+    break;
+
+  case REDIT_EXIT_KEYWORD:
+    if (OLC_EXIT(d)->keyword)
+      free(OLC_EXIT(d)->keyword);
+    OLC_EXIT(d)->keyword = str_udup(arg);
+    redit_disp_exit_menu(d);
+    return;
+
+  case REDIT_EXIT_KEY:
+    number = atoi(arg);
+    if (number < 0)
+      OLC_EXIT(d)->key = NOTHING;
+    else
+      OLC_EXIT(d)->key = number;
+    redit_disp_exit_menu(d);
+    return;
+
+  case REDIT_EXIT_DOORFLAGS:
+    number = atoi(arg);
+    if (number < 0 || number > 2) {
+      write_to_output(d, "That's not a valid choice!\r\n");
+      redit_disp_exit_flag_menu(d);
+    } else {
+      /*
+       * Doors are a bit idiotic, don't you think? :) -- I agree. -gg
+       */
+      OLC_EXIT(d)->exit_info = (number == 0 ? 0 :
+				(number == 1 ? EX_ISDOOR :
+				(number == 2 ? EX_ISDOOR | EX_PICKPROOF : 0)));
+      /*
+       * Jump back to the menu system.
+       */
+      redit_disp_exit_menu(d);
+    }
+    return;
+
+  case REDIT_EXTRADESC_KEY:
+    if (genolc_checkstring(d, arg)) {
+      if (OLC_DESC(d)->keyword)
+        free(OLC_DESC(d)->keyword);
+      OLC_DESC(d)->keyword = str_udup(arg);
+    }
+    redit_disp_extradesc_menu(d);
+    return;
+
+  case REDIT_EXTRADESC_MENU:
+    switch ((number = atoi(arg))) {
+    case 0:
+      /*
+       * If something got left out, delete the extra description
+       * when backing out to the menu.
+       */
+      if (OLC_DESC(d)->keyword == NULL || OLC_DESC(d)->description == NULL) {
+	struct extra_descr_data *temp;
+	if (OLC_DESC(d)->keyword)
+	  free(OLC_DESC(d)->keyword);
+	if (OLC_DESC(d)->description)
+	  free(OLC_DESC(d)->description);
+
+	/*
+	 * Clean up pointers.
+	 */
+	REMOVE_FROM_LIST(OLC_DESC(d), OLC_ROOM(d)->ex_description, next);
+	free(OLC_DESC(d));
+      }
+      break;
+    case 1:
+      OLC_MODE(d) = REDIT_EXTRADESC_KEY;
+      write_to_output(d, "Enter keywords, separated by spaces : ");
+      return;
+    case 2:
+      OLC_MODE(d) = REDIT_EXTRADESC_DESCRIPTION;
+      send_editor_help(d);
+      write_to_output(d, "Enter extra description:\r\n\r\n");
+      if (OLC_DESC(d)->description) {
+	write_to_output(d, "%s", OLC_DESC(d)->description);
+	oldtext = strdup(OLC_DESC(d)->description);
+      }
+      string_write(d, &OLC_DESC(d)->description, MAX_MESSAGE_LENGTH, 0, oldtext);
+      return;
+    case 3:
+      if (OLC_DESC(d)->keyword == NULL || OLC_DESC(d)->description == NULL) {
+	write_to_output(d, "You can't edit the next extra description without completing this one.\r\n");
+	redit_disp_extradesc_menu(d);
+      } else {
+	struct extra_descr_data *new_extra;
+
+	if (OLC_DESC(d)->next)
+	  OLC_DESC(d) = OLC_DESC(d)->next;
+	else {
+	  /*
+	   * Make new extra description and attach at end.
+	   */
+	  CREATE(new_extra, struct extra_descr_data, 1);
+	  OLC_DESC(d)->next = new_extra;
+	  OLC_DESC(d) = new_extra;
+	}
+	redit_disp_extradesc_menu(d);
+      }
+      return;
+    }
+    break;
+  
+  case REDIT_DELETE:
+    if (*arg == 'y' || *arg == 'Y') {
+      if (delete_room(real_room(OLC_ROOM(d)->number)))
+        write_to_output(d, "Room deleted.\r\n");
+      else
+        write_to_output(d, "Couldn't delete the room!.\r\n");
+      
+      cleanup_olc(d, CLEANUP_ALL);
+      return;
+    } else if (*arg == 'n' || *arg == 'N') {
+      redit_disp_menu(d);
+      OLC_MODE(d) = REDIT_MAIN_MENU;      
+      return;
+    } else
+      write_to_output(d, "Please answer 'Y' or 'N': ");
+    
+    break;  
+  
+  default:
+    /*
+     * We should never get here.
+     */
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: Reached default case in parse_redit");
+    break;
+  }
+  /*
+   * If we get this far, something has been changed.
+   */
+  OLC_VAL(d) = 1;
+  redit_disp_menu(d);
+}
+
+void redit_string_cleanup(struct descriptor_data *d, int terminator)
+{
+  switch (OLC_MODE(d)) {
+  case REDIT_DESC:
+    redit_disp_menu(d);
+    break;
+  case REDIT_EXIT_DESCRIPTION:
+    redit_disp_exit_menu(d);
+    break;
+  case REDIT_EXTRADESC_DESCRIPTION:
+    redit_disp_extradesc_menu(d);
+    break;
+  }
+}
diff -BENbdpru circle-3.1/src/sedit.c circle3.1_oasis206/src/sedit.c
--- circle-3.1/src/sedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/sedit.c	2003-10-07 11:09:12.000000000 +0200
@@ -0,0 +1,846 @@
+/************************************************************************
+ * OasisOLC - Shops / sedit.c					v2.0	*
+ * Copyright 1996 Harvey Gilpin						*
+ * Copyright 1997-2001 George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "db.h"
+#include "shop.h"
+#include "genolc.h"
+#include "genshp.h"
+#include "genzon.h"
+#include "oasis.h"
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * External variable declarations.
+ */
+extern struct shop_data *shop_index;
+extern struct char_data *mob_proto;
+extern struct obj_data *obj_proto;
+extern struct room_data *world;
+extern struct zone_data *zone_table;
+extern struct index_data *mob_index;
+extern struct index_data *obj_index;
+extern const char *trade_letters[];
+extern const char *shop_bits[];
+extern const char *item_types[];
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * External functions.
+ */
+SPECIAL(shop_keeper);
+
+/*
+ * Should check more things.
+ */
+void sedit_save_internally(struct descriptor_data *d)
+{
+  OLC_SHOP(d)->vnum = OLC_NUM(d);
+  add_shop(OLC_SHOP(d));
+}
+
+void sedit_save_to_disk(int num)
+{
+  save_shops(num);
+}
+
+/*-------------------------------------------------------------------*\
+  utility functions 
+\*-------------------------------------------------------------------*/
+
+ACMD(do_oasis_sedit)
+{
+  int number = NOWHERE, save = 0;
+  shop_rnum real_num;
+  struct descriptor_data *d;
+  char *buf3;
+  char buf1[MAX_INPUT_LENGTH];
+  char buf2[MAX_INPUT_LENGTH];
+  
+  /****************************************************************************/
+  /** Parse any arguments.                                                   **/
+  /****************************************************************************/
+  buf3 = two_arguments(argument, buf1, buf2);
+  
+  if (!*buf1) {
+    send_to_char(ch, "Specify a shop VNUM to edit.\r\n");
+    return;
+  } else if (!isdigit(*buf1)) {
+    if (str_cmp("save", buf1) != 0) {
+      send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+      return;
+    }
+    
+    save = TRUE;
+    
+    if (is_number(buf2))
+      number = atoi(buf2);
+    else if (GET_OLC_ZONE(ch) > 0) {
+      zone_rnum zlok;
+      
+      if ((zlok = real_zone(GET_OLC_ZONE(ch))) == NOWHERE)
+        number = NOWHERE;
+      else
+        number = genolc_zone_bottom(zlok);
+    }
+    
+    if (number == NOWHERE) {
+      send_to_char(ch, "Save which zone?\r\n");
+      return;
+    }
+  }
+  
+  /****************************************************************************/
+  /** If a numeric argument was given, get it.                               **/
+  /****************************************************************************/
+  if (number == NOWHERE)
+    number = atoi(buf1);
+  
+  /****************************************************************************/
+  /** Check that the shop isn't already being edited.                        **/
+  /****************************************************************************/
+  for (d = descriptor_list; d; d = d->next) {
+    if (STATE(d) == CON_SEDIT) {
+      if (d->olc && OLC_NUM(d) == number) {
+        send_to_char(ch, "That shop is currently being edited by %s.\r\n",
+          PERS(d->character, ch));
+        return;
+      }
+    }
+  }
+  
+  /****************************************************************************/
+  /** Point d to the builder's descriptor.                                   **/
+  /****************************************************************************/
+  d = ch->desc;
+  
+  /****************************************************************************/
+  /** Give the descriptor an OLC structure.                                  **/
+  /****************************************************************************/
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE,
+      "SYSERR: do_oasis_sedit: Player already had olc structure.");
+    free(d->olc);
+  }
+  
+  CREATE(d->olc, struct oasis_olc_data, 1);
+  
+  /****************************************************************************/
+  /** Find the zone.                                                         **/
+  /****************************************************************************/
+  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == NOWHERE) {
+    send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Everyone but IMPLs can only edit zones they have been assigned.        **/
+  /****************************************************************************/
+  if (!can_edit_zone(ch, OLC_ZNUM(d))) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    
+    /**************************************************************************/
+    /** Free the OLC structure.                                              **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  if (save) {
+    send_to_char(ch, "Saving all shops in zone %d.\r\n",
+      zone_table[OLC_ZNUM(d)].number);
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE,
+      "OLC: %s saves shop info for zone %d.",
+      GET_NAME(ch), zone_table[OLC_ZNUM(d)].number);
+    
+    /**************************************************************************/
+    /** Save the shops to the shop file.                                     **/
+    /**************************************************************************/
+    save_shops(OLC_ZNUM(d));
+    
+    /**************************************************************************/
+    /** Free the OLC structure.                                              **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  OLC_NUM(d) = number;
+  
+  if ((real_num = real_shop(number)) != NOTHING)
+    sedit_setup_existing(d, real_num);
+  else
+    sedit_setup_new(d);
+  
+  STATE(d) = CON_SEDIT;
+  
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  
+  mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s starts editing zone %d allowed zone %d",
+    GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+}
+
+void sedit_setup_new(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+
+  /*
+   * Allocate a scratch shop structure.
+   */
+  CREATE(shop, struct shop_data, 1);
+
+  /*
+   * Fill in some default values.
+   */
+  S_KEEPER(shop) = NOBODY;
+  S_CLOSE1(shop) = 28;
+  S_BUYPROFIT(shop) = 1.0;
+  S_SELLPROFIT(shop) = 1.0;
+  /*
+   * Add a spice of default strings.
+   */
+  S_NOITEM1(shop) = strdup("%s Sorry, I don't stock that item.");
+  S_NOITEM2(shop) = strdup("%s You don't seem to have that.");
+  S_NOCASH1(shop) = strdup("%s I can't afford that!");
+  S_NOCASH2(shop) = strdup("%s You are too poor!");
+  S_NOBUY(shop) = strdup("%s I don't trade in such items.");
+  S_BUY(shop) = strdup("%s That'll be %d coins, thanks.");
+  S_SELL(shop) = strdup("%s I'll give you %d coins for that.");
+  /*
+   * Stir the lists lightly.
+   */
+  CREATE(S_PRODUCTS(shop), obj_vnum, 1);
+
+  S_PRODUCT(shop, 0) = NOTHING;
+  CREATE(S_ROOMS(shop), room_rnum, 1);
+
+  S_ROOM(shop, 0) = NOWHERE;
+  CREATE(S_NAMELISTS(shop), struct shop_buy_data, 1);
+
+  S_BUYTYPE(shop, 0) = NOTHING;
+
+  /*
+   * Presto! A shop.
+   */
+  OLC_SHOP(d) = shop;
+  sedit_disp_menu(d);
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_setup_existing(struct descriptor_data *d, int rshop_num)
+{
+  /*
+   * Create a scratch shop structure.
+   */
+  CREATE(OLC_SHOP(d), struct shop_data, 1);
+
+  copy_shop(OLC_SHOP(d), shop_index + rshop_num);
+  sedit_disp_menu(d);
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+void sedit_products_menu(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+  int i;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  write_to_output(d, "##     VNUM     Product\r\n");
+  for (i = 0; S_PRODUCT(shop, i) != NOTHING; i++) {
+    write_to_output(d, "%2d - [%s%5d%s] - %s%s%s\r\n", i,
+	    cyn, obj_index[S_PRODUCT(shop, i)].vnum, nrm,
+	    yel, obj_proto[S_PRODUCT(shop, i)].short_description, nrm);
+  }
+  write_to_output(d, "\r\n"
+	  "%sA%s) Add a new product.\r\n"
+	  "%sD%s) Delete a product.\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
+
+  OLC_MODE(d) = SEDIT_PRODUCTS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_compact_rooms_menu(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+  int i, count = 0;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  for (i = 0; S_ROOM(shop, i) != NOWHERE; i++) {
+    write_to_output(d, "%2d - [%s%5d%s]  | %s", i, cyn, S_ROOM(shop, i), nrm,
+			!(++count % 5) ? "\r\n" : "");
+  }
+  write_to_output(d, "\r\n"
+	  "%sA%s) Add a new room.\r\n"
+	  "%sD%s) Delete a room.\r\n"
+	  "%sL%s) Long display.\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
+
+  OLC_MODE(d) = SEDIT_ROOMS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_rooms_menu(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+  int i;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  write_to_output(d, "##     VNUM     Room\r\n\r\n");
+  for (i = 0; S_ROOM(shop, i) != NOWHERE; i++) {
+    write_to_output(d, "%2d - [%s%5d%s] - %s%s%s\r\n", i, cyn, S_ROOM(shop, i), nrm,
+	    yel, world[real_room(S_ROOM(shop, i))].name, nrm);
+  }
+  write_to_output(d, "\r\n"
+	  "%sA%s) Add a new room.\r\n"
+	  "%sD%s) Delete a room.\r\n"
+	  "%sC%s) Compact Display.\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm, grn, nrm);
+
+  OLC_MODE(d) = SEDIT_ROOMS_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_namelist_menu(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+  int i;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  write_to_output(d, "##              Type   Namelist\r\n\r\n");
+  for (i = 0; S_BUYTYPE(shop, i) != NOTHING; i++) {
+    write_to_output(d, "%2d - %s%15s%s - %s%s%s\r\n", i, cyn,
+		item_types[S_BUYTYPE(shop, i)], nrm, yel,
+		S_BUYWORD(shop, i) ? S_BUYWORD(shop, i) : "<None>", nrm);
+  }
+  write_to_output(d, "\r\n"
+	  "%sA%s) Add a new entry.\r\n"
+	  "%sD%s) Delete an entry.\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter choice : ", grn, nrm, grn, nrm, grn, nrm);
+
+  OLC_MODE(d) = SEDIT_NAMELIST_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_shop_flags_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int i, count = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  for (i = 0; i < NUM_SHOP_FLAGS; i++) {
+    write_to_output(d, "%s%2d%s) %-20.20s   %s", grn, i + 1, nrm, shop_bits[i],
+		!(++count % 2) ? "\r\n" : "");
+  }
+  sprintbit(S_BITVECTOR(OLC_SHOP(d)), shop_bits, bits, sizeof(bits));
+  write_to_output(d, "\r\nCurrent Shop Flags : %s%s%s\r\nEnter choice : ",
+		cyn, bits, nrm);
+  OLC_MODE(d) = SEDIT_SHOP_FLAGS;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_no_trade_menu(struct descriptor_data *d)
+{
+  char bits[MAX_STRING_LENGTH];
+  int i, count = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  for (i = 0; i < NUM_TRADERS; i++) {
+    write_to_output(d, "%s%2d%s) %-20.20s   %s", grn, i + 1, nrm, trade_letters[i],
+		!(++count % 2) ? "\r\n" : "");
+  }
+  sprintbit(S_NOTRADE(OLC_SHOP(d)), trade_letters, bits, sizeof(bits));
+  write_to_output(d, "\r\nCurrently won't trade with: %s%s%s\r\n"
+	  "Enter choice : ", cyn, bits, nrm);
+  OLC_MODE(d) = SEDIT_NOTRADE;
+}
+
+/*-------------------------------------------------------------------*/
+
+void sedit_types_menu(struct descriptor_data *d)
+{
+  struct shop_data *shop;
+  int i, count = 0;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  for (i = 0; i < NUM_ITEM_TYPES; i++) {
+    write_to_output(d, "%s%2d%s) %s%-20s%s  %s", grn, i, nrm, cyn, item_types[i],
+		nrm, !(++count % 3) ? "\r\n" : "");
+  }
+  write_to_output(d, "%sEnter choice : ", nrm);
+  OLC_MODE(d) = SEDIT_TYPE_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Display main menu.
+ */
+void sedit_disp_menu(struct descriptor_data *d)
+{
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  struct shop_data *shop;
+
+  shop = OLC_SHOP(d);
+  get_char_colors(d->character);
+
+  clear_screen(d);
+  sprintbit(S_NOTRADE(shop), trade_letters, buf1, sizeof(buf1));
+  sprintbit(S_BITVECTOR(shop), shop_bits, buf2, sizeof(buf2));
+  write_to_output(d,
+	  "-- Shop Number : [%s%d%s]\r\n"
+	  "%s0%s) Keeper      : [%s%d%s] %s%s\r\n"
+          "%s1%s) Open 1      : %s%4d%s          %s2%s) Close 1     : %s%4d\r\n"
+          "%s3%s) Open 2      : %s%4d%s          %s4%s) Close 2     : %s%4d\r\n"
+	  "%s5%s) Sell rate   : %s%1.2f%s          %s6%s) Buy rate    : %s%1.2f\r\n"
+	  "%s7%s) Keeper no item : %s%s\r\n"
+	  "%s8%s) Player no item : %s%s\r\n"
+	  "%s9%s) Keeper no cash : %s%s\r\n"
+	  "%sA%s) Player no cash : %s%s\r\n"
+	  "%sB%s) Keeper no buy  : %s%s\r\n"
+	  "%sC%s) Buy sucess     : %s%s\r\n"
+	  "%sD%s) Sell sucess    : %s%s\r\n"
+	  "%sE%s) No Trade With  : %s%s\r\n"
+	  "%sF%s) Shop flags     : %s%s\r\n"
+	  "%sR%s) Rooms Menu\r\n"
+	  "%sP%s) Products Menu\r\n"
+	  "%sT%s) Accept Types Menu\r\n"
+	  "%sQ%s) Quit\r\n"
+	  "Enter Choice : ",
+
+	  cyn, OLC_NUM(d), nrm,
+	  grn, nrm, cyn, S_KEEPER(shop) == NOBODY ? -1 : mob_index[S_KEEPER(shop)].vnum,
+	  nrm, yel, S_KEEPER(shop) == NOBODY ? "None" : mob_proto[S_KEEPER(shop)].player.short_descr,
+	  grn, nrm, cyn, S_OPEN1(shop), nrm,
+	  grn, nrm, cyn, S_CLOSE1(shop),
+	  grn, nrm, cyn, S_OPEN2(shop), nrm,
+	  grn, nrm, cyn, S_CLOSE2(shop),
+	  grn, nrm, cyn, S_BUYPROFIT(shop), nrm,
+	  grn, nrm, cyn, S_SELLPROFIT(shop),
+	  grn, nrm, yel, S_NOITEM1(shop),
+	  grn, nrm, yel, S_NOITEM2(shop),
+	  grn, nrm, yel, S_NOCASH1(shop),
+	  grn, nrm, yel, S_NOCASH2(shop),
+	  grn, nrm, yel, S_NOBUY(shop),
+	  grn, nrm, yel, S_BUY(shop),
+	  grn, nrm, yel, S_SELL(shop),
+	  grn, nrm, cyn, buf1,
+	  grn, nrm, cyn, buf2,
+	  grn, nrm, grn, nrm, grn, nrm, grn, nrm
+  );
+
+  OLC_MODE(d) = SEDIT_MAIN_MENU;
+}
+
+/**************************************************************************
+  The GARGANTUAN event handler
+ **************************************************************************/
+
+void sedit_parse(struct descriptor_data *d, char *arg)
+{
+  int i;
+
+  if (OLC_MODE(d) > SEDIT_NUMERICAL_RESPONSE) {
+    if (!isdigit(arg[0]) && ((*arg == '-') && (!isdigit(arg[1])))) {
+      write_to_output(d, "Field must be numerical, try again : ");
+      return;
+    }
+  }
+  switch (OLC_MODE(d)) {
+/*-------------------------------------------------------------------*/
+  case SEDIT_CONFIRM_SAVESTRING:
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      sedit_save_internally(d);
+      mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE,
+        "OLC: %s edits shop %d", GET_NAME(d->character), OLC_NUM(d));
+      if (CONFIG_OLC_SAVE) {
+	sedit_save_to_disk(real_zone_by_thing(OLC_NUM(d)));
+	write_to_output(d, "Shop saved to disk.\r\n");
+      } else
+        write_to_output(d, "Shop saved to memory.\r\n");
+      cleanup_olc(d, CLEANUP_STRUCTS);
+      return;
+    case 'n':
+    case 'N':
+      cleanup_olc(d, CLEANUP_ALL);
+      return;
+    default:
+      write_to_output(d, "Invalid choice!\r\nDo you wish to save the shop? : ");
+      return;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case SEDIT_MAIN_MENU:
+    i = 0;
+    switch (*arg) {
+    case 'q':
+    case 'Q':
+      if (OLC_VAL(d)) {		/* Anything been changed? */
+	write_to_output(d, "Do you wish to save the changes to the shop? (y/n) : ");
+	OLC_MODE(d) = SEDIT_CONFIRM_SAVESTRING;
+      } else
+	cleanup_olc(d, CLEANUP_ALL);
+      return;
+    case '0':
+      OLC_MODE(d) = SEDIT_KEEPER;
+      write_to_output(d, "Enter vnum number of shop keeper : ");
+      return;
+    case '1':
+      OLC_MODE(d) = SEDIT_OPEN1;
+      write_to_output(d, "When does this shop open (a day has 28 hours) ? ");
+      i++;
+      break;
+    case '2':
+      OLC_MODE(d) = SEDIT_CLOSE1;
+      write_to_output(d, "When does this shop close (a day has 28 hours) ? ");
+      i++;
+      break;
+    case '3':
+      OLC_MODE(d) = SEDIT_OPEN2;
+      write_to_output(d, "When does this shop open (a day has 28 hours) ? ");
+      i++;
+      break;
+    case '4':
+      OLC_MODE(d) = SEDIT_CLOSE2;
+      write_to_output(d, "When does this shop close (a day has 28 hours) ? ");
+      i++;
+      break;
+    case '5':
+      OLC_MODE(d) = SEDIT_BUY_PROFIT;
+      i++;
+      break;
+    case '6':
+      OLC_MODE(d) = SEDIT_SELL_PROFIT;
+      i++;
+      break;
+    case '7':
+      OLC_MODE(d) = SEDIT_NOITEM1;
+      i--;
+      break;
+    case '8':
+      OLC_MODE(d) = SEDIT_NOITEM2;
+      i--;
+      break;
+    case '9':
+      OLC_MODE(d) = SEDIT_NOCASH1;
+      i--;
+      break;
+    case 'a':
+    case 'A':
+      OLC_MODE(d) = SEDIT_NOCASH2;
+      i--;
+      break;
+    case 'b':
+    case 'B':
+      OLC_MODE(d) = SEDIT_NOBUY;
+      i--;
+      break;
+    case 'c':
+    case 'C':
+      OLC_MODE(d) = SEDIT_BUY;
+      i--;
+      break;
+    case 'd':
+    case 'D':
+      OLC_MODE(d) = SEDIT_SELL;
+      i--;
+      break;
+    case 'e':
+    case 'E':
+      sedit_no_trade_menu(d);
+      return;
+    case 'f':
+    case 'F':
+      sedit_shop_flags_menu(d);
+      return;
+    case 'r':
+    case 'R':
+      sedit_rooms_menu(d);
+      return;
+    case 'p':
+    case 'P':
+      sedit_products_menu(d);
+      return;
+    case 't':
+    case 'T':
+      sedit_namelist_menu(d);
+      return;
+    default:
+      sedit_disp_menu(d);
+      return;
+    }
+
+    if (i == 0)
+      break;
+    else if (i == 1)
+      write_to_output(d, "\r\nEnter new value : ");
+    else if (i == -1)
+      write_to_output(d, "\r\nEnter new text :\r\n] ");
+    else
+      write_to_output(d, "Oops...\r\n");
+    return;
+/*-------------------------------------------------------------------*/
+  case SEDIT_NAMELIST_MENU:
+    switch (*arg) {
+    case 'a':
+    case 'A':
+      sedit_types_menu(d);
+      return;
+    case 'd':
+    case 'D':
+      write_to_output(d, "\r\nDelete which entry? : ");
+      OLC_MODE(d) = SEDIT_DELETE_TYPE;
+      return;
+    case 'q':
+    case 'Q':
+      break;
+    }
+    break;
+/*-------------------------------------------------------------------*/
+  case SEDIT_PRODUCTS_MENU:
+    switch (*arg) {
+    case 'a':
+    case 'A':
+      write_to_output(d, "\r\nEnter new product vnum number : ");
+      OLC_MODE(d) = SEDIT_NEW_PRODUCT;
+      return;
+    case 'd':
+    case 'D':
+      write_to_output(d, "\r\nDelete which product? : ");
+      OLC_MODE(d) = SEDIT_DELETE_PRODUCT;
+      return;
+    case 'q':
+    case 'Q':
+      break;
+    }
+    break;
+/*-------------------------------------------------------------------*/
+  case SEDIT_ROOMS_MENU:
+    switch (*arg) {
+    case 'a':
+    case 'A':
+      write_to_output(d, "\r\nEnter new room vnum number : ");
+      OLC_MODE(d) = SEDIT_NEW_ROOM;
+      return;
+    case 'c':
+    case 'C':
+      sedit_compact_rooms_menu(d);
+      return;
+    case 'l':
+    case 'L':
+      sedit_rooms_menu(d);
+      return;
+    case 'd':
+    case 'D':
+      write_to_output(d, "\r\nDelete which room? : ");
+      OLC_MODE(d) = SEDIT_DELETE_ROOM;
+      return;
+    case 'q':
+    case 'Q':
+      break;
+    }
+    break;
+/*-------------------------------------------------------------------*/
+    /*
+     * String edits.
+     */
+  case SEDIT_NOITEM1:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_NOITEM1(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_NOITEM2:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_NOITEM2(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_NOCASH1:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_NOCASH1(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_NOCASH2:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_NOCASH2(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_NOBUY:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_NOBUY(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_BUY:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_BUY(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_SELL:
+    if (genolc_checkstring(d, arg))
+      modify_string(&S_SELL(OLC_SHOP(d)), arg);
+    break;
+  case SEDIT_NAMELIST:
+    if (genolc_checkstring(d, arg)) {
+      struct shop_buy_data new_entry;
+
+      BUY_TYPE(new_entry) = OLC_VAL(d);
+      BUY_WORD(new_entry) = strdup(arg);
+      add_to_type_list(&(S_NAMELISTS(OLC_SHOP(d))), &new_entry);
+    }
+    sedit_namelist_menu(d);
+    return;
+
+/*-------------------------------------------------------------------*/
+    /*
+     * Numerical responses.
+     */
+  case SEDIT_KEEPER:
+    i = atoi(arg);
+    if ((i = atoi(arg)) != -1)
+      if ((i = real_mobile(i)) == NOBODY) {
+	write_to_output(d, "That mobile does not exist, try again : ");
+	return;
+      }
+    S_KEEPER(OLC_SHOP(d)) = i;
+    if (i == -1)
+      break;
+    /*
+     * Fiddle with special procs.
+     */
+    S_FUNC(OLC_SHOP(d)) =
+      mob_index[i].func != shop_keeper ? mob_index[i].func : NULL;
+    mob_index[i].func = shop_keeper;
+    break;
+  case SEDIT_OPEN1:
+    S_OPEN1(OLC_SHOP(d)) = LIMIT(atoi(arg), 0, 28);
+    break;
+  case SEDIT_OPEN2:
+    S_OPEN2(OLC_SHOP(d)) = LIMIT(atoi(arg), 0, 28);
+    break;
+  case SEDIT_CLOSE1:
+    S_CLOSE1(OLC_SHOP(d)) = LIMIT(atoi(arg), 0, 28);
+    break;
+  case SEDIT_CLOSE2:
+    S_CLOSE2(OLC_SHOP(d)) = LIMIT(atoi(arg), 0, 28);
+    break;
+  case SEDIT_BUY_PROFIT:
+    sscanf(arg, "%f", &S_BUYPROFIT(OLC_SHOP(d)));
+    break;
+  case SEDIT_SELL_PROFIT:
+    sscanf(arg, "%f", &S_SELLPROFIT(OLC_SHOP(d)));
+    break;
+  case SEDIT_TYPE_MENU:
+    OLC_VAL(d) = LIMIT(atoi(arg), 0, NUM_ITEM_TYPES - 1);
+    write_to_output(d, "Enter namelist (return for none) :-\r\n] ");
+    OLC_MODE(d) = SEDIT_NAMELIST;
+    return;
+  case SEDIT_DELETE_TYPE:
+    remove_from_type_list(&(S_NAMELISTS(OLC_SHOP(d))), atoi(arg));
+    sedit_namelist_menu(d);
+    return;
+  case SEDIT_NEW_PRODUCT:
+    if ((i = atoi(arg)) != -1)
+      if ((i = real_object(i)) == NOTHING) {
+	write_to_output(d, "That object does not exist, try again : ");
+	return;
+      }
+    if (i > 0)
+      add_to_int_list(&(S_PRODUCTS(OLC_SHOP(d))), i);
+    sedit_products_menu(d);
+    return;
+  case SEDIT_DELETE_PRODUCT:
+    remove_from_int_list(&(S_PRODUCTS(OLC_SHOP(d))), atoi(arg));
+    sedit_products_menu(d);
+    return;
+  case SEDIT_NEW_ROOM:
+    if ((i = atoi(arg)) != -1)
+      if ((i = real_room(i)) == NOWHERE) {
+	write_to_output(d, "That room does not exist, try again : ");
+	return;
+      }
+    if (i >= 0)
+      add_to_int_list(&(S_ROOMS(OLC_SHOP(d))), atoi(arg));
+    sedit_rooms_menu(d);
+    return;
+  case SEDIT_DELETE_ROOM:
+    remove_from_int_list(&(S_ROOMS(OLC_SHOP(d))), atoi(arg));
+    sedit_rooms_menu(d);
+    return;
+  case SEDIT_SHOP_FLAGS:
+    if ((i = LIMIT(atoi(arg), 0, NUM_SHOP_FLAGS)) > 0) {
+      TOGGLE_BIT(S_BITVECTOR(OLC_SHOP(d)), 1 << (i - 1));
+      sedit_shop_flags_menu(d);
+      return;
+    }
+    break;
+  case SEDIT_NOTRADE:
+    if ((i = LIMIT(atoi(arg), 0, NUM_TRADERS)) > 0) {
+      TOGGLE_BIT(S_NOTRADE(OLC_SHOP(d)), 1 << (i - 1));
+      sedit_no_trade_menu(d);
+      return;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  default:
+    /*
+     * We should never get here.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: sedit_parse(): Reached default case!");
+    write_to_output(d, "Oops...\r\n");
+    break;
+  }
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * END OF CASE 
+ * If we get here, we have probably changed something, and now want to
+ * return to main menu.  Use OLC_VAL as a 'has changed' flag.
+ */
+  OLC_VAL(d) = 1;
+  sedit_disp_menu(d);
+}
diff -BENbdpru circle-3.1/src/shop.c circle3.1_oasis206/src/shop.c
--- circle-3.1/src/shop.c	2002-10-04 06:38:04.000000000 +0200
+++ circle3.1_oasis206/src/shop.c	2003-10-07 11:12:04.000000000 +0200
@@ -187,7 +187,7 @@ int top(struct stack_data *stack)
   if (S_LEN(stack) > 0)
     return (S_DATA(stack, S_LEN(stack) - 1));
   else
-    return (NOTHING);
+    return (-1);
 }
 
 
@@ -276,10 +276,10 @@ int evaluate_expression(struct obj_data 
       }
     }
   }
-  while (top(&ops) != NOTHING)
+  while (top(&ops) != -1)
     evaluate_operation(&ops, &vals);
   temp = pop(&vals);
-  if (top(&vals) != NOTHING) {
+  if (top(&vals) != -1) {
     log("SYSERR: Extra operands left on shop keyword expression stack.");
     return (FALSE);
   }
@@ -1019,7 +1019,7 @@ int ok_damage_shopkeeper(struct char_dat
 /* val == obj_vnum and obj_rnum (?) */
 int add_to_list(struct shop_buy_data *list, int type, int *len, int *val)
 {
-  if (*val != NOTHING) {
+  if (*val != NOTHING && *val >= 0) { /* necessary after changing to unsigned v/rnums -- Welcor */
     if (*len < MAX_SHOP_OBJ) {
       if (type == LIST_PRODUCE)
 	*val = real_object(*val);
@@ -1096,9 +1096,9 @@ int read_type_list(FILE *shop_f, struct 
     else
       *(END_OF(buf) - 1) = '\0';
 
-    num = NOTHING;
+    num = -1;
 
-    if (strncmp(buf, "-1", 4) != 0)
+    if (strncmp(buf, "-1", 2) != 0)
       for (tindex = 0; *item_types[tindex] != '\n'; tindex++)
         if (!strn_cmp(item_types[tindex], buf, strlen(item_types[tindex]))) {
           num = tindex;
@@ -1107,7 +1107,7 @@ int read_type_list(FILE *shop_f, struct 
         }
 
     ptr = buf;
-    if (num == NOTHING) {
+    if (num == -1) {
       sscanf(buf, "%d", &num);
       while (!isdigit(*ptr))
 	ptr++;
@@ -1207,7 +1207,7 @@ void boot_the_shops(FILE *shop_f, char *
       shop_index[top_shop].message_buy = read_shop_message(5, SHOP_NUM(top_shop), shop_f, buf2);
       shop_index[top_shop].message_sell = read_shop_message(6, SHOP_NUM(top_shop), shop_f, buf2);
       read_line(shop_f, "%d", &SHOP_BROKE_TEMPER(top_shop));
-      read_line(shop_f, "%d", &SHOP_BITVECTOR(top_shop));
+      read_line(shop_f, "%ld", &SHOP_BITVECTOR(top_shop));
       read_line(shop_f, "%hd", &SHOP_KEEPER(top_shop));
 
       SHOP_KEEPER(top_shop) = real_mobile(SHOP_KEEPER(top_shop));
@@ -1530,3 +1530,15 @@ void destroy_shops(void)
   shop_index = NULL;
   top_shop = -1;
 }
+
+
+int count_shops(shop_vnum low, shop_vnum high)
+{
+  int i, j;
+  
+  for (i = j = 0; SHOP_NUM(i) <= high; i++)
+    if (SHOP_NUM(i) >= low)
+      j++;
+ 
+  return j;
+}
diff -BENbdpru circle-3.1/src/spec_assign.c circle3.1_oasis206/src/spec_assign.c
--- circle-3.1/src/spec_assign.c	2001-12-04 13:22:54.000000000 +0100
+++ circle3.1_oasis206/src/spec_assign.c	2003-07-26 10:19:22.000000000 +0200
@@ -18,7 +18,6 @@
 
 
 /* external globals */
-extern int dts_are_dumps;
 extern int mini_mud;
 
 /* external functions */
@@ -300,7 +299,7 @@ void assign_rooms(void)
   ASSIGNROOM(3030, dump);
   ASSIGNROOM(3031, pet_shops);
 
-  if (dts_are_dumps)
+  if (CONFIG_DTS_ARE_DUMPS)
     for (i = 0; i <= top_of_world; i++)
       if (ROOM_FLAGGED(i, ROOM_DEATH))
 	world[i].func = dump;
diff -BENbdpru circle-3.1/src/spec_procs.c circle3.1_oasis206/src/spec_procs.c
--- circle-3.1/src/spec_procs.c	2002-09-26 02:41:38.000000000 +0200
+++ circle3.1_oasis206/src/spec_procs.c	2003-07-26 10:19:22.000000000 +0200
@@ -122,8 +122,8 @@ extern int prac_params[4][NUM_CLASSES];
 void list_skills(struct char_data *ch)
 {
   const char *overflow = "\r\n**OVERFLOW**\r\n";
-  int i, sortpos, nlen;
-  size_t len = 0;
+  int i, sortpos;
+  size_t len = 0, nlen;
   char buf2[MAX_STRING_LENGTH];
 
   if (!GET_PRACTICES(ch)) {
diff -BENbdpru circle-3.1/src/spell_parser.c circle3.1_oasis206/src/spell_parser.c
--- circle-3.1/src/spell_parser.c	2002-04-09 16:12:16.000000000 +0200
+++ circle3.1_oasis206/src/spell_parser.c	2003-07-26 10:19:22.000000000 +0200
@@ -494,7 +494,7 @@ int cast_spell(struct char_data *ch, str
     send_to_char(ch, "You can't cast this spell if you're not in a group!\r\n");
     return (0);
   }
-  send_to_char(ch, "%s", OK);
+  send_to_char(ch, "%s", CONFIG_OK);
   say_spell(ch, spellnum, tch, tobj);
 
   return (call_magic(ch, tch, tobj, spellnum, GET_LEVEL(ch), CAST_SPELL));
diff -BENbdpru circle-3.1/src/spells.c circle3.1_oasis206/src/spells.c
--- circle-3.1/src/spells.c	2002-02-01 03:04:18.000000000 +0100
+++ circle3.1_oasis206/src/spells.c	2003-07-26 10:19:22.000000000 +0200
@@ -25,7 +25,6 @@
 /* external variables */
 extern room_rnum r_mortal_start_room;
 extern int mini_mud;
-extern int pk_allowed;
 
 /* external functions */
 void clearMemory(struct char_data *ch);
@@ -112,7 +111,7 @@ ASPELL(spell_summon)
     return;
   }
 
-  if (!pk_allowed) {
+  if (!CONFIG_PK_ALLOWED) {
     if (MOB_FLAGGED(victim, MOB_AGGRESSIVE)) {
       act("As the words escape your lips and $N travels\r\n"
 	  "through time and space towards you, you realize that $E is\r\n"
@@ -213,7 +212,7 @@ ASPELL(spell_charm)
   else if (AFF_FLAGGED(victim, AFF_CHARM) || level < GET_LEVEL(victim))
     send_to_char(ch, "You fail.\r\n");
   /* player charming another player - no legal reason for this */
-  else if (!pk_allowed && !IS_NPC(victim))
+  else if (!CONFIG_PK_ALLOWED && !IS_NPC(victim))
     send_to_char(ch, "You fail - shouldn't be doing it anyway.\r\n");
   else if (circle_follow(victim, ch))
     send_to_char(ch, "Sorry, following in circles can not be allowed.\r\n");
@@ -263,7 +262,8 @@ ASPELL(spell_identify)
     sprintbit(GET_OBJ_EXTRA(obj), extra_bits, bitbuf, sizeof(bitbuf));
     send_to_char(ch, "Item is: %s\r\n", bitbuf);
 
-    send_to_char(ch, "Weight: %d, Value: %d, Rent: %d\r\n", GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj));
+    send_to_char(ch, "Weight: %d, Value: %d, Rent: %d, Min. level: %d\r\n",
+                     GET_OBJ_WEIGHT(obj), GET_OBJ_COST(obj), GET_OBJ_RENT(obj), GET_OBJ_LEVEL(obj));
 
     switch (GET_OBJ_TYPE(obj)) {
     case ITEM_SCROLL:
diff -BENbdpru circle-3.1/src/structs.h circle3.1_oasis206/src/structs.h
--- circle-3.1/src/structs.h	2002-11-18 22:23:38.000000000 +0100
+++ circle3.1_oasis206/src/structs.h	2003-10-07 11:15:58.000000000 +0200
@@ -214,7 +214,9 @@
 #define PRF_NOGOSS	(1 << 19) /* Can't hear gossip channel		*/
 #define PRF_NOGRATZ	(1 << 20) /* Can't hear grats channel		*/
 #define PRF_ROOMFLAGS	(1 << 21) /* Can see room flags (ROOM_x)	*/
-#define PRF_DISPAUTO	(1 << 22) /* Show prompt HP, MP, MV when < 30%.	*/
+#define PRF_DISPAUTO	(1 << 22) /* Show prompt HP, MP, MV when < 25%.	*/
+#define PRF_CLS         (1 << 23) /* Clear screen in OLC                */
+#define PRF_BUILDWALK   (1 << 24) /* Build new rooms while walking ?    */
 
 /* Affect bits: used in char_data.char_specials.saved.affected_by */
 /* WARNING: In the world files, NEVER set the bits marked "R" ("Reserved") */
@@ -261,6 +263,14 @@
 #define CON_DELCNF1	 15	/* Delete confirmation 1		*/
 #define CON_DELCNF2	 16	/* Delete confirmation 2		*/
 #define CON_DISCONNECT	 17	/* In-game link loss (leave character)	*/
+#define CON_OEDIT	 18	/* OLC mode - object editor		*/
+#define CON_REDIT	 19	/* OLC mode - room editor		*/
+#define CON_ZEDIT	 20	/* OLC mode - zone info editor		*/
+#define CON_MEDIT	 21	/* OLC mode - mobile editor		*/
+#define CON_SEDIT	 22	/* OLC mode - shop editor		*/
+#define CON_TEDIT	 23	/* OLC mode - text editor		*/
+#define CON_CEDIT	 24	/* OLC mode - conf editor		*/
+#define CON_AEDIT        25     /* OLC mode - social (action) edit      */
 
 /* Character equipment positions: used as index for char_data.equipment[] */
 /* NOTE: Don't confuse these constants with the ITEM_ bitvectors
@@ -457,6 +467,9 @@
 #define LVL_GOD		32
 #define LVL_IMMORT	31
 
+/* Builders that have access to the saveall command */
+#define LVL_BUILDER	LVL_GRGOD
+
 /* Level of the 'freeze' command */
 #define LVL_FREEZE	LVL_GRGOD
 
@@ -493,7 +506,7 @@
 #define LARGE_BUFSIZE	   (MAX_SOCK_BUF - GARBAGE_SPACE - MAX_PROMPT_LENGTH)
 
 #define HISTORY_SIZE		5	/* Keep last 5 commands. */
-#define MAX_STRING_LENGTH	8192
+#define MAX_STRING_LENGTH	16384   
 #define MAX_INPUT_LENGTH	256	/* Max length per *line* of input */
 #define MAX_RAW_INPUT_LENGTH	512	/* Max size of *raw* input */
 #define MAX_MESSAGES		60
@@ -574,11 +587,12 @@ struct extra_descr_data {
 
 /* object-related structures ******************************************/
 
-
+#define NUM_OBJ_VAL_POSITIONS 4
 /* object flags; used in obj_data */
 struct obj_flag_data {
-   int	value[4];	/* Values of the item (see list)    */
+   int	value[NUM_OBJ_VAL_POSITIONS];	/* Values of the item (see list)    */
    byte type_flag;	/* Type of item			    */
+   int level;		/* Minimum level of object.		*/
    int /*bitvector_t*/	wear_flags;	/* Where you can wear it	    */
    int /*bitvector_t*/	extra_flags;	/* If it hums, glows, etc.	    */
    int	weight;		/* Weigt what else                  */
@@ -630,7 +644,7 @@ struct obj_file_elem {
 #if USE_AUTOEQ
    sh_int location;
 #endif
-   int	value[4];
+   int	value[NUM_OBJ_VAL_POSITIONS];
    int /*bitvector_t*/	extra_flags;
    int	weight;
    int	timer;
@@ -834,7 +848,7 @@ struct player_special_data_saved {
    ubyte spare4;
    ubyte spare5;
    int spells_to_learn;		/* How many can you learn yet this level*/
-   int spare7;
+   int olc_zone;
    int spare8;
    int spare9;
    int spare10;
@@ -990,7 +1004,8 @@ struct descriptor_data {
    int  showstr_count;		/* number of pages to page through	*/
    int  showstr_page;		/* which page are we currently showing?	*/
    char	**str;			/* for the modify-str system		*/
-   size_t max_str;	        /*		-			*/
+   char *backstr;		/* backup string for modify-str system	*/
+   size_t max_str;	        /* maximum size of string in modify-str	*/
    long	mail_to;		/* name for mail system			*/
    int	has_prompt;		/* is the user at a prompt?             */
    char	inbuf[MAX_RAW_INPUT_LENGTH];  /* buffer for raw input		*/
@@ -1008,6 +1023,7 @@ struct descriptor_data {
    struct descriptor_data *snooping; /* Who is this char snooping	*/
    struct descriptor_data *snoop_by; /* And who is snooping this char	*/
    struct descriptor_data *next; /* link to next descriptor		*/
+   struct oasis_olc_data *olc;   /* OLC info                            */
 };
 
 
@@ -1036,6 +1052,42 @@ struct message_list {
    struct message_type *msg;	/* List of messages.			*/
 };
 
+/* used in the socials */
+struct social_messg {
+  int act_nr;
+  char *command;               /* holds copy of activating command */
+  char *sort_as;              /* holds a copy of a similar command or
+                               * abbreviation to sort by for the parser */
+  int hide;                   /* ? */
+  int min_victim_position;    /* Position of victim */
+  int min_char_position;      /* Position of char */
+  int min_level_char;          /* Minimum level of socialing char */
+
+  /* No argument was supplied */
+  char *char_no_arg;
+  char *others_no_arg;
+
+  /* An argument was there, and a victim was found */
+  char *char_found;
+  char *others_found;
+  char *vict_found;
+
+  /* An argument was there, as well as a body part, and a victim was found */
+  char *char_body_found;
+  char *others_body_found;
+  char *vict_body_found;
+
+  /* An argument was there, but no victim was found */
+  char *not_found;
+
+  /* The victim turned out to be the character */
+  char *char_auto;
+  char *others_auto;
+
+  /* If the char cant be found search the char's inven and do these: */
+  char *char_obj_found;
+  char *others_obj_found;
+};
 
 struct dex_skill_type {
    sh_int p_pocket;
@@ -1101,3 +1153,105 @@ struct guild_info_type {
   room_vnum guild_room;
   int direction;
 };
+
+/*
+ * Config structs
+ * 
+ */
+ 
+ /*
+ * The game configuration structure used for configurating the game play 
+ * variables.
+ */
+struct game_data {
+  int pk_allowed;         /* Is player killing allowed? 	  */
+  int pt_allowed;         /* Is player thieving allowed?	  */
+  int level_can_shout;	  /* Level player must be to shout.	  */
+  int holler_move_cost;	  /* Cost to holler in move points.	  */
+  int tunnel_size;        /* Number of people allowed in a tunnel.*/
+  int max_exp_gain;       /* Maximum experience gainable per kill.*/
+  int max_exp_loss;       /* Maximum experience losable per death.*/
+  int max_npc_corpse_time;/* Num tics before NPC corpses decompose*/
+  int max_pc_corpse_time; /* Num tics before PC corpse decomposes.*/
+  int idle_void;          /* Num tics before PC sent to void(idle)*/
+  int idle_rent_time;     /* Num tics before PC is autorented.	  */
+  int idle_max_level;     /* Level of players immune to idle.     */
+  int dts_are_dumps;      /* Should items in dt's be junked?	  */
+  int load_into_inventory;/* Objects load in immortals inventory. */
+  int track_through_doors;/* Track through doors while closed?    */
+  int immort_level_ok;    /* Automatically level mortals to imm?  */
+  
+  char *OK;               /* When player receives 'Okay.' text.	  */
+  char *NOPERSON;         /* 'No-one by that name here.'	  */
+  char *NOEFFECT;         /* 'Nothing seems to happen.'	          */
+};
+
+
+
+/*
+ * The rent and crashsave options.
+ */
+struct crash_save_data {
+  int free_rent;          /* Should the MUD allow rent for free?  */
+  int max_obj_save;       /* Max items players can rent.          */
+  int min_rent_cost;      /* surcharge on top of item costs.	  */
+  int auto_save;          /* Does the game automatically save ppl?*/
+  int autosave_time;      /* if auto_save=TRUE, how often?        */
+  int crash_file_timeout; /* Life of crashfiles and idlesaves.    */
+  int rent_file_timeout;  /* Lifetime of normal rent files in days*/
+};
+
+
+/*
+ * The room numbers. 
+ */
+struct room_numbers {
+  room_vnum mortal_start_room;	/* vnum of room that mortals enter at.  */
+  room_vnum immort_start_room;  /* vnum of room that immorts enter at.  */
+  room_vnum frozen_start_room;  /* vnum of room that frozen ppl enter.  */
+  room_vnum donation_room_1;    /* vnum of donation room #1.            */
+  room_vnum donation_room_2;    /* vnum of donation room #2.            */
+  room_vnum donation_room_3;    /* vnum of donation room #3.	        */
+};
+
+
+/*
+ * The game operational constants.
+ */
+struct game_operation {
+  ush_int DFLT_PORT;        /* The default port to run the game.  */
+  char *DFLT_IP;            /* Bind to all interfaces.		  */
+  char *DFLT_DIR;           /* The default directory (lib).	  */
+  char *LOGNAME;            /* The file to log messages to.	  */
+  int max_playing;          /* Maximum number of players allowed. */
+  int max_filesize;         /* Maximum size of misc files.	  */
+  int max_bad_pws;          /* Maximum number of pword attempts.  */
+  int siteok_everyone;	    /* Everyone from all sites are SITEOK.*/
+  int nameserver_is_slow;   /* Is the nameserver slow or fast?	  */
+  int use_new_socials;      /* Use new or old socials file ?      */
+  int auto_save_olc;        /* Does OLC save to disk right away ? */
+  char *MENU;               /* The MAIN MENU.			  */
+  char *WELC_MESSG;	    /* The welcome message.		  */
+  char *START_MESSG;        /* The start msg for new characters.  */
+};
+
+/*
+ * The Autowizard options.
+ */
+struct autowiz_data {
+  int use_autowiz;        /* Use the autowiz feature?		*/
+  int min_wizlist_lev;    /* Minimun level to show on wizlist.	*/
+};
+
+/*
+ * The main configuration structure;
+ */
+struct config_data {
+  char                   *CONFFILE;	/* config file path	 */
+  struct game_data       play;		/* play related config   */
+  struct crash_save_data csd;		/* rent and save related */
+  struct room_numbers    room_nums;	/* room numbers          */
+  struct game_operation  operation;	/* basic operation       */
+  struct autowiz_data    autowiz;	/* autowiz related stuff */
+};
+
diff -BENbdpru circle-3.1/src/tedit.c circle3.1_oasis206/src/tedit.c
--- circle-3.1/src/tedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/tedit.c	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,148 @@
+/*
+ * Originally written by: Michael Scott -- Manx.
+ * Last known e-mail address: scottm@workcomm.net
+ *
+ * XXX: This needs Oasis-ifying.
+ */
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "utils.h"
+#include "interpreter.h"
+#include "comm.h"
+#include "db.h"
+#include "genolc.h"
+#include "oasis.h"
+#include "improved-edit.h"
+#include "tedit.h"
+
+extern const char *credits;
+extern const char *news;
+extern const char *motd;
+extern const char *imotd;
+extern const char *help;
+extern const char *info;
+extern const char *background;
+extern const char *handbook;
+extern const char *policies;
+
+void tedit_string_cleanup(struct descriptor_data *d, int terminator)
+{
+  FILE *fl;
+  char *storage = OLC_STORAGE(d);
+
+  if (!storage)
+    terminator = STRINGADD_ABORT;
+
+  switch (terminator) {
+  case STRINGADD_SAVE:
+    if (!(fl = fopen(storage, "w")))
+      mudlog(CMP, LVL_IMPL, TRUE, "SYSERR: Can't write file '%s'.", storage);
+    else {
+      if (*d->str) {
+        strip_cr(*d->str);
+        fputs(*d->str, fl);
+      }
+      fclose(fl);
+      mudlog(CMP, LVL_GOD, TRUE, "OLC: %s saves '%s'.", GET_NAME(d->character), storage);
+      write_to_output(d, "Saved.\r\n");
+    }
+    break;
+  case STRINGADD_ABORT:
+    write_to_output(d, "Edit aborted.\r\n");
+    act("$n stops editing some scrolls.", TRUE, d->character, 0, 0, TO_ROOM);
+    break;
+  default:
+    log("SYSERR: tedit_string_cleanup: Unknown terminator status.");
+    break;
+  }
+
+  /* Common cleanup code. */
+  cleanup_olc(d, CLEANUP_ALL);
+  STATE(d) = CON_PLAYING;
+}
+
+ACMD(do_tedit)
+{
+  int l, i = 0;
+  char field[MAX_INPUT_LENGTH];
+  char *backstr = NULL;
+   
+  struct {
+    char *cmd;
+    char level;
+    const char **buffer;
+    int  size;
+    char *filename;
+  } fields[] = {
+	/* edit the lvls to your own needs */
+	{ "credits",	LVL_IMPL,	&credits,	2400,	CREDITS_FILE},
+	{ "news",	LVL_GRGOD,	&news,		8192,	NEWS_FILE},
+	{ "motd",	LVL_GRGOD,	&motd,		2400,	MOTD_FILE},
+	{ "imotd",	LVL_IMPL,	&imotd,		2400,	IMOTD_FILE},
+	{ "help",       LVL_GRGOD,	&help,		2400,	HELP_PAGE_FILE},
+	{ "info",	LVL_GRGOD,	&info,		8192,	INFO_FILE},
+	{ "background",	LVL_IMPL,	&background,	8192,	BACKGROUND_FILE},
+	{ "handbook",   LVL_IMPL,	&handbook,	8192,   HANDBOOK_FILE},
+	{ "policies",	LVL_IMPL,	&policies,	8192,	POLICIES_FILE},
+	{ "\n",		0,		NULL,		0,	NULL }
+  };
+
+  if (ch->desc == NULL)
+    return;
+   
+  one_argument(argument, field);
+
+  if (!*field) {
+    send_to_char(ch, "Files available to be edited:\r\n");
+    for (l = 0; *fields[l].cmd != '\n'; l++) {
+      if (GET_LEVEL(ch) >= fields[l].level) {
+	send_to_char(ch, "%-11.11s ", fields[l].cmd);
+	if (!(++i % 7))
+	  send_to_char(ch, "\r\n");
+      }
+    }
+    if (i % 7)
+      send_to_char(ch, "\r\n");
+    if (i == 0)
+      send_to_char(ch, "None.\r\n");
+    return;
+  }
+  for (l = 0; *(fields[l].cmd) != '\n'; l++)
+    if (!strncmp(field, fields[l].cmd, strlen(field)))
+      break;
+   
+  if (*fields[l].cmd == '\n') {
+    send_to_char(ch, "Invalid text editor option.\r\n");
+    return;
+  }
+   
+  if (GET_LEVEL(ch) < fields[l].level) {
+    send_to_char(ch, "You are not godly enough for that!\r\n");
+    return;
+  }
+
+  /* set up editor stats */
+  clear_screen(ch->desc);
+  send_editor_help(ch->desc);
+  send_to_char(ch, "Edit file below:\r\n\r\n");
+
+  if (ch->desc->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_tedit: Player already had olc structure.");
+    free(ch->desc->olc);
+  }
+  CREATE(ch->desc->olc, struct oasis_olc_data, 1);
+  
+  if (*fields[l].buffer) {
+    send_to_char(ch, "%s", *fields[l].buffer);
+    backstr = strdup(*fields[l].buffer);
+  }
+
+  OLC_STORAGE(ch->desc) = strdup(fields[l].filename);
+  string_write(ch->desc, (char **)fields[l].buffer, fields[l].size, 0, backstr);
+
+  act("$n begins editing a scroll.", TRUE, ch, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  STATE(ch->desc) = CON_TEDIT;
+}
diff -BENbdpru circle-3.1/src/tedit.h circle3.1_oasis206/src/tedit.h
--- circle-3.1/src/tedit.h	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/tedit.h	2003-07-26 10:19:22.000000000 +0200
@@ -0,0 +1,3 @@
+ACMD(do_tedit);
+void tedit_string_cleanup(struct descriptor_data *d, int terminator);
+
diff -BENbdpru circle-3.1/src/utils.h circle3.1_oasis206/src/utils.h
--- circle-3.1/src/utils.h	2002-11-18 03:29:42.000000000 +0100
+++ circle3.1_oasis206/src/utils.h	2003-10-07 11:28:32.000000000 +0200
@@ -320,6 +320,7 @@ void	update_pos(struct char_data *victim
 #define GET_TALK(ch, i)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.talks[i]))
 #define POOFIN(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofin))
 #define POOFOUT(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->poofout))
+#define GET_OLC_ZONE(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->saved.olc_zone))
 #define GET_LAST_OLC_TARG(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_targ))
 #define GET_LAST_OLC_MODE(ch)	CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->last_olc_mode))
 #define GET_ALIASES(ch)		CHECK_PLAYER_SPECIAL((ch), ((ch)->player_specials->aliases))
@@ -339,7 +340,7 @@ void	update_pos(struct char_data *victim
 #define MEMORY(ch)		((ch)->mob_specials.memory)
 
 #define STRENGTH_APPLY_INDEX(ch) \
-        ( ((GET_ADD(ch)==0) || (GET_STR(ch) != 18)) ? GET_STR(ch) :\
+        ( ((GET_ADD(ch) ==0) || (GET_STR(ch) != 18)) ? GET_STR(ch) :\
           (GET_ADD(ch) <= 50) ? 26 :( \
           (GET_ADD(ch) <= 75) ? 27 :( \
           (GET_ADD(ch) <= 90) ? 28 :( \
@@ -370,6 +371,11 @@ void	update_pos(struct char_data *victim
 /* Hrm, not many.  We should make more. -gg 3/4/99 */
 #define STATE(d)	((d)->connected)
 
+#define IS_PLAYING(d)   (STATE(d) == CON_TEDIT || STATE(d) == CON_REDIT ||      \
+                        STATE(d) == CON_MEDIT || STATE(d) == CON_OEDIT ||       \
+                        STATE(d) == CON_ZEDIT || STATE(d) == CON_SEDIT ||       \
+                        STATE(d) == CON_CEDIT || STATE(d) == CON_PLAYING ||     \
+                        STATE(d) == CON_AEDIT)
 
 /* object utils **********************************************************/
 
@@ -381,6 +387,8 @@ void	update_pos(struct char_data *victim
 #define VALID_OBJ_RNUM(obj)	(GET_OBJ_RNUM(obj) <= top_of_objt && \
 				 GET_OBJ_RNUM(obj) != NOTHING)
 
+#define GET_OBJ_LEVEL(obj)      ((obj)->obj_flags.level)
+#define GET_OBJ_PERM(obj)       ((obj)->obj_flags.bitvector)
 #define GET_OBJ_TYPE(obj)	((obj)->obj_flags.type_flag)
 #define GET_OBJ_COST(obj)	((obj)->obj_flags.cost)
 #define GET_OBJ_RENT(obj)	((obj)->obj_flags.cost_per_day)
@@ -475,6 +483,8 @@ void	update_pos(struct char_data *victim
 
 
 #define EXIT(ch, door)  (world[IN_ROOM(ch)].dir_option[door])
+#define W_EXIT(room, num)     (world[(room)].dir_option[(num)])
+#define R_EXIT(room, num)     ((room)->dir_option[(num)])
 
 #define CAN_GO(ch, door) (EXIT(ch,door) && \
 			 (EXIT(ch,door)->to_room != NOWHERE) && \
@@ -511,6 +521,14 @@ void	update_pos(struct char_data *victim
 #define TRUE  (!FALSE)
 #endif
 
+#if !defined(YES)
+#define YES 1
+#endif
+
+#if !defined(NO)
+#define NO 0
+#endif
+
 /* defines for fseek */
 #ifndef SEEK_SET
 #define SEEK_SET	0
@@ -530,3 +548,63 @@ void	update_pos(struct char_data *victim
 #define CRYPT(a,b) ((char *) crypt((a),(b)))
 #endif
 
+/*******************  Config macros *********************/
+
+#define CONFIG_CONFFILE         config_info.CONFFILE
+
+#define CONFIG_PK_ALLOWED       config_info.play.pk_allowed
+#define CONFIG_PT_ALLOWED       config_info.play.pt_allowed
+#define CONFIG_LEVEL_CAN_SHOUT  config_info.play.level_can_shout
+#define CONFIG_HOLLER_MOVE_COST config_info.play.holler_move_cost
+#define CONFIG_TUNNEL_SIZE      config_info.play.tunnel_size
+#define CONFIG_MAX_EXP_GAIN     config_info.play.max_exp_gain
+#define CONFIG_MAX_EXP_LOSS     config_info.play.max_exp_loss
+#define CONFIG_MAX_NPC_CORPSE_TIME config_info.play.max_npc_corpse_time
+#define CONFIG_MAX_PC_CORPSE_TIME config_info.play.max_pc_corpse_time
+#define CONFIG_IDLE_VOID        config_info.play.idle_void
+#define CONFIG_IDLE_RENT_TIME   config_info.play.idle_rent_time
+#define CONFIG_IDLE_MAX_LEVEL   config_info.play.idle_max_level
+#define CONFIG_DTS_ARE_DUMPS    config_info.play.dts_are_dumps
+#define CONFIG_LOAD_INVENTORY   config_info.play.load_into_inventory
+#define CONFIG_TRACK_T_DOORS    config_info.play.track_through_doors
+#define CONFIG_IMMORT_LEVEL_OK  config_info.play.immort_level_ok
+#define CONFIG_OK               config_info.play.OK
+#define CONFIG_NOPERSON         config_info.play.NOPERSON
+#define CONFIG_NOEFFECT         config_info.play.NOEFFECT
+
+  /** Crash Saves **/
+#define CONFIG_FREE_RENT        config_info.csd.free_rent
+#define CONFIG_MAX_OBJ_SAVE     config_info.csd.max_obj_save
+#define CONFIG_MIN_RENT_COST    config_info.csd.min_rent_cost
+#define CONFIG_AUTO_SAVE        config_info.csd.auto_save
+#define CONFIG_AUTOSAVE_TIME    config_info.csd.autosave_time
+#define CONFIG_CRASH_TIMEOUT    config_info.csd.crash_file_timeout
+#define CONFIG_RENT_TIMEOUT     config_info.csd.rent_file_timeout
+
+  /** Room Numbers **/
+#define CONFIG_MORTAL_START     config_info.room_nums.mortal_start_room
+#define CONFIG_IMMORTAL_START   config_info.room_nums.immort_start_room
+#define CONFIG_FROZEN_START     config_info.room_nums.frozen_start_room
+#define CONFIG_DON_ROOM_1       config_info.room_nums.donation_room_1
+#define CONFIG_DON_ROOM_2       config_info.room_nums.donation_room_2
+#define CONFIG_DON_ROOM_3       config_info.room_nums.donation_room_3
+
+  /** Game Operation **/
+#define CONFIG_DFLT_PORT        config_info.operation.DFLT_PORT
+#define CONFIG_DFLT_IP          config_info.operation.DFLT_IP
+#define CONFIG_MAX_PLAYING      config_info.operation.max_playing
+#define CONFIG_MAX_FILESIZE     config_info.operation.max_filesize
+#define CONFIG_MAX_BAD_PWS      config_info.operation.max_bad_pws
+#define CONFIG_SITEOK_ALL       config_info.operation.siteok_everyone
+#define CONFIG_OLC_SAVE         config_info.operation.auto_save_olc
+#define CONFIG_NEW_SOCIALS      config_info.operation.use_new_socials
+#define CONFIG_NS_IS_SLOW       config_info.operation.nameserver_is_slow
+#define CONFIG_DFLT_DIR         config_info.operation.DFLT_DIR
+#define CONFIG_LOGNAME          config_info.operation.LOGNAME
+#define CONFIG_MENU             config_info.operation.MENU
+#define CONFIG_WELC_MESSG       config_info.operation.WELC_MESSG
+#define CONFIG_START_MESSG      config_info.operation.START_MESSG
+
+  /** Autowiz **/
+#define CONFIG_USE_AUTOWIZ      config_info.autowiz.use_autowiz
+#define CONFIG_MIN_WIZLIST_LEV  config_info.autowiz.min_wizlist_lev
diff -BENbdpru circle-3.1/src/zedit.c circle3.1_oasis206/src/zedit.c
--- circle-3.1/src/zedit.c	1970-01-01 01:00:00.000000000 +0100
+++ circle3.1_oasis206/src/zedit.c	2003-10-07 11:31:22.000000000 +0200
@@ -0,0 +1,1213 @@
+/************************************************************************
+ * OasisOLC - Zones / zedit.c					v2.0	*
+ * Copyright 1996 Harvey Gilpin						*
+ * Copyright 1997-2001 George Greer (greerga@circlemud.org)		*
+ ************************************************************************/
+
+#include "conf.h"
+#include "sysdep.h"
+#include "structs.h"
+#include "comm.h"
+#include "interpreter.h"
+#include "utils.h"
+#include "db.h"
+#include "constants.h"
+#include "genolc.h"
+#include "genzon.h"
+#include "oasis.h"
+
+/*-------------------------------------------------------------------*/
+
+extern struct zone_data *zone_table;
+extern zone_rnum top_of_zone_table;
+extern struct index_data *mob_index;
+extern struct char_data *mob_proto;
+extern struct index_data *obj_index;
+extern struct obj_data *obj_proto;
+extern struct descriptor_data *descriptor_list;
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Nasty internal macros to clean up the code.
+ */
+#define MYCMD		(OLC_ZONE(d)->cmd[subcmd])
+#define OLC_CMD(d)	(OLC_ZONE(d)->cmd[OLC_VAL(d)])
+
+/* Prototypes. */
+int start_change_command(struct descriptor_data *d, int pos);
+
+/*-------------------------------------------------------------------*/
+
+ACMD(do_oasis_zedit)
+{
+  int number = NOWHERE, save = 0, real_num;
+  struct descriptor_data *d;
+  char *buf3;
+  char buf1[MAX_STRING_LENGTH];
+  char buf2[MAX_STRING_LENGTH];
+  
+  /****************************************************************************/
+  /** Parse any arguments.                                                   **/
+  /****************************************************************************/
+  buf3 = two_arguments(argument, buf1, buf2);
+  
+  /****************************************************************************/
+  /** If no argument was given, use the zone the builder is standing in.     **/
+  /****************************************************************************/
+  if (!*buf1)
+    number = GET_ROOM_VNUM(IN_ROOM(ch));
+  else if (!isdigit(*buf1)) {
+    if (str_cmp("save", buf1) == 0) {
+      save = TRUE;
+      
+      if (is_number(buf2))
+        number = atoi(buf2);
+      else if (GET_OLC_ZONE(ch) > 0) {
+        zone_rnum zlok;
+        
+        if ((zlok = real_zone(GET_OLC_ZONE(ch))) == NOWHERE)
+          number = NOWHERE;
+        else
+          number = genolc_zone_bottom(zlok);
+      }
+      
+      if (number == NOWHERE) {
+        send_to_char(ch, "Save which zone?\r\n");
+        return;
+      }
+    } else if (GET_LEVEL(ch) >= LVL_IMPL) {
+      if (str_cmp("new", buf1) || !buf3 || !*buf3)
+        send_to_char(ch, "Format: zedit new <zone number> <bottom-room> "
+           "<upper-room>\r\n");
+      else {
+        char sbot[MAX_INPUT_LENGTH], stop[MAX_INPUT_LENGTH];
+        room_vnum bottom, top;
+        
+        skip_spaces(&buf3);
+        two_arguments(buf3, sbot, stop);
+        
+        number = atoi(buf2);
+        if (number < 0)
+          number = NOWHERE;
+        bottom = atoi(sbot);
+        top = atoi(stop);
+        
+        /**********************************************************************/
+        /** Setup the new zone (displays the menu to the builder).           **/
+        /**********************************************************************/
+        zedit_new_zone(ch, number, bottom, top);
+      }
+      
+      /************************************************************************/
+      /** Done now, exit the function.                                       **/
+      /************************************************************************/
+      return;
+      
+    } else {
+      send_to_char(ch, "Yikes!  Stop that, someone will get hurt!\r\n");
+      return;
+    }
+  }
+  
+  /****************************************************************************/
+  /** If a numeric argumentwas given, retrieve it.                           **/
+  /****************************************************************************/
+  if (number == NOWHERE)
+    number = atoi(buf1);
+  
+  /****************************************************************************/
+  /** Check that nobody is currently editing this zone.                      **/
+  /****************************************************************************/
+  for (d = descriptor_list; d; d = d->next) {
+    if (STATE(d) == CON_ZEDIT) {
+      if (d->olc && OLC_NUM(d) == number) {
+        send_to_char(ch, "That zone is currently being edited by %s.\r\n",
+          PERS(d->character, ch));
+        return;
+      }
+    }
+  }
+  
+  /****************************************************************************/
+  /** Store the builder's descriptor in d.                                   **/
+  /****************************************************************************/
+  d = ch->desc;
+  
+  /****************************************************************************/
+  /** Give the builder's descriptor an OLC structure.                        **/
+  /****************************************************************************/
+  if (d->olc) {
+    mudlog(BRF, LVL_IMMORT, TRUE, "SYSERR: do_oasis_zedit: Player already "
+      "had olc structure.");
+    free(d->olc);
+  }
+  
+  CREATE(d->olc, struct oasis_olc_data, 1);
+  
+  /****************************************************************************/
+  /** Find the zone.                                                         **/
+  /****************************************************************************/
+  if ((OLC_ZNUM(d) = real_zone_by_thing(number)) == NOWHERE) {
+    send_to_char(ch, "Sorry, there is no zone for that number!\r\n");
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** Everyone but IMPLs can only edit zones they have been assigned.        **/
+  /****************************************************************************/
+  if (!can_edit_zone(ch, OLC_ZNUM(d))) {
+    send_to_char(ch, "You do not have permission to edit this zone.\r\n");
+    mudlog(BRF, LVL_IMPL, TRUE,
+      "OLC: %s tried to edit zone %d allowed zone %d", GET_NAME(ch),
+      zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  /****************************************************************************/
+  /** If we need to save, then save the zone.                                **/
+  /****************************************************************************/
+  if (save) {
+    send_to_char(ch, "Saving all zone information for zone %d.\r\n",
+      zone_table[OLC_ZNUM(d)].number);
+    mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE,
+      "OLC: %s saves zone information for zone %d.", GET_NAME(ch),
+      zone_table[OLC_ZNUM(d)].number);
+    
+    /**************************************************************************/
+    /** Save the zone information to the zone file.                          **/
+    /**************************************************************************/
+    save_zone(OLC_ZNUM(d));
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+  
+  OLC_NUM(d) = number;
+  
+  if ((real_num = real_room(number)) == NOWHERE) {
+    write_to_output(d, "That room does not exist.\r\n");
+    
+    /**************************************************************************/
+    /** Free the descriptor's OLC structure.                                 **/
+    /**************************************************************************/
+    free(d->olc);
+    d->olc = NULL;
+    return;
+  }
+
+  zedit_setup(d, real_num);
+  STATE(d) = CON_ZEDIT;
+  
+  act("$n starts using OLC.", TRUE, d->character, 0, 0, TO_ROOM);
+  SET_BIT(PLR_FLAGS(ch), PLR_WRITING);
+  
+  mudlog(BRF, LVL_IMMORT, TRUE, "OLC: %s starts editing zone %d allowed zone %d",
+    GET_NAME(ch), zone_table[OLC_ZNUM(d)].number, GET_OLC_ZONE(ch));
+}
+
+void zedit_setup(struct descriptor_data *d, int room_num)
+{
+  struct zone_data *zone;
+  int subcmd = 0, count = 0, cmd_room = NOWHERE;
+
+  /*
+   * Allocate one scratch zone structure.  
+   */
+  CREATE(zone, struct zone_data, 1);
+
+  /*
+   * Copy all the zone header information over.
+   */
+  zone->name = strdup(zone_table[OLC_ZNUM(d)].name);
+  if (zone_table[OLC_ZNUM(d)].builders)
+    zone->builders = strdup(zone_table[OLC_ZNUM(d)].builders);
+  zone->lifespan = zone_table[OLC_ZNUM(d)].lifespan;
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+  zone->bot = zone_table[OLC_ZNUM(d)].bot;
+#endif
+  zone->top = zone_table[OLC_ZNUM(d)].top;
+  zone->reset_mode = zone_table[OLC_ZNUM(d)].reset_mode;
+  /*
+   * The remaining fields are used as a 'has been modified' flag  
+   */
+  zone->number = 0;	/* Header information has changed.	*/
+  zone->age = 0;	/* The commands have changed.		*/
+
+  /*
+   * Start the reset command list with a terminator.
+   */
+  CREATE(zone->cmd, struct reset_com, 1);
+  zone->cmd[0].command = 'S';
+
+  /*
+   * Add all entries in zone_table that relate to this room.
+   */
+  while (ZCMD(OLC_ZNUM(d), subcmd).command != 'S') {
+    switch (ZCMD(OLC_ZNUM(d), subcmd).command) {
+    case 'M':
+    case 'O':
+      cmd_room = ZCMD(OLC_ZNUM(d), subcmd).arg3;
+      break;
+    case 'D':
+    case 'R':
+      cmd_room = ZCMD(OLC_ZNUM(d), subcmd).arg1;
+      break;
+    default:
+      break;
+    }
+    if (cmd_room == room_num) {
+      add_cmd_to_list(&(zone->cmd), &ZCMD(OLC_ZNUM(d), subcmd), count);
+      count++;
+    }
+    subcmd++;
+  }
+
+  OLC_ZONE(d) = zone;
+  /*
+   * Display main menu.
+   */
+  zedit_disp_menu(d);
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Create a new zone.
+ */
+void zedit_new_zone(struct char_data *ch, zone_vnum vzone_num, room_vnum bottom, room_vnum top)
+{
+  int result;
+  const char *error;
+  struct descriptor_data *dsc;
+
+  if ((result = create_new_zone(vzone_num, bottom, top, &error)) == NOWHERE) {
+    write_to_output(ch->desc, error);
+    return;
+  }
+
+  for (dsc = descriptor_list; dsc; dsc = dsc->next) {
+    switch (STATE(dsc)) {
+      case CON_REDIT:
+        OLC_ROOM(dsc)->zone += (OLC_ZNUM(dsc) >= result);
+        /* Fall through. */
+      case CON_ZEDIT:
+      case CON_MEDIT:
+      case CON_SEDIT:
+      case CON_OEDIT:
+        OLC_ZNUM(dsc) += (OLC_ZNUM(dsc) >= result);
+        break;
+      default:
+        break;
+    }
+  }
+
+  zedit_save_to_disk(result); /* save to disk .. */
+
+  mudlog(BRF, MAX(LVL_BUILDER, GET_INVIS_LEV(ch)), TRUE,
+    "OLC: %s creates new zone #%d", GET_NAME(ch), vzone_num);
+  write_to_output(ch->desc, "Zone created successfully.\r\n");
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Save all the information in the player's temporary buffer back into
+ * the current zone table.
+ */
+void zedit_save_internally(struct descriptor_data *d)
+{
+  int	mobloaded = FALSE,
+	objloaded = FALSE,
+	subcmd;
+  room_rnum room_num = real_room(OLC_NUM(d));
+
+  if (room_num == NOWHERE) {
+    log("SYSERR: zedit_save_internally: OLC_NUM(d) room %d not found.", OLC_NUM(d));
+    return;
+  }
+
+  remove_room_zone_commands(OLC_ZNUM(d), room_num);
+
+  /*
+   * Now add all the entries in the players descriptor list  
+   */
+  for (subcmd = 0; MYCMD.command != 'S'; subcmd++) {
+    /*
+     * Since Circle does not keep track of what rooms the 'G', 'E', and
+     * 'P' commands are exitted in, but OasisOLC groups zone commands
+     * by rooms, this creates interesting problems when builders use these
+     * commands without loading a mob or object first.  This fix prevents such
+     * commands from being saved and 'wandering' through the zone command
+     * list looking for mobs/objects to latch onto.
+     * C.Raehl 4/27/99
+     */
+    switch (MYCMD.command) {
+      /* Possible fail cases. */
+      case 'G':
+      case 'E':
+        if (mobloaded)
+          break;
+        write_to_output(d, "Equip/Give command not saved since no mob was loaded first.\r\n");
+        continue;
+      case 'P':
+        if (objloaded)
+          break;
+        write_to_output(d, "Put command not saved since another object was not loaded first.\r\n");
+        continue;
+      /* Pass cases. */
+      case 'M':
+        mobloaded = TRUE;
+        break;
+      case 'O':
+        objloaded = TRUE;
+        break;
+      default:
+        mobloaded = objloaded = FALSE;
+        break;
+    }
+    add_cmd_to_list(&(zone_table[OLC_ZNUM(d)].cmd), &MYCMD, subcmd);
+  }
+
+  /*
+   * Finally, if zone headers have been changed, copy over  
+   */
+  if (OLC_ZONE(d)->number) {
+    free(zone_table[OLC_ZNUM(d)].name);
+    free(zone_table[OLC_ZNUM(d)].builders);
+    
+    zone_table[OLC_ZNUM(d)].name = strdup(OLC_ZONE(d)->name);
+    zone_table[OLC_ZNUM(d)].builders = strdup(OLC_ZONE(d)->builders);
+    zone_table[OLC_ZNUM(d)].bot = OLC_ZONE(d)->bot;
+    zone_table[OLC_ZNUM(d)].top = OLC_ZONE(d)->top;
+    zone_table[OLC_ZNUM(d)].reset_mode = OLC_ZONE(d)->reset_mode;
+    zone_table[OLC_ZNUM(d)].lifespan = OLC_ZONE(d)->lifespan;
+  }
+  add_to_save_list(zone_table[OLC_ZNUM(d)].number, SL_ZON);
+}
+
+/*-------------------------------------------------------------------*/
+
+void zedit_save_to_disk(int zone)
+{
+  save_zone(zone);
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Error check user input and then setup change  
+ */
+int start_change_command(struct descriptor_data *d, int pos)
+{
+  if (pos < 0 || pos >= count_commands(OLC_ZONE(d)->cmd))
+    return 0;
+
+  /*
+   * Ok, let's get editing.
+   */
+  OLC_VAL(d) = pos;
+  return 1;
+}
+
+/**************************************************************************
+ Menu functions 
+ **************************************************************************/
+
+/*
+ * the main menu 
+ */
+void zedit_disp_menu(struct descriptor_data *d)
+{
+  int subcmd = 0, room, counter = 0;
+
+  get_char_colors(d->character);
+  clear_screen(d);
+  room = real_room(OLC_NUM(d));
+
+  /*
+   * Menu header  
+   */
+  send_to_char(d->character, 
+	  "Room number: %s%d%s		Room zone: %s%d\r\n"
+	  "%s1%s) Builders       : %s%s\r\n"
+	  "%sZ%s) Zone name      : %s%s\r\n"
+	  "%sL%s) Lifespan       : %s%d minutes\r\n"
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+	  "%sB%s) Bottom of zone : %s%d\r\n"
+#endif
+	  "%sT%s) Top of zone    : %s%d\r\n"
+	  "%sR%s) Reset Mode     : %s%s%s\r\n"
+	  "[Command list]\r\n",
+
+	  cyn, OLC_NUM(d), nrm,
+	  cyn, zone_table[OLC_ZNUM(d)].number,
+	  grn, nrm, yel, OLC_ZONE(d)->builders ? OLC_ZONE(d)->builders : "None.",
+	  grn, nrm, yel, OLC_ZONE(d)->name ? OLC_ZONE(d)->name : "<NONE!>",
+	  grn, nrm, yel, OLC_ZONE(d)->lifespan,
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+	  grn, nrm, yel, OLC_ZONE(d)->bot,
+#endif
+	  grn, nrm, yel, OLC_ZONE(d)->top,
+	  grn, nrm,
+          yel,
+          OLC_ZONE(d)->reset_mode ? ((OLC_ZONE(d)->reset_mode == 1) ? "Reset when no players are in zone." : "Normal reset.") : "Never reset",
+          nrm
+	  );
+
+  /*
+   * Print the commands for this room into display buffer.
+   */
+  while (MYCMD.command != 'S') {
+    /*
+     * Translate what the command means.
+     */
+    write_to_output(d, "%s%d - %s", nrm, counter++, yel);
+    switch (MYCMD.command) {
+    case 'M':
+      write_to_output(d, "%sLoad %s [%s%d%s], Max : %d",
+              MYCMD.if_flag ? " then " : "",
+              mob_proto[MYCMD.arg1].player.short_descr, cyn,
+              mob_index[MYCMD.arg1].vnum, yel, MYCMD.arg2
+              );
+      break;
+    case 'G':
+      write_to_output(d, "%sGive it %s [%s%d%s], Max : %d",
+	      MYCMD.if_flag ? " then " : "",
+	      obj_proto[MYCMD.arg1].short_description,
+	      cyn, obj_index[MYCMD.arg1].vnum, yel,
+	      MYCMD.arg2
+	      );
+      break;
+    case 'O':
+      write_to_output(d, "%sLoad %s [%s%d%s], Max : %d",
+	      MYCMD.if_flag ? " then " : "",
+	      obj_proto[MYCMD.arg1].short_description,
+	      cyn, obj_index[MYCMD.arg1].vnum, yel,
+	      MYCMD.arg2
+	      );
+      break;
+    case 'E':
+      write_to_output(d, "%sEquip with %s [%s%d%s], %s, Max : %d",
+	      MYCMD.if_flag ? " then " : "",
+	      obj_proto[MYCMD.arg1].short_description,
+	      cyn, obj_index[MYCMD.arg1].vnum, yel,
+	      equipment_types[MYCMD.arg3],
+	      MYCMD.arg2
+	      );
+      break;
+    case 'P':
+      write_to_output(d, "%sPut %s [%s%d%s] in %s [%s%d%s], Max : %d",
+	      MYCMD.if_flag ? " then " : "",
+	      obj_proto[MYCMD.arg1].short_description,
+	      cyn, obj_index[MYCMD.arg1].vnum, yel,
+	      obj_proto[MYCMD.arg3].short_description,
+	      cyn, obj_index[MYCMD.arg3].vnum, yel,
+	      MYCMD.arg2
+	      );
+      break;
+    case 'R':
+      write_to_output(d, "%sRemove %s [%s%d%s] from room.",
+	      MYCMD.if_flag ? " then " : "",
+	      obj_proto[MYCMD.arg2].short_description,
+	      cyn, obj_index[MYCMD.arg2].vnum, yel
+	      );
+      break;
+    case 'D':
+      write_to_output(d, "%sSet door %s as %s.",
+	      MYCMD.if_flag ? " then " : "",
+	      dirs[MYCMD.arg2],
+	      MYCMD.arg3 ? ((MYCMD.arg3 == 1) ? "closed" : "locked") : "open"
+	      );
+      break;
+    default:
+      write_to_output(d, "<Unknown Command>");
+      break;
+    }
+    write_to_output(d, "\r\n");
+    subcmd++;
+  }
+  /*
+   * Finish off menu  
+   */
+   write_to_output(d,
+	  "%s%d - <END OF LIST>\r\n"
+	  "%sN%s) Insert new command.\r\n"
+	  "%sE%s) Edit a command.\r\n"
+	  "%sD%s) Delete a command.\r\n"
+	  "%sQ%s) Quit\r\nEnter your choice : ",
+	  nrm, counter, grn, nrm, grn, nrm, grn, nrm, grn, nrm
+	  );
+
+  OLC_MODE(d) = ZEDIT_MAIN_MENU;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Print the command type menu and setup response catch. 
+ */
+void zedit_disp_comtype(struct descriptor_data *d)
+{
+  get_char_colors(d->character);
+  clear_screen(d);
+  write_to_output(d,
+	"\r\n"
+	"%sM%s) Load Mobile to room             %sO%s) Load Object to room\r\n"
+	"%sE%s) Equip mobile with object        %sG%s) Give an object to a mobile\r\n"
+	"%sP%s) Put object in another object    %sD%s) Open/Close/Lock a Door\r\n"
+	"%sR%s) Remove an object from the room\r\n"
+	"\r\n"
+	"What sort of command will this be? : ",
+	grn, nrm, grn, nrm, grn, nrm, grn, nrm, grn, nrm,
+	grn, nrm, grn, nrm
+	);
+  OLC_MODE(d) = ZEDIT_COMMAND_TYPE;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Print the appropriate message for the command type for arg1 and set
+ * up the input catch clause  
+ */
+void zedit_disp_arg1(struct descriptor_data *d)
+{
+  write_to_output(d, "\r\n");
+
+  switch (OLC_CMD(d).command) {
+  case 'M':
+    write_to_output(d, "Input mob's vnum : ");
+    OLC_MODE(d) = ZEDIT_ARG1;
+    break;
+  case 'O':
+  case 'E':
+  case 'P':
+  case 'G':
+    write_to_output(d, "Input object vnum : ");
+    OLC_MODE(d) = ZEDIT_ARG1;
+    break;
+  case 'D':
+  case 'R':
+    /*
+     * Arg1 for these is the room number, skip to arg2  
+     */
+    OLC_CMD(d).arg1 = real_room(OLC_NUM(d));
+    zedit_disp_arg2(d);
+    break;
+  default:
+    /*
+     * We should never get here.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_disp_arg1(): Help!");
+    write_to_output(d, "Oops...\r\n");
+    return;
+  }
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Print the appropriate message for the command type for arg2 and set
+ * up the input catch clause.
+ */
+void zedit_disp_arg2(struct descriptor_data *d)
+{
+  int i;
+
+  write_to_output(d, "\r\n");
+
+  switch (OLC_CMD(d).command) {
+  case 'M':
+  case 'O':
+  case 'E':
+  case 'P':
+  case 'G':
+    write_to_output(d, "Input the maximum number that can exist on the mud : ");
+    break;
+  case 'D':
+    for (i = 0; *dirs[i] != '\n'; i++) {
+      write_to_output(d, "%d) Exit %s.\r\n", i, dirs[i]);
+    }
+    write_to_output(d, "Enter exit number for door : ");
+    break;
+  case 'R':
+    write_to_output(d, "Input object's vnum : ");
+    break;
+  default:
+    /*
+     * We should never get here, but just in case...
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_disp_arg2(): Help!");
+    write_to_output(d, "Oops...\r\n");
+    return;
+  }
+  OLC_MODE(d) = ZEDIT_ARG2;
+}
+
+/*-------------------------------------------------------------------*/
+
+/*
+ * Print the appropriate message for the command type for arg3 and set
+ * up the input catch clause.
+ */
+void zedit_disp_arg3(struct descriptor_data *d)
+{
+  int i = 0;
+
+  write_to_output(d, "\r\n");
+
+  switch (OLC_CMD(d).command) {
+  case 'E':
+    while (*equipment_types[i] != '\n') {
+      write_to_output(d, "%2d) %26.26s %2d) %26.26s\r\n", i,
+	   equipment_types[i], i + 1, (*equipment_types[i + 1] != '\n') ?
+	      equipment_types[i + 1] : "");
+      if (*equipment_types[i + 1] != '\n')
+	i += 2;
+      else
+	break;
+    }
+    write_to_output(d, "Location to equip : ");
+    break;
+  case 'P':
+    write_to_output(d, "Virtual number of the container : ");
+    break;
+  case 'D':
+    write_to_output(d, "0)  Door open\r\n"
+		"1)  Door closed\r\n"
+		"2)  Door locked\r\n"
+		"Enter state of the door : ");
+    break;
+  case 'M':
+  case 'O':
+  case 'R':
+  case 'G':
+  default:
+    /*
+     * We should never get here, just in case.
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_disp_arg3(): Help!");
+    write_to_output(d, "Oops...\r\n");
+    return;
+  }
+  OLC_MODE(d) = ZEDIT_ARG3;
+}
+
+/**************************************************************************
+  The GARGANTAUN event handler
+ **************************************************************************/
+
+void zedit_parse(struct descriptor_data *d, char *arg)
+{
+  int pos, i = 0;
+
+  switch (OLC_MODE(d)) {
+/*-------------------------------------------------------------------*/
+  case ZEDIT_CONFIRM_SAVESTRING:
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      /*
+       * Save the zone in memory, hiding invisible people.
+       */
+      zedit_save_internally(d);
+      if (CONFIG_OLC_SAVE) {
+	write_to_output(d, "Saving zone info to disk.\r\n");
+	zedit_save_to_disk(OLC_ZNUM(d));
+      } else
+        write_to_output(d, "Saving zone info in memory.\r\n");
+
+      mudlog(CMP, MAX(LVL_BUILDER, GET_INVIS_LEV(d->character)), TRUE,
+	"OLC: %s edits zone info for room %d.", GET_NAME(d->character), OLC_NUM(d));
+      /* FALL THROUGH */
+    case 'n':
+    case 'N':
+      cleanup_olc(d, CLEANUP_ALL);
+      break;
+    default:
+      write_to_output(d, "Invalid choice!\r\n");
+      write_to_output(d, "Do you wish to save the zone info? : ");
+      break;
+    }
+    break;
+   /* End of ZEDIT_CONFIRM_SAVESTRING */
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_MAIN_MENU:
+    switch (*arg) {
+    case 'q':
+    case 'Q':
+      if (OLC_ZONE(d)->age || OLC_ZONE(d)->number) {
+	write_to_output(d, "Do you wish to save the changes to the zone info? (y/n) : ");
+	OLC_MODE(d) = ZEDIT_CONFIRM_SAVESTRING;
+      } else {
+	write_to_output(d, "No changes made.\r\n");
+	cleanup_olc(d, CLEANUP_ALL);
+      }
+      break;
+    case 'n':
+    case 'N':
+      /*
+       * New entry.
+       */
+      if (OLC_ZONE(d)->cmd[0].command == 'S') {
+        /* first command */
+        if (new_command(OLC_ZONE(d), 0) && start_change_command(d, 0)) {
+	  zedit_disp_comtype(d);
+	  OLC_ZONE(d)->age = 1;
+          break;
+	}
+      }
+      write_to_output(d, "What number in the list should the new command be? : ");
+      OLC_MODE(d) = ZEDIT_NEW_ENTRY;
+      break;
+    case 'e':
+    case 'E':
+      /*
+       * Change an entry.
+       */
+      write_to_output(d, "Which command do you wish to change? : ");
+      OLC_MODE(d) = ZEDIT_CHANGE_ENTRY;
+      break;
+    case 'd':
+    case 'D':
+      /*
+       * Delete an entry.
+       */
+      write_to_output(d, "Which command do you wish to delete? : ");
+      OLC_MODE(d) = ZEDIT_DELETE_ENTRY;
+      break;
+    case 'z':
+    case 'Z':
+      /*
+       * Edit zone name.
+       */
+      write_to_output(d, "Enter new zone name : ");
+      OLC_MODE(d) = ZEDIT_ZONE_NAME;
+      break;
+    case '1':
+      /*
+       * Edit zone builders.
+       */
+      write_to_output(d, "Enter new builders list : ");
+      OLC_MODE(d) = ZEDIT_ZONE_BUILDERS;
+      break;
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+    case 'b':
+    case 'B':
+      /*
+       * Edit bottom of zone.
+       */
+      if (GET_LEVEL(d->character) < LVL_IMPL)
+	zedit_disp_menu(d);
+      else {
+	write_to_output(d, "Enter new bottom of zone : ");
+	OLC_MODE(d) = ZEDIT_ZONE_BOT;
+      }
+      break;
+#endif
+    case 't':
+    case 'T':
+      /*
+       * Edit top of zone.
+       */
+      if (GET_LEVEL(d->character) < LVL_IMPL)
+	zedit_disp_menu(d);
+      else {
+	write_to_output(d, "Enter new top of zone : ");
+	OLC_MODE(d) = ZEDIT_ZONE_TOP;
+      }
+      break;
+    case 'l':
+    case 'L':
+      /*
+       * Edit zone lifespan.
+       */
+      write_to_output(d, "Enter new zone lifespan : ");
+      OLC_MODE(d) = ZEDIT_ZONE_LIFE;
+      break;
+    case 'r':
+    case 'R':
+      /*
+       * Edit zone reset mode.
+       */
+      write_to_output(d, "\r\n"
+		"0) Never reset\r\n"
+		"1) Reset only when no players in zone\r\n"
+		"2) Normal reset\r\n"
+		"Enter new zone reset type : ");
+      OLC_MODE(d) = ZEDIT_ZONE_RESET;
+      break;
+    default:
+      zedit_disp_menu(d);
+      break;
+    }
+    break;
+    /* End of ZEDIT_MAIN_MENU */
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_NEW_ENTRY:
+    /*
+     * Get the line number and insert the new line.
+     */
+    pos = atoi(arg);
+    if (isdigit(*arg) && new_command(OLC_ZONE(d), pos)) {
+      if (start_change_command(d, pos)) {
+	zedit_disp_comtype(d);
+	OLC_ZONE(d)->age = 1;
+      }
+    } else
+      zedit_disp_menu(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_DELETE_ENTRY:
+    /*
+     * Get the line number and delete the line.
+     */
+    pos = atoi(arg);
+    if (isdigit(*arg)) {
+      delete_command(OLC_ZONE(d), pos);
+      OLC_ZONE(d)->age = 1;
+    }
+    zedit_disp_menu(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_CHANGE_ENTRY:
+    /*
+     * Parse the input for which line to edit, and goto next quiz.
+     */
+    /*
+     *  Abort edit, and return to main menu 
+     * - idea from Mark Garringer zizazat@hotmail.com
+     */
+    if (toupper(*arg) == 'A') { 
+      if (OLC_CMD(d).command == 'N') { 
+        OLC_CMD(d).command = '*';
+      } 
+      zedit_disp_menu(d);
+      break;
+    }
+
+    pos = atoi(arg);
+    if (isdigit(*arg) && start_change_command(d, pos)) {
+      zedit_disp_comtype(d);
+      OLC_ZONE(d)->age = 1;
+    } else
+      zedit_disp_menu(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_COMMAND_TYPE:
+    /*
+     * Parse the input for which type of command this is, and goto next
+     * quiz.
+     */
+    OLC_CMD(d).command = toupper(*arg);
+    if (!OLC_CMD(d).command || (strchr("MOPEDGR", OLC_CMD(d).command) == NULL)) {
+      write_to_output(d, "Invalid choice, try again : ");
+    } else {
+      if (OLC_VAL(d)) {	/* If there was a previous command. */
+	write_to_output(d, "Is this command dependent on the success of the previous one? (y/n)\r\n");
+	OLC_MODE(d) = ZEDIT_IF_FLAG;
+      } else {	/* 'if-flag' not appropriate. */
+	OLC_CMD(d).if_flag = 0;
+	zedit_disp_arg1(d);
+      }
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_IF_FLAG:
+    /*
+     * Parse the input for the if flag, and goto next quiz.
+     */
+    switch (*arg) {
+    case 'y':
+    case 'Y':
+      OLC_CMD(d).if_flag = 1;
+      break;
+    case 'n':
+    case 'N':
+      OLC_CMD(d).if_flag = 0;
+      break;
+    default:
+      write_to_output(d, "Try again : ");
+      return;
+    }
+    zedit_disp_arg1(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ARG1:
+    /*
+     * Parse the input for arg1, and goto next quiz.
+     */
+    if (!isdigit(*arg)) {
+      write_to_output(d, "Must be a numeric value, try again : ");
+      return;
+    }
+    switch (OLC_CMD(d).command) {
+    case 'M':
+      if ((pos = real_mobile(atoi(arg))) != NOBODY) {
+	OLC_CMD(d).arg1 = pos;
+	zedit_disp_arg2(d);
+      } else
+	write_to_output(d, "That mobile does not exist, try again : ");
+      break;
+    case 'O':
+    case 'P':
+    case 'E':
+    case 'G':
+      if ((pos = real_object(atoi(arg))) != NOTHING) {
+	OLC_CMD(d).arg1 = pos;
+	zedit_disp_arg2(d);
+      } else
+	write_to_output(d, "That object does not exist, try again : ");
+      break;
+    case 'D':
+    case 'R':
+    default:
+      /*
+       * We should never get here.
+       */
+      cleanup_olc(d, CLEANUP_ALL);
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_parse(): case ARG1: Ack!");
+      write_to_output(d, "Oops...\r\n");
+      break;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ARG2:
+    /*
+     * Parse the input for arg2, and goto next quiz.
+     */
+    if (!isdigit(*arg)) {
+      write_to_output(d, "Must be a numeric value, try again : ");
+      return;
+    }
+    switch (OLC_CMD(d).command) {
+    case 'M':
+    case 'O':
+      OLC_CMD(d).arg2 = MIN(MAX_DUPLICATES, atoi(arg));
+      OLC_CMD(d).arg3 = real_room(OLC_NUM(d));
+      zedit_disp_menu(d);
+      break;
+    case 'G':
+      OLC_CMD(d).arg2 = MIN(MAX_DUPLICATES, atoi(arg));
+      zedit_disp_menu(d);
+      break;
+    case 'P':
+    case 'E':
+      OLC_CMD(d).arg2 = MIN(MAX_DUPLICATES, atoi(arg));
+      zedit_disp_arg3(d);
+      break;
+    case 'D':
+      pos = atoi(arg);
+      /*
+       * Count directions.
+       */
+      if (pos < 0 || pos > NUM_OF_DIRS)
+	write_to_output(d, "Try again : ");
+      else {
+	OLC_CMD(d).arg2 = pos;
+	zedit_disp_arg3(d);
+      }
+      break;
+    case 'R':
+      if ((pos = real_object(atoi(arg))) != NOTHING) {
+	OLC_CMD(d).arg2 = pos;
+	zedit_disp_menu(d);
+      } else
+	write_to_output(d, "That object does not exist, try again : ");
+      break;
+    default:
+      /*
+       * We should never get here, but just in case...
+       */
+      cleanup_olc(d, CLEANUP_ALL);
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_parse(): case ARG2: Ack!");
+      write_to_output(d, "Oops...\r\n");
+      break;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ARG3:
+    /*
+     * Parse the input for arg3, and go back to main menu.
+     */
+    if (!isdigit(*arg)) {
+      write_to_output(d, "Must be a numeric value, try again : ");
+      return;
+    }
+    switch (OLC_CMD(d).command) {
+    case 'E':
+      pos = atoi(arg);
+      /*
+       * Count number of wear positions.  We could use NUM_WEARS, this is
+       * more reliable.
+       */
+      while (*equipment_types[i] != '\n')
+	i++;
+      if (pos < 0 || pos > i)
+	write_to_output(d, "Try again : ");
+      else {
+	OLC_CMD(d).arg3 = pos;
+	zedit_disp_menu(d);
+      }
+      break;
+    case 'P':
+      if ((pos = real_object(atoi(arg))) != NOTHING) {
+	OLC_CMD(d).arg3 = pos;
+	zedit_disp_menu(d);
+      } else
+	write_to_output(d, "That object does not exist, try again : ");
+      break;
+    case 'D':
+      pos = atoi(arg);
+      if (pos < 0 || pos > 2)
+	write_to_output(d, "Try again : ");
+      else {
+	OLC_CMD(d).arg3 = pos;
+	zedit_disp_menu(d);
+      }
+      break;
+    case 'M':
+    case 'O':
+    case 'G':
+    case 'R':
+    default:
+      /*
+       * We should never get here, but just in case...
+       */
+      cleanup_olc(d, CLEANUP_ALL);
+      mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_parse(): case ARG3: Ack!");
+      write_to_output(d, "Oops...\r\n");
+      break;
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ZONE_NAME:
+    /*
+     * Add new name and return to main menu.
+     */
+    if (genolc_checkstring(d, arg)) {
+      if (OLC_ZONE(d)->name)
+        free(OLC_ZONE(d)->name);
+      else
+        log("SYSERR: OLC: ZEDIT_ZONE_NAME: no name to free!");
+      OLC_ZONE(d)->name = strdup(arg);
+      OLC_ZONE(d)->number = 1;
+    }
+    zedit_disp_menu(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ZONE_BUILDERS:
+    /*
+     * Add new builders list and return to main menu.
+     */
+    if (genolc_checkstring(d, arg)) {
+      if (OLC_ZONE(d)->builders)
+        free(OLC_ZONE(d)->builders);
+      else
+        log("SYSERR: OLC: ZEDIT_ZONE_BUILDERS: no builders list to free!");
+      OLC_ZONE(d)->builders = strdup(arg);
+      OLC_ZONE(d)->number = 1;
+    }
+    zedit_disp_menu(d);
+    break;
+  
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ZONE_RESET:
+    /*
+     * Parse and add new reset_mode and return to main menu.
+     */
+    pos = atoi(arg);
+    if (!isdigit(*arg) || pos < 0 || pos > 2)
+      write_to_output(d, "Try again (0-2) : ");
+    else {
+      OLC_ZONE(d)->reset_mode = pos;
+      OLC_ZONE(d)->number = 1;
+      zedit_disp_menu(d);
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ZONE_LIFE:
+    /*
+     * Parse and add new lifespan and return to main menu.
+     */
+    pos = atoi(arg);
+    if (!isdigit(*arg) || pos < 0 || pos > 240)
+      write_to_output(d, "Try again (0-240) : ");
+    else {
+      OLC_ZONE(d)->lifespan = pos;
+      OLC_ZONE(d)->number = 1;
+      zedit_disp_menu(d);
+    }
+    break;
+
+/*-------------------------------------------------------------------*/
+#if _CIRCLEMUD >= CIRCLEMUD_VERSION(3,0,21)
+  case ZEDIT_ZONE_BOT:
+    /*
+     * Parse and add new bottom room in zone and return to main menu.
+     */
+    if (OLC_ZNUM(d) == 0)
+      OLC_ZONE(d)->bot = LIMIT(atoi(arg), 0, OLC_ZONE(d)->top);
+    else
+      OLC_ZONE(d)->bot = LIMIT(atoi(arg), zone_table[OLC_ZNUM(d) - 1].top + 1, OLC_ZONE(d)->top);
+    OLC_ZONE(d)->number = 1;
+    zedit_disp_menu(d);
+    break;
+#endif
+
+/*-------------------------------------------------------------------*/
+  case ZEDIT_ZONE_TOP:
+    /*
+     * Parse and add new top room in zone and return to main menu.
+     */
+    if (OLC_ZNUM(d) == top_of_zone_table)
+      OLC_ZONE(d)->top = LIMIT(atoi(arg), genolc_zonep_bottom(OLC_ZONE(d)), 32000);
+    else
+      OLC_ZONE(d)->top = LIMIT(atoi(arg), genolc_zonep_bottom(OLC_ZONE(d)), genolc_zone_bottom(OLC_ZNUM(d) + 1) - 1);
+    OLC_ZONE(d)->number = 1;
+    zedit_disp_menu(d);
+    break;
+
+/*-------------------------------------------------------------------*/
+  default:
+    /*
+     * We should never get here, but just in case...
+     */
+    cleanup_olc(d, CLEANUP_ALL);
+    mudlog(BRF, LVL_BUILDER, TRUE, "SYSERR: OLC: zedit_parse(): Reached default case!");
+    write_to_output(d, "Oops...\r\n");
+    break;
+  }
+}
+
+/******************************************************************************/
+/** End of parse_zedit()                                                     **/
+/******************************************************************************/
